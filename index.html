<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Shooter â€” LAN P2P (manual SDP)</title>
<style>
  :root{--bg:#000;--ui-bg:rgba(0,0,0,0.35);--btn:#222}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  canvas{display:block}
  .hud{position:absolute;left:8px;top:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px);font-size:14px}
  .players{position:absolute;left:8px;top:96px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px);white-space:pre-line;font-size:13px}
  .instructions{position:absolute;right:8px;top:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:280px;font-size:13px}
  .crosshair{position:absolute;left:50%;top:50%;width:12px;height:12px;margin:-6px 0 0 -6px;pointer-events:none;z-index:40}
  .crosshair:before,.crosshair:after{content:'';position:absolute;background:#fff}
  .crosshair:before{left:50%;top:0;transform:translateX(-50%);width:2px;height:12px}
  .crosshair:after{top:50%;left:0;transform:translateY(-50%);height:2px;width:12px}
  .weapon-wheel{position:absolute;left:50%;top:50%;width:260px;height:260px;margin:-130px 0 0 -130px;border-radius:50%;background:rgba(0,0,0,0.6);border:2px solid rgba(255,255,255,0.2);display:none;z-index:70;pointer-events:none;box-shadow:0 0 30px rgba(0,0,0,0.5)}
  .weapon-wheel.open{display:block}
  .weapon-wheel::after{content:'';position:absolute;left:50%;top:50%;width:80px;height:80px;margin:-40px 0 0 -40px;border-radius:50%;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.25)}
  .weapon-wheel-option{position:absolute;width:90px;height:90px;border-radius:14px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;text-align:center;font-size:13px;line-height:1.3;padding:8px;transform:translate(-50%,-50%);transition:background 0.15s,border 0.15s,transform 0.15s}
  .weapon-wheel-option strong{display:block;font-size:14px;margin-bottom:4px}
  .weapon-wheel-option span{display:block;font-size:12px;opacity:0.75}
  .weapon-wheel-option.active{background:rgba(255,255,255,0.25);border-color:rgba(255,255,255,0.55);transform:translate(-50%,-50%) scale(1.08)}
  .weapon-wheel-center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;font-size:16px;line-height:1.4}
  .weapon-wheel-center span{display:block;font-size:12px;opacity:0.7}
  .weapon-wheel-hint{position:absolute;left:50%;bottom:-34px;transform:translateX(-50%);font-size:12px;color:#ddd;text-align:center;opacity:0.9}
  #gameOver{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:90;padding:16px;background:rgba(0,0,0,0.9);display:none;text-align:center;border-radius:10px}
  #network{position:absolute;left:8px;bottom:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px)}
  .lobby-browser{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:120;background:rgba(7,7,7,0.92);border-radius:16px;padding:18px;display:none;min-width:520px;min-height:320px;box-shadow:0 18px 50px rgba(0,0,0,0.55)}
  .lobby-browser.open{display:flex;flex-direction:column;gap:12px}
  .lobby-browser-header{display:flex;justify-content:space-between;align-items:center;font-size:16px;font-weight:600}
  .lobby-browser-body{display:flex;gap:12px;flex:1;min-height:220px}
  .lobby-list{flex:1;display:flex;flex-direction:column;gap:6px;overflow-y:auto;padding-right:4px}
  .lobby-entry{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-radius:10px;background:rgba(255,255,255,0.06);cursor:pointer;border:1px solid transparent;transition:background 0.15s,border 0.15s}
  .lobby-entry:hover{background:rgba(255,255,255,0.12)}
  .lobby-entry.active{background:rgba(255,255,255,0.18);border-color:rgba(255,255,255,0.35)}
  .lobby-detail{flex:1.1;display:flex;flex-direction:column;gap:10px;padding:12px;border-radius:12px;background:rgba(255,255,255,0.04)}
  .lobby-detail h3{margin:0;font-size:18px}
  .lobby-player-list{flex:1;overflow-y:auto;background:rgba(0,0,0,0.25);border-radius:10px;padding:8px;font-size:13px}
  .lobby-player-list.empty{display:flex;align-items:center;justify-content:center;opacity:0.7}
  .lobby-actions{display:flex;gap:8px;justify-content:flex-end}
  textarea{width:480px;height:120px;background:#111;color:#fff;border:1px solid #333;padding:6px;border-radius:6px;resize:vertical}
  @media(max-width:640px){ textarea{width:calc(100vw - 32px)} .instructions{max-width:140px;font-size:12px} .hud,.players,.instructions,#network{padding:6px;font-size:13px} }
  button{padding:6px 10px;margin:4px;border-radius:8px;border:none;background:var(--btn);color:#fff;cursor:pointer}
  input[type="text"]{padding:6px;border-radius:6px;border:1px solid #333;background:#111;color:#fff}
  label{font-size:13px;margin-right:8px}
  .small{font-size:12px}
  .touch-controls{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:80;display:none}
  .touch-controls.active{display:block}
  .touch-joystick{position:absolute;width:150px;height:150px;border-radius:50%;border:2px solid rgba(255,255,255,0.25);background:rgba(0,0,0,0.25);pointer-events:auto;touch-action:none}
  .touch-joystick::after{content:'';position:absolute;left:50%;top:50%;width:60px;height:60px;margin:-30px 0 0 -30px;border-radius:50%;background:rgba(255,255,255,0.3);transition:transform 0.06s ease;transform:translate(var(--jx,0px),var(--jy,0px))}
  .touch-joystick.move{left:24px;bottom:24px}
  .touch-joystick.look{right:24px;bottom:24px}
  .touch-buttons{position:absolute;right:26px;top:calc(50% - 120px);display:flex;flex-direction:column;gap:16px;pointer-events:auto}
  .touch-button{width:110px;padding:10px 0;border-radius:28px;background:rgba(0,0,0,0.45);border:2px solid rgba(255,255,255,0.25);color:#fff;text-align:center;font-size:14px;font-weight:600;touch-action:none}
  .touch-button.small{width:86px;font-size:12px;align-self:flex-end}
  .touch-button.active{background:rgba(255,255,255,0.25);border-color:rgba(255,255,255,0.55)}
  @media(hover:none) and (pointer:coarse){
    .touch-controls{display:block}
  }
</style>
</head>
<body>
<div id="container">
  <div class="hud" id="hud">Score: 0 | Enemies: 0 | HP: 1 | Host IP: N/A</div>

  <div class="players" id="players">Players: me</div>

  <div class="instructions">
    <strong>Controls</strong><br>
    WASD / Left Stick - move<br>Mouse / Right Stick - look<br>Click / RT / Touch Shoot - fire (hold to spray)<br>Space / A - jump & double jump (hold near walls to climb)<br>Shift / B - slide boost (tap in air to vault)<br>Ctrl / X - forward dash<br>Y / View - toggle camera<br>Esc - release mouse<br>1-4 - quick swap weapons<br>Hold Q / LT / Touch Wheel - weapon wheel<br>H - toggle high quality<br>Touch players: use the on-screen sticks & buttons<br>Weapons: 1 Pulse | 2 Rocket | 3 Scatter | 4 Pee Stream
  </div>

  <div class="crosshair"></div>

  <div id="weaponWheel" class="weapon-wheel">
    <div class="weapon-wheel-hint">Move the mouse to highlight a weapon</div>
  </div>

  <div id="gameOver">
    <div style="font-size:20px">Game Over</div>
    <img src="backflip.gif" alt="backflip" style="width:180px">
    <br><button id="retry">Retry</button>
  </div>

  <div id="network">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>Name: <input id="nameInput" type="text" placeholder="Your name" style="width:140px"></label>
      <label>Server URL: <input id="serverUrl" type="text" placeholder="wss://example.ngrok-free.app" value="wss://unswarming-etha-unscanned.ngrok-free.dev" style="width:210px"></label>
      <label>Room Code: <input id="roomCode" type="text" placeholder="my-room" style="width:110px"></label>
      <button id="btnHost">Quick Host</button>
      <button id="btnJoin">Quick Join</button>
      <button id="btnDisconnect" disabled>Disconnect</button>
      <button id="btnHide">Hide UI</button>
    </div>

    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px">
      <label>Lobby Name: <input id="lobbyName" type="text" placeholder="City Showdown" style="width:170px"></label>
      <label>Max Players: <input id="lobbyMax" type="number" min="1" max="16" value="10" style="width:60px"></label>
      <button id="btnCreateLobby">Create Lobby</button>
      <button id="btnBrowseLobbies">Browse Lobbies</button>
    </div>

    <div id="connectionStatus" class="small" style="margin-top:6px">Status: disconnected</div>
    <div id="networkLog" class="small" style="margin-top:6px;max-height:140px;overflow:auto;white-space:pre-line"></div>
  </div>
</div>

<div id="lobbyBrowser" class="lobby-browser">
  <div class="lobby-browser-header">
    <span>Lobby Browser</span>
    <div>
      <button id="btnRefreshLobbies" style="margin:0 6px 0 0">Refresh</button>
      <button id="btnCloseLobbyBrowser">Close</button>
    </div>
  </div>
  <div class="lobby-browser-body">
    <div id="lobbyList" class="lobby-list"></div>
    <div class="lobby-detail">
      <h3 id="lobbyDetailName">Select a lobby</h3>
      <div id="lobbyDetailMeta" class="small" style="opacity:0.8">Pick a room from the list to see who is inside.</div>
      <div id="lobbyPlayers" class="lobby-player-list empty">No lobby selected</div>
      <div class="lobby-actions">
        <button id="btnJoinLobby" disabled>Join Lobby</button>
      </div>
    </div>
  </div>
</div>

<div id="touchControls" class="touch-controls">
  <div id="touchMove" class="touch-joystick move"></div>
  <div id="touchLook" class="touch-joystick look"></div>
  <div class="touch-buttons">
    <div class="touch-button" data-action="jump">Jump</div>
    <div class="touch-button" data-action="dash">Dash</div>
    <div class="touch-button" data-action="slide">Slide</div>
    <div class="touch-button small" data-action="wheel">Wheel</div>
    <div class="touch-button" data-action="shoot">Shoot</div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
import { OBJLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/OBJLoader.js?module';
import { MTLLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/MTLLoader.js?module';

/* -------------------------
   Scene + basic game setup
   ------------------------- */
const container = document.getElementById('container');
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87b9ff);
scene.fog = new THREE.Fog(0x87b9ff, 40, 180);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,0.7,0);
scene.add(camera);
const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight); container.appendChild(renderer.domElement);
window.addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); positionWeaponWheelOptions(); weaponWheelState.pointer = {x: innerWidth/2, y: innerHeight/2}; });

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,10,5); scene.add(dir);

const environment = new THREE.Group();
scene.add(environment);

const staticColliders = [];
function addBoxCollider(minX, minY, minZ, maxX, maxY, maxZ){
  staticColliders.push(new THREE.Box3(new THREE.Vector3(minX, minY, minZ), new THREE.Vector3(maxX, maxY, maxZ)));
}

const groundMaterial = new THREE.MeshStandardMaterial({color:0x3d9a4a, roughness:0.85, metalness:0.08});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), groundMaterial);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
environment.add(ground);

const path = new THREE.Mesh(new THREE.PlaneGeometry(8,26), new THREE.MeshStandardMaterial({color:0x9a7b55, roughness:0.92, metalness:0.05}));
path.rotation.x = -Math.PI/2;
path.position.set(0,0.02,-9);
environment.add(path);

const houseGroup = new THREE.Group();
const houseBase = new THREE.Mesh(new THREE.BoxGeometry(5.4,3.2,5.4), new THREE.MeshStandardMaterial({color:0xa0785a, roughness:0.72}));
houseBase.position.y = 1.6;
houseGroup.add(houseBase);
const roof = new THREE.Mesh(new THREE.ConeGeometry(4.3,2.8,4), new THREE.MeshStandardMaterial({color:0x7a2a22, roughness:0.45}));
roof.position.y = 3.8;
roof.rotation.y = Math.PI/4;
houseGroup.add(roof);
const door = new THREE.Mesh(new THREE.BoxGeometry(1.2,2.2,0.2), new THREE.MeshStandardMaterial({color:0x3b281a, roughness:0.6}));
door.position.set(0,1.1,2.7);
houseGroup.add(door);
const windowMat = new THREE.MeshStandardMaterial({color:0x8fd5ff, emissive:0x1a2a33, emissiveIntensity:0.25, roughness:0.2});
const windowLeft = new THREE.Mesh(new THREE.PlaneGeometry(1.2,1.2), windowMat);
windowLeft.position.set(-1.6,1.6,2.71);
windowLeft.rotation.y = Math.PI;
houseGroup.add(windowLeft);
const windowRight = windowLeft.clone();
windowRight.position.x = 1.6;
houseGroup.add(windowRight);
houseGroup.position.set(9,0,-6);
environment.add(houseGroup);
addBoxCollider(9-2.8, 0, -6-2.8, 9+2.8, 2.2, -6+2.8);

const mountain = new THREE.Mesh(new THREE.ConeGeometry(7.5,10,6), new THREE.MeshStandardMaterial({color:0x61615f, roughness:0.96}));
mountain.position.set(-12,5,14);
environment.add(mountain);
addBoxCollider(-12-5, 0, 14-5, -12+5, 10, 14+5);

const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2.4,0), new THREE.MeshStandardMaterial({color:0x5a534c, roughness:0.88}));
rock.position.set(-4,1.2,-3);
environment.add(rock);
addBoxCollider(-6.2,0,-5.2,-1.8,2.4,-0.8);

const shrubGeometry = new THREE.ConeGeometry(0.6,1.2,6);
const shrubMaterial = new THREE.MeshStandardMaterial({color:0x2f7c34, roughness:0.9});
[[ -2, -11 ], [ 5, -4 ], [ -8, 6 ], [ 3, 10 ], [ 11, -2 ]].forEach(([x,z])=>{
  const shrub = new THREE.Mesh(shrubGeometry, shrubMaterial);
  shrub.position.set(x,0.6,z);
  environment.add(shrub);
});

function createTree(x, z, height=3.6){
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.26,height*0.6,10), new THREE.MeshStandardMaterial({color:0x6b4b2a, roughness:0.8}));
  trunk.position.set(x, height*0.3, z);
  const canopy = new THREE.Mesh(new THREE.ConeGeometry(height*0.35, height*0.8, 12), new THREE.MeshStandardMaterial({color:0x2f8344, roughness:0.7}));
  canopy.position.set(x, height*0.9, z);
  environment.add(trunk);
  environment.add(canopy);
  addBoxCollider(x-0.45, 0, z-0.45, x+0.45, height*0.9, z+0.45);
}
[[ -14, -8 ], [ -10, -3 ], [ -6, 11 ], [ 6, 14 ], [ 12, 3 ], [ 15, -5 ]].forEach(([x,z], idx)=> createTree(x, z, 3.3 + (idx%3)*0.45));

const pond = new THREE.Mesh(new THREE.CylinderGeometry(4.2,4.2,0.2,28), new THREE.MeshStandardMaterial({color:0x4ab6ff, transparent:true, opacity:0.82, roughness:0.12, metalness:0.32}));
pond.position.set(-5,0.09,-12);
environment.add(pond);
addBoxCollider(-5-4.2, 0, -12-4.2, -5+4.2, 0.4, -12+4.2);

const dock = new THREE.Mesh(new THREE.BoxGeometry(2.8,0.18,1.6), new THREE.MeshStandardMaterial({color:0x8b7252, roughness:0.85}));
dock.position.set(-1.6,0.18,-12.2);
environment.add(dock);
addBoxCollider(dock.position.x-1.4, 0, dock.position.z-0.8, dock.position.x+1.4, dock.position.y+0.2, dock.position.z+0.8);

const campfire = new THREE.Group();
const fireRocks = new THREE.Mesh(new THREE.TorusGeometry(0.6,0.12,8,16), new THREE.MeshStandardMaterial({color:0x777777, roughness:0.9}));
campfire.add(fireRocks);
const flame = new THREE.Mesh(new THREE.ConeGeometry(0.28,0.7,8), new THREE.MeshStandardMaterial({color:0xffc164, emissive:0xff8632, emissiveIntensity:0.8, transparent:true, opacity:0.9}));
flame.position.y = 0.45;
campfire.add(flame);
campfire.position.set(2.4,0,-3.6);
environment.add(campfire);
addBoxCollider(2.4-0.7,0,-3.6-0.7,2.4+0.7,0.8,-3.6+0.7);

const bench = new THREE.Group();
const benchSeat = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.12,0.42), new THREE.MeshStandardMaterial({color:0xa6855c, roughness:0.72}));
benchSeat.position.y = 0.42;
bench.add(benchSeat);
const benchLegMaterial = new THREE.MeshStandardMaterial({color:0x57422d, roughness:0.8});
[[ -0.7, -0.16 ], [ 0.7, -0.16 ], [ -0.7, 0.16 ], [ 0.7, 0.16 ]].forEach(([lx, lz])=>{
  const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.42,0.1), benchLegMaterial);
  leg.position.set(lx,0.21,lz);
  bench.add(leg);
});
bench.position.set(3.4,0,-2.4);
bench.rotation.y = Math.PI/6;
environment.add(bench);
addBoxCollider(bench.position.x-0.9,0,bench.position.z-0.35, bench.position.x+0.9, bench.position.y+0.6, bench.position.z+0.35);

const houseSteps = new THREE.Group();
const stepMaterial = new THREE.MeshStandardMaterial({color:0x9f8a6f, roughness:0.7});
for(let i=0;i<4;i++){
  const step = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.34,1.2), stepMaterial);
  step.position.set(7.1, 0.17 + i*0.32, -6.9 + i*0.88);
  houseSteps.add(step);
  addBoxCollider(step.position.x-0.8, 0, step.position.z-0.6, step.position.x+0.8, step.position.y+0.2, step.position.z+0.6);
}
const railing = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,2.2,8), new THREE.MeshStandardMaterial({color:0xceb27a, roughness:0.6}));
railing.position.set(7.8,1.2,-4.8);
railing.rotation.z = Math.PI/2.3;
houseSteps.add(railing);
houseSteps.position.x += 0.2;
environment.add(houseSteps);

const rooftopWalk = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.18,4.4), new THREE.MeshStandardMaterial({color:0xcab99a, roughness:0.68}));
rooftopWalk.position.set(8.6, 1.35, -4.3);
rooftopWalk.rotation.y = -0.12;
environment.add(rooftopWalk);
addBoxCollider(rooftopWalk.position.x-0.9, rooftopWalk.position.y-0.1, rooftopWalk.position.z-2.2, rooftopWalk.position.x+0.9, rooftopWalk.position.y+0.2, rooftopWalk.position.z+2.2);
const rooftopRamp = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.22,1.6), new THREE.MeshStandardMaterial({color:0xbfa983, roughness:0.7}));
rooftopRamp.position.set(9.2, 2.05, -2.8);
environment.add(rooftopRamp);
addBoxCollider(rooftopRamp.position.x-0.6, rooftopRamp.position.y-0.1, rooftopRamp.position.z-0.8, rooftopRamp.position.x+0.6, rooftopRamp.position.y+0.2, rooftopRamp.position.z+0.8);

const lookoutPlatform = new THREE.Mesh(new THREE.BoxGeometry(3.2,0.24,2.6), new THREE.MeshStandardMaterial({color:0xb7a57a, roughness:0.75}));
lookoutPlatform.position.set(9,2.45,-1.8);
environment.add(lookoutPlatform);
addBoxCollider(lookoutPlatform.position.x-1.6, lookoutPlatform.position.y, lookoutPlatform.position.z-1.3, lookoutPlatform.position.x+1.6, lookoutPlatform.position.y+0.4, lookoutPlatform.position.z+1.3);

const signCanvas = document.createElement('canvas');
signCanvas.width = 512;
signCanvas.height = 256;
const signCtx = signCanvas.getContext('2d');
const signTexture = new THREE.CanvasTexture(signCanvas);
signTexture.anisotropy = 4;
const signMaterial = new THREE.MeshStandardMaterial({map: signTexture, transparent: true, roughness:0.82, metalness:0.12, side: THREE.DoubleSide});
const signBoard = new THREE.Mesh(new THREE.PlaneGeometry(4.6,2.3), signMaterial);
signBoard.position.set(0,1.6,0);
const signPostMaterial = new THREE.MeshStandardMaterial({color:0x8e6b42, roughness:0.9});
const signPostLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,2.4,10), signPostMaterial);
signPostLeft.position.set(-0.9,1.2,0);
const signPostRight = signPostLeft.clone();
signPostRight.position.x = 0.9;
const signGroup = new THREE.Group();
signGroup.add(signBoard);
signGroup.add(signPostLeft);
signGroup.add(signPostRight);
const signBeam = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.18,0.2), signPostMaterial);
signBeam.position.set(0,2.2,0);
signGroup.add(signBeam);
signGroup.position.set(2.5,0,-14);
environment.add(signGroup);
addBoxCollider(signGroup.position.x - 0.5, 0, signGroup.position.z - 0.5, signGroup.position.x + 0.5, 2.6, signGroup.position.z + 0.5);

let activeLobbyName = 'Alexland';

function updatePopulationSign(count, lobbyName = activeLobbyName){
  if(!signCtx || !signTexture) return;
  const display = Math.max(1, Math.round(count));
  const name = (lobbyName || 'Alexland').trim() || 'Alexland';
  const key = `${display}|${name}`;
  if(updatePopulationSign.last === key) return;
  updatePopulationSign.last = key;
  signCtx.fillStyle = '#2f6b24';
  signCtx.fillRect(0,0,signCanvas.width,signCanvas.height);
  signCtx.fillStyle = '#1c4815';
  signCtx.fillRect(18,18,signCanvas.width-36,signCanvas.height-36);
  signCtx.lineWidth = 6;
  signCtx.strokeStyle = '#d7cfa2';
  signCtx.strokeRect(18,18,signCanvas.width-36,signCanvas.height-36);
  signCtx.fillStyle = '#f2eccb';
  signCtx.textAlign = 'left';
  signCtx.textBaseline = 'top';
  const trimmed = name.length > 20 ? `${name.slice(0, 19)}â€¦` : name;
  const titleSize = trimmed.length > 14 ? 44 : 52;
  const popSize = trimmed.length > 16 ? 38 : 44;
  signCtx.font = `bold ${titleSize}px "Segoe UI", sans-serif`;
  signCtx.fillText(`Welcome to ${trimmed}`, 32, 52);
  signCtx.font = `bold ${popSize}px "Segoe UI", sans-serif`;
  signCtx.fillText(`Population: ${display}`, 32, 140);
  signTexture.needsUpdate = true;
}
updatePopulationSign(1, activeLobbyName);

function setActiveLobbyName(name){
  activeLobbyName = (name && name.trim()) ? name.trim() : 'Alexland';
  updatePopulationSign(Object.keys(remotePlayers).length + 1, activeLobbyName);
}

function resolveWorldCollisions(nextPosition){
  const adjusted = nextPosition.clone();
  let hitNormal = null;
  const radius = player?.radius ?? 0.45;
  const height = player?.height ?? 1.6;
  const playerBottom = nextPosition.y;
  const playerTop = playerBottom + height;
  for(const box of staticColliders){
    if(playerTop <= box.min.y || playerBottom >= box.max.y) continue;
    const expandedMinX = box.min.x - radius;
    const expandedMaxX = box.max.x + radius;
    const expandedMinZ = box.min.z - radius;
    const expandedMaxZ = box.max.z + radius;
    if(adjusted.x >= expandedMinX && adjusted.x <= expandedMaxX && adjusted.z >= expandedMinZ && adjusted.z <= expandedMaxZ){
      const centerX = (box.min.x + box.max.x) / 2;
      const centerZ = (box.min.z + box.max.z) / 2;
      const overlapX = Math.min(expandedMaxX - adjusted.x, adjusted.x - expandedMinX);
      const overlapZ = Math.min(expandedMaxZ - adjusted.z, adjusted.z - expandedMinZ);
      if(overlapX < overlapZ){
        if(adjusted.x > centerX){
          adjusted.x = expandedMaxX;
          if(player.velocity.x > 0) player.velocity.x = 0;
          hitNormal = new THREE.Vector3(1,0,0);
        } else {
          adjusted.x = expandedMinX;
          if(player.velocity.x < 0) player.velocity.x = 0;
          hitNormal = new THREE.Vector3(-1,0,0);
        }
      } else {
        if(adjusted.z > centerZ){
          adjusted.z = expandedMaxZ;
          if(player.velocity.z > 0) player.velocity.z = 0;
          hitNormal = new THREE.Vector3(0,0,1);
        } else {
          adjusted.z = expandedMinZ;
          if(player.velocity.z < 0) player.velocity.z = 0;
          hitNormal = new THREE.Vector3(0,0,-1);
        }
      }
    }
  }
  return { position: adjusted, normal: hitNormal };
}

/* HUD elements */
const hud = document.getElementById('hud');
const playersDiv = document.getElementById('players');
const nameInput = document.getElementById('nameInput');
const serverUrlInput = document.getElementById('serverUrl');
const roomInput = document.getElementById('roomCode');
const lobbyNameInput = document.getElementById('lobbyName');
const lobbyMaxInput = document.getElementById('lobbyMax');
const statusEl = document.getElementById('connectionStatus');
const networkLogEl = document.getElementById('networkLog');
const btnDisconnect = document.getElementById('btnDisconnect');
const btnCreateLobby = document.getElementById('btnCreateLobby');
const btnBrowseLobbies = document.getElementById('btnBrowseLobbies');
const btnRefreshLobbies = document.getElementById('btnRefreshLobbies');
const btnCloseLobbyBrowser = document.getElementById('btnCloseLobbyBrowser');
const btnJoinLobby = document.getElementById('btnJoinLobby');
const lobbyBrowserEl = document.getElementById('lobbyBrowser');
const lobbyListEl = document.getElementById('lobbyList');
const lobbyDetailNameEl = document.getElementById('lobbyDetailName');
const lobbyDetailMetaEl = document.getElementById('lobbyDetailMeta');
const lobbyPlayersEl = document.getElementById('lobbyPlayers');
const weaponWheelEl = document.getElementById('weaponWheel');
const touchControlsEl = document.getElementById('touchControls');
const touchMoveEl = document.getElementById('touchMove');
const touchLookEl = document.getElementById('touchLook');
const touchButtons = Array.from(document.querySelectorAll('.touch-button'));
let remotePlayers = {}; // peerId -> state

const DEFAULT_SIGNALING_URL = 'wss://unswarming-etha-unscanned.ngrok-free.dev';
const NETWORK_STORAGE_KEY = 'alex-network-settings';
let persistedNetworkSettings = loadPersistedNetworkSettings();

function loadPersistedNetworkSettings(){
  if(typeof window === 'undefined' || !window.localStorage){
    return {};
  }
  try{
    const raw = window.localStorage.getItem(NETWORK_STORAGE_KEY);
    if(!raw) return {};
    const parsed = JSON.parse(raw);
    return parsed && typeof parsed === 'object' ? parsed : {};
  }catch(err){
    console.warn('Failed to read stored network settings', err);
    return {};
  }
}

function savePersistedNetworkSettings(update){
  if(!update || typeof update !== 'object') return;
  persistedNetworkSettings = { ...persistedNetworkSettings, ...update };
  if(typeof window === 'undefined' || !window.localStorage) return;
  try{
    window.localStorage.setItem(NETWORK_STORAGE_KEY, JSON.stringify(persistedNetworkSettings));
  }catch(err){
    console.warn('Failed to persist network settings', err);
  }
}

function applyStoredNetworkDefaults(){
  const settings = persistedNetworkSettings || {};
  const server = settings.server || DEFAULT_SIGNALING_URL;
  serverUrlInput.value = server;
  if(settings.name){
    nameInput.value = settings.name;
  }
  if(settings.room){
    roomInput.value = settings.room;
  }
  if(settings.lobbyName){
    lobbyNameInput.value = settings.lobbyName;
  }
  if(settings.capacity){
    lobbyMaxInput.value = settings.capacity;
  }
}

applyStoredNetworkDefaults();

const aggregatedInput = {
  move: new THREE.Vector2(),
  jumpHeld: false,
  jumpPressed: false,
  slideHeld: false,
  slidePressed: false,
  dashPressed: false,
  wheelHeld: false,
  wheelPressed: false,
  fireHeld: false,
  firePressed: false,
  prevSlideHeld: false,
  prevWheelHeld: false
};

const keyboardState = {
  moveX: 0,
  moveY: 0,
  jumpHeld: false,
  slideHeld: false,
  dashHeld: false,
  wheelHeld: false
};

const gamepadState = {
  connected: false,
  moveX: 0,
  moveY: 0,
  lookX: 0,
  lookY: 0,
  jump: false,
  dash: false,
  slide: false,
  wheel: false,
  fire: false,
  viewToggle: false,
  prevJump: false,
  prevDash: false,
  prevSlide: false,
  prevWheel: false,
  prevFire: false,
  prevViewToggle: false,
  justJumped: false,
  justDashed: false,
  justSlid: false,
  justWheel: false,
  justFire: false,
  justToggledView: false
};

const touchState = {
  active: false,
  moveId: null,
  lookId: null,
  moveStart: null,
  lookStart: null,
  moveOffset: new THREE.Vector2(),
  lookOffset: new THREE.Vector2(),
  jump: false,
  dash: false,
  slide: false,
  wheel: false,
  fire: false,
  prevJump: false,
  prevDash: false,
  prevSlide: false,
  prevWheel: false,
  prevFire: false,
  justJumped: false,
  justDashed: false,
  justSlid: false,
  justWheel: false,
  justFired: false
};

const weaponConfigs = [
  {
    id: 1,
    label: 'Pulse Blaster',
    desc: 'Fast, accurate shot',
    type: 'pulse',
    fireInterval: 0.22,
    firePoseDuration: 0.14,
    sway: {amplitude: 0.012, speed: 3.4, tilt: 0.02},
    appearance: {color: 0xffff66, emissive: 0x332200, emissiveIntensity: 0.55, length: 0.95, thickness: 0.95},
    poses: {
      idle: {
        left: {pos: [-0.32, -0.08, -0.32], rot: [-0.35, 0.25, 1.4]},
        right: {pos: [0.22, -0.12, -0.4], rot: [-0.45, -0.05, -1.45]},
        weapon: {pos: [0, -0.1, -0.5], rot: [-0.08, 0, 0]}
      },
      fire: {
        left: {pos: [-0.3, -0.05, -0.25], rot: [-0.25, 0.4, 1.3]},
        right: {pos: [0.25, -0.1, -0.32], rot: [-0.35, 0.05, -1.35]},
        weapon: {pos: [0, -0.06, -0.58], rot: [-0.15, 0, 0]}
      }
    }
  },
  {
    id: 2,
    label: 'Burst Rocket',
    desc: 'Slow but explosive',
    type: 'rocket',
    fireInterval: 0.95,
    firePoseDuration: 0.28,
    sway: {amplitude: 0.008, speed: 2.6, tilt: 0.018},
    appearance: {color: 0xff5a2f, emissive: 0x401000, emissiveIntensity: 0.65, length: 1.35, thickness: 1.25},
    poses: {
      idle: {
        left: {pos: [-0.28, -0.18, -0.24], rot: [-0.2, 0.1, 1.55]},
        right: {pos: [0.15, -0.25, -0.34], rot: [-0.1, -0.2, -1.45]},
        weapon: {pos: [0, -0.22, -0.58], rot: [0.1, 0.05, 0]}
      },
      fire: {
        left: {pos: [-0.26, -0.16, -0.18], rot: [-0.1, 0.18, 1.4]},
        right: {pos: [0.18, -0.22, -0.26], rot: [0.02, -0.15, -1.35]},
        weapon: {pos: [0, -0.18, -0.72], rot: [0.18, 0.1, 0.05]}
      }
    }
  },
  {
    id: 3,
    label: 'Scatter Cycler',
    desc: 'Wide pellet burst',
    type: 'scatter',
    fireInterval: 0.58,
    firePoseDuration: 0.2,
    sway: {amplitude: 0.014, speed: 3.1, tilt: 0.024},
    appearance: {color: 0xfff1c1, emissive: 0x3a2c15, emissiveIntensity: 0.45, length: 1.05, thickness: 1.1},
    poses: {
      idle: {
        left: {pos: [-0.34, -0.12, -0.3], rot: [-0.55, 0.28, 1.7]},
        right: {pos: [0.2, -0.16, -0.38], rot: [-0.65, -0.12, -1.6]},
        weapon: {pos: [0, -0.14, -0.54], rot: [-0.28, 0, 0]}
      },
      fire: {
        left: {pos: [-0.32, -0.09, -0.24], rot: [-0.42, 0.4, 1.55]},
        right: {pos: [0.22, -0.14, -0.32], rot: [-0.5, 0, -1.45]},
        weapon: {pos: [0, -0.1, -0.64], rot: [-0.32, 0.08, 0]}
      }
    }
  },
  {
    id: 4,
    label: 'Pee Stream',
    desc: 'Rapid droplet spray',
    type: 'pee',
    fireInterval: 0.12,
    firePoseDuration: 0.1,
    sway: {amplitude: 0.018, speed: 4.2, tilt: 0.03},
    appearance: {color: 0xfff57a, emissive: 0x463800, emissiveIntensity: 0.35, length: 1.2, thickness: 0.75},
    stream: {count: 8, spreadYaw: 0.26, spreadPitch: 0.2, speed: 12, size: 0.06, damage: 0.03, ttl: 0.6, hitRadius: 0.28, gravity: 4.2},
    poses: {
      idle: {
        left: {pos: [-0.18, -0.07, -0.44], rot: [-0.35, 0.05, 1.2]},
        right: {pos: [0.08, -0.1, -0.52], rot: [-0.4, -0.04, -1.2]},
        weapon: {pos: [0, -0.06, -0.72], rot: [-0.45, 0, 0]}
      },
      fire: {
        left: {pos: [-0.16, -0.06, -0.4], rot: [-0.2, 0.12, 1.05]},
        right: {pos: [0.1, -0.08, -0.46], rot: [-0.28, 0, -1.05]},
        weapon: {pos: [0, -0.03, -0.82], rot: [-0.52, 0.05, 0]}
      }
    }
  }
];
const weaponConfigById = new Map(weaponConfigs.map(cfg=>[cfg.id, cfg]));

const weaponWheelState = {
  open: false,
  pointer: {x: innerWidth/2, y: innerHeight/2},
  selected: 0,
  options: weaponConfigs.map(cfg=>({id:cfg.id, label:cfg.label, desc:cfg.desc})),
  optionEls: [],
  centerEl: null
};
const shootState = {down:false, cooldown:0, mouseDown:false};

function cloneTemplate(template){
  const clone = template.clone(true);
  clone.traverse(node=>{
    if(node.isMesh && node.material){
      if(Array.isArray(node.material)){
        node.material = node.material.map(mat=> mat && mat.clone ? mat.clone() : mat);
      } else {
        node.material = node.material.clone ? node.material.clone() : node.material;
      }
    }
  });
  const setup = (template.userData && typeof template.userData.setupClone === 'function') ? template.userData.setupClone : (clone.userData && typeof clone.userData.setupClone === 'function' ? clone.userData.setupClone : null);
  if(typeof setup === 'function'){
    setup(clone);
  }
  return clone;
}

function createHumanoidTemplate(options={}){
  const { primary=0x6699ff, secondary=0x24355b, skin=0xffd7c4, accent=0xf5f1e6, height=1.6 } = options;
  const root = new THREE.Group();
  const hips = new THREE.Group(); hips.name = 'hips'; hips.position.y = 0.76; root.add(hips);
  const torso = new THREE.Group(); torso.name = 'torso'; torso.position.y = 0.36; hips.add(torso);
  const chest = new THREE.Mesh(new THREE.BoxGeometry(0.48,0.64,0.32), new THREE.MeshStandardMaterial({color:primary, roughness:0.6, metalness:0.15}));
  chest.position.y = 0.32; chest.name = 'chest'; torso.add(chest);
  const belt = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.18,0.34), new THREE.MeshStandardMaterial({color:secondary, roughness:0.7}));
  belt.position.y = 0.05; torso.add(belt);
  const head = new THREE.Group(); head.name = 'head'; head.position.y = 0.7; torso.add(head);
  const headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.32,0.32,0.32), new THREE.MeshStandardMaterial({color:skin, roughness:0.45}));
  headMesh.position.y = 0.16; head.add(headMesh);
  const eyeMat = new THREE.MeshStandardMaterial({color:0x1a1a1a, emissive:0x131313, roughness:0.3});
  const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.01), eyeMat); leftEye.position.set(-0.08,0.04,0.16); head.add(leftEye);
  const rightEye = leftEye.clone(); rightEye.position.x = 0.08; head.add(rightEye);
  const brow = new THREE.Mesh(new THREE.BoxGeometry(0.24,0.04,0.01), new THREE.MeshStandardMaterial({color:secondary, roughness:0.4}));
  brow.position.set(0,0.12,0.15); head.add(brow);

  function makeLimb(name, isArm){
    const group = new THREE.Group();
    group.name = name;
    const length = isArm ? 0.62 : 0.74;
    group.userData.length = length;
    const radius = isArm ? 0.09 : 0.11;
    const geom = new THREE.CylinderGeometry(radius, radius, length, 12);
    const mat = isArm ? new THREE.MeshStandardMaterial({color:skin, roughness:0.55}) : new THREE.MeshStandardMaterial({color:secondary, roughness:0.7});
    const limb = new THREE.Mesh(geom, mat);
    limb.position.y = -length/2;
    group.add(limb);
    return group;
  }

  const leftArm = makeLimb('leftArm', true); leftArm.position.set(-0.32,0.55,0); torso.add(leftArm);
  const rightArm = makeLimb('rightArm', true); rightArm.position.set(0.32,0.55,0); torso.add(rightArm);
  const leftLeg = makeLimb('leftLeg', false); leftLeg.position.set(-0.2,0.02,0); hips.add(leftLeg);
  const rightLeg = makeLimb('rightLeg', false); rightLeg.position.set(0.2,0.02,0); hips.add(rightLeg);
  const bootMat = new THREE.MeshStandardMaterial({color:accent, roughness:0.5});
  [leftLeg, rightLeg].forEach(leg=>{
    const boot = new THREE.Mesh(new THREE.BoxGeometry(0.24,0.1,0.36), bootMat);
    boot.position.set(0, -leg.userData.length + 0.08, 0.08);
    leg.add(boot);
  });
  const shoulderMat = new THREE.MeshStandardMaterial({color:secondary, roughness:0.6});
  const leftShoulder = new THREE.Mesh(new THREE.SphereGeometry(0.12,12,12), shoulderMat); leftShoulder.position.set(-0.32,0.64,0); torso.add(leftShoulder);
  const rightShoulder = leftShoulder.clone(); rightShoulder.position.x = 0.32; torso.add(rightShoulder);

  const box = new THREE.Box3().setFromObject(root);
  const size = box.getSize(new THREE.Vector3());
  if(size.y > 0 && height){
    const scale = height / size.y;
    root.scale.setScalar(scale);
  }
  const scaled = new THREE.Box3().setFromObject(root);
  const offset = scaled.min;
  root.position.y -= offset.y;

  root.userData.humanoidOptions = {...options, primary, secondary, skin, accent, height};
  root.userData.setupClone = clone=>{
    const parts = {};
    clone.traverse(node=>{
      if(node.name && ['hips','torso','head','leftArm','rightArm','leftLeg','rightLeg'].includes(node.name)){
        parts[node.name] = node;
      }
    });
    const baseRot = {};
    const basePos = {};
    for(const key in parts){
      const n = parts[key];
      baseRot[key] = n.rotation.clone();
      basePos[key] = n.position.clone();
    }
    clone.userData.humanoid = { parts, baseRot, basePos, state:{phase:Math.random()*Math.PI*2}, options:{...options, primary, secondary, skin, accent} };
  };
  return root;
}

function createLowEnemyTemplate(){
  return createHumanoidTemplate({ primary:0xcf5240, secondary:0x3a1111, skin:0xffb8a2, accent:0x2d0c0c, height:1.62, type:'enemy' });
}

function createLowPlayerTemplate(){
  return createHumanoidTemplate({ primary:0x4f7bff, secondary:0x1f2e6b, skin:0xffd8c0, accent:0xffffff, height:1.65, type:'player' });
}

function updateHumanoidRig(root, anim={}, dt=0){
  if(!root || !root.userData || !root.userData.humanoid) return;
  const data = root.userData.humanoid;
  const parts = data.parts || {};
  const baseRot = data.baseRot || {};
  const basePos = data.basePos || {};
  data.state = data.state || {phase:0};
  const state = data.state;
  const mode = anim.mode || 'idle';
  const speed = anim.speed ?? 0;
  const delta = dt || 0.016;
  const frequency = (mode === 'run' || mode === 'sprint') ? 8.5 + speed*2 : mode === 'climb' ? 6.2 : 4.2;
  state.phase += delta * frequency;

  for(const key in parts){
    const node = parts[key];
    const base = baseRot[key];
    const pos = basePos[key];
    if(base){ node.rotation.set(base.x, base.y, base.z); }
    if(pos){ node.position.set(pos.x, pos.y, pos.z); }
  }

  const hips = parts.hips;
  const torso = parts.torso;
  const head = parts.head;
  const leftArm = parts.leftArm;
  const rightArm = parts.rightArm;
  const leftLeg = parts.leftLeg;
  const rightLeg = parts.rightLeg;

  const swing = Math.sin(state.phase);
  const counter = Math.sin(state.phase + Math.PI);

  if(mode === 'run' || mode === 'sprint'){
    const amp = (mode === 'sprint' ? 1.1 : 0.85) * Math.max(0.45, speed);
    if(leftArm){ leftArm.rotation.x += counter * 0.9 * amp; leftArm.rotation.z += 0.15 * Math.cos(state.phase*0.5); }
    if(rightArm){ rightArm.rotation.x += swing * 0.9 * amp; rightArm.rotation.z -= 0.15 * Math.cos(state.phase*0.5); }
    if(leftLeg){ leftLeg.rotation.x += swing * 1.1 * amp; }
    if(rightLeg){ rightLeg.rotation.x += counter * 1.1 * amp; }
    if(torso){ torso.rotation.z += Math.sin(state.phase)*0.05*amp; torso.rotation.x += -Math.abs(Math.sin(state.phase))*0.05*amp; }
    if(hips){ hips.position.y += Math.abs(Math.cos(state.phase))*0.05*amp; }
    if(head){ head.rotation.y += Math.sin(state.phase*0.4)*0.05; }
  } else if(mode === 'slide'){
    if(hips){ hips.position.y -= 0.28; hips.rotation.x = -0.4; }
    if(leftLeg){ leftLeg.rotation.x = -0.6; }
    if(rightLeg){ rightLeg.rotation.x = -0.25; }
    if(leftArm){ leftArm.rotation.x = -0.5; leftArm.rotation.z = 1.1; }
    if(rightArm){ rightArm.rotation.x = -0.4; rightArm.rotation.z = -1.1; }
    if(torso){ torso.rotation.x = -0.18; }
  } else if(mode === 'dash'){
    if(leftArm){ leftArm.rotation.x = 0.9; leftArm.rotation.z = 0.45; }
    if(rightArm){ rightArm.rotation.x = 0.9; rightArm.rotation.z = -0.45; }
    if(leftLeg){ leftLeg.rotation.x = -0.35; }
    if(rightLeg){ rightLeg.rotation.x = 0.65; }
    if(torso){ torso.rotation.x = -0.22; }
  } else if(mode === 'climb'){
    const climbAmp = 0.55;
    if(leftArm){ leftArm.rotation.x = -0.9 + Math.cos(state.phase)*0.45; leftArm.rotation.z = 0.3; }
    if(rightArm){ rightArm.rotation.x = -0.9 + Math.cos(state.phase + Math.PI)*0.45; rightArm.rotation.z = -0.3; }
    if(leftLeg){ leftLeg.rotation.x = 0.6 + Math.sin(state.phase)*0.4; }
    if(rightLeg){ rightLeg.rotation.x = 0.6 + Math.sin(state.phase + Math.PI)*0.4; }
    if(torso){ torso.rotation.x = 0.28; }
    if(hips){ hips.position.y += Math.sin(state.phase)*0.06; }
  } else if(mode === 'air'){
    if(leftArm){ leftArm.rotation.x = -0.45; leftArm.rotation.z = 0.25; }
    if(rightArm){ rightArm.rotation.x = -0.45; rightArm.rotation.z = -0.25; }
    if(leftLeg){ leftLeg.rotation.x = 0.28; }
    if(rightLeg){ rightLeg.rotation.x = -0.18; }
    if(torso){ torso.rotation.x = 0.12; }
  } else {
    const idleSwing = Math.sin(state.phase*0.5) * 0.05;
    if(hips){ hips.position.y += idleSwing * 0.15; }
    if(leftArm){ leftArm.rotation.x += idleSwing * 0.35; leftArm.rotation.z = 0.08; }
    if(rightArm){ rightArm.rotation.x -= idleSwing * 0.35; rightArm.rotation.z = -0.08; }
    if(head){ head.rotation.y += Math.sin(state.phase*0.25) * 0.04; }
  }
}

function prepareModelGroup(object, targetHeight=1){
  const group = new THREE.Group();
  group.add(object);
  object.traverse(node=>{
    if(node.isMesh && node.material){
      if(Array.isArray(node.material)){
        node.material = node.material.map(mat=> mat && mat.clone ? mat.clone() : mat);
      } else if(node.material.isMaterial && node.material.clone){
        node.material = node.material.clone();
      }
    }
  });
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  if(size.y > 0 && targetHeight){
    const scale = targetHeight / size.y;
    object.scale.multiplyScalar(scale);
  }
  const centeredBox = new THREE.Box3().setFromObject(object);
  const center = centeredBox.getCenter(new THREE.Vector3());
  object.position.sub(center);
  return group;
}

function loadObjWithMtl(objPath, mtlPath){
  return new Promise((resolve, reject)=>{
    const mtlLoader = new MTLLoader();
    const resolvePath = path=>{
      const idx = path.lastIndexOf('/');
      return idx >= 0 ? { dir: path.slice(0, idx + 1), file: path.slice(idx + 1) } : { dir: '', file: path };
    };
    const mtl = resolvePath(mtlPath);
    const obj = resolvePath(objPath);
    mtlLoader.setPath(mtl.dir || './');
    mtlLoader.setResourcePath(mtl.dir || obj.dir || './');
    mtlLoader.load(mtl.file, materials=>{
      materials.preload();
      const objLoader = new OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.setPath(obj.dir || './');
      objLoader.setResourcePath(obj.dir || './');
      objLoader.load(obj.file, resolve, undefined, reject);
    }, undefined, reject);
  });
}

let highQuality = false;
let highQualityLoadPromise = null;
const enemyTemplates = { low: createLowEnemyTemplate(), high: null };
const playerTemplates = { low: createLowPlayerTemplate(), high: null };

async function ensureHighQualityModels(){
  if(enemyTemplates.high && playerTemplates.high) return;
  if(highQualityLoadPromise) return highQualityLoadPromise;
  highQualityLoadPromise = Promise.all([
    loadObjWithMtl('models/oofer.obj', 'models/oofer.mtl').then(object=>{ enemyTemplates.high = prepareModelGroup(object, 1); }),
    loadObjWithMtl('models/alex.obj', 'models/alex.mtl').then(object=>{ playerTemplates.high = prepareModelGroup(object, 1); })
  ]).catch(err=>{
    console.error('Failed to load high quality assets', err);
    throw err;
  }).finally(()=>{ highQualityLoadPromise = null; });
  return highQualityLoadPromise;
}

function getActiveEnemyTemplate(){
  return (highQuality && enemyTemplates.high) ? enemyTemplates.high : enemyTemplates.low;
}

function getActivePlayerTemplate(){
  return (highQuality && playerTemplates.high) ? playerTemplates.high : playerTemplates.low;
}

function applyQualityTemplates(){
  if(alexMesh){
    while(alexMesh.children.length){ alexMesh.remove(alexMesh.children[0]); }
    alexMesh.add(cloneTemplate(getActivePlayerTemplate()));
  }
  if(enemyGroup){
    for(let i=0;i<enemies.length;i++){
      const enemy = enemies[i];
      if(!enemy) continue;
      const clone = cloneTemplate(getActiveEnemyTemplate());
      clone.position.copy(enemy.position);
      clone.quaternion.copy(enemy.quaternion);
      clone.userData = {...enemy.userData};
      enemyGroup.remove(enemy);
      enemyGroup.add(clone);
      enemies[i] = clone;
    }
  }
  if(remotePlayers){
    for(const id in remotePlayers){
      const rp = remotePlayers[id];
      if(rp && rp.mesh){
        scene.remove(rp.mesh);
        rp.mesh = null;
      }
    }
  }
}

async function toggleHighQualityMode(){
  const targetState = !highQuality;
  if(targetState){
    try{
      await ensureHighQualityModels();
      highQuality = true;
    }catch(err){
      console.error('Unable to enable high quality mode', err);
      highQuality = false;
      return;
    }
  } else {
    highQuality = false;
  }
  applyQualityTemplates();
}

function buildWeaponWheel(){
  weaponWheelEl.innerHTML = '<div class="weapon-wheel-hint">Move the mouse to highlight a weapon</div>';
  weaponWheelState.optionEls = weaponWheelState.options.map((opt, idx)=>{
    const el = document.createElement('div');
    el.className = 'weapon-wheel-option';
    el.innerHTML = `<div><strong>${opt.label}</strong>${opt.desc ? `<span>${opt.desc}</span>` : ''}</div>`;
    el.dataset.index = idx;
    weaponWheelEl.appendChild(el);
    return el;
  });
  weaponWheelState.centerEl = document.createElement('div');
  weaponWheelState.centerEl.className = 'weapon-wheel-center';
  weaponWheelEl.appendChild(weaponWheelState.centerEl);
  positionWeaponWheelOptions();
  updateWeaponWheelHighlight();
}

function positionWeaponWheelOptions(){
  const center = 130;
  const radius = 90;
  const total = weaponWheelState.options.length;
  weaponWheelState.optionEls.forEach((el, idx)=>{
    const angle = (idx/total) * Math.PI * 2 - Math.PI/2;
    const x = center + Math.cos(angle) * radius;
    const y = center + Math.sin(angle) * radius;
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
  });
}

function updateWeaponWheelHighlight(){
  weaponWheelState.optionEls.forEach((el, idx)=>{
    el.classList.toggle('active', idx === weaponWheelState.selected);
  });
  if(weaponWheelState.centerEl){
    const opt = weaponWheelState.options[weaponWheelState.selected];
    if(opt){
      weaponWheelState.centerEl.innerHTML = `<div>${opt.label}</div>${opt.desc ? `<span>${opt.desc}</span>` : ''}`;
    }
  }
}

function weaponWheelIsMultiplayer(){
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(ch && ch.readyState === 'open') return true;
  }
  return false;
}

function openWeaponWheel(){
  if(weaponWheelState.open) return;
  weaponWheelState.open = true;
  weaponWheelEl.classList.add('open');
  weaponWheelState.pointer = {x: innerWidth/2, y: innerHeight/2};
  const currentIndex = weaponWheelState.options.findIndex(opt=>opt.id === player.weapon);
  if(currentIndex >= 0) weaponWheelState.selected = currentIndex;
  const hint = weaponWheelEl.querySelector('.weapon-wheel-hint');
  if(hint){
    hint.textContent = weaponWheelIsMultiplayer() ? 'Multiplayer: slow motion disabled' : 'Move the mouse to highlight a weapon';
  }
  updateWeaponWheelHighlight();
}

function closeWeaponWheel(){
  if(!weaponWheelState.open) return;
  weaponWheelState.open = false;
  weaponWheelEl.classList.remove('open');
  const chosen = weaponWheelState.options[weaponWheelState.selected];
  if(chosen){
    equipWeapon(chosen.id);
  }
}

function updateWeaponWheelSelection(){
  if(!weaponWheelState.open) return;
  const centerX = innerWidth/2;
  const centerY = innerHeight/2;
  const dx = weaponWheelState.pointer.x - centerX;
  const dy = weaponWheelState.pointer.y - centerY;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if(dist < 20){
    return;
  }
  const total = weaponWheelState.options.length;
  if(total === 0) return;
  let angle = Math.atan2(dy, dx);
  angle = (angle + Math.PI*2) % (Math.PI*2);
  const slice = (Math.PI*2) / total;
  const index = Math.floor((angle + slice/2) / slice) % total;
  if(index !== weaponWheelState.selected){
    weaponWheelState.selected = index;
    updateWeaponWheelHighlight();
  }
}

function equipWeapon(id, options={}){
  const cfg = weaponConfigById.get(id);
  if(!cfg) return;
  if(typeof player !== 'undefined'){
    player.weapon = id;
  }
  const idx = weaponWheelState.options.findIndex(opt=>opt.id===id);
  if(idx>=0){
    weaponWheelState.selected = idx;
    updateWeaponWheelHighlight();
  }
  if(typeof armRig !== 'undefined' && armRig){
    armRig.setWeapon(id, options.immediate);
  }
  shootState.cooldown = 0;
}

function createArmRig(){
  const group = new THREE.Group();
  group.position.set(0, -0.12, 0.08);
  group.rotation.set(0, 0, 0);
  const baseGroupPosition = group.position.clone();

  const skinMaterial = new THREE.MeshStandardMaterial({color:0xffcaa6, roughness:0.55, metalness:0.1});
  const armGeometry = new THREE.CylinderGeometry(0.09, 0.12, 0.6, 14);
  armGeometry.translate(0, -0.3, 0);

  const left = new THREE.Group();
  const leftMesh = new THREE.Mesh(armGeometry, skinMaterial);
  left.add(leftMesh);

  const right = new THREE.Group();
  const rightMesh = new THREE.Mesh(armGeometry, skinMaterial.clone());
  right.add(rightMesh);

  const weapon = new THREE.Group();
  const weaponGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1, 18);
  weaponGeometry.translate(0, -0.5, 0);
  const weaponMaterial = new THREE.MeshStandardMaterial({color:0xffff66, roughness:0.3, metalness:0.45, emissive:0x222200, emissiveIntensity:0.6});
  const weaponMesh = new THREE.Mesh(weaponGeometry, weaponMaterial);
  weaponMesh.rotation.x = Math.PI/2;
  weapon.add(weaponMesh);

  group.add(left);
  group.add(right);
  group.add(weapon);

  camera.add(group);

  const leftTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const rightTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const weaponTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const tempEuler = new THREE.Euler();

  function setTargetsForPose(pose){
    const safePose = pose || (weaponConfigs[0]?.poses.idle);
    if(safePose?.left){
      leftTarget.pos.set(safePose.left.pos[0], safePose.left.pos[1], safePose.left.pos[2]);
      tempEuler.set(safePose.left.rot[0], safePose.left.rot[1], safePose.left.rot[2], 'XYZ');
      leftTarget.quat.setFromEuler(tempEuler);
    }
    if(safePose?.right){
      rightTarget.pos.set(safePose.right.pos[0], safePose.right.pos[1], safePose.right.pos[2]);
      tempEuler.set(safePose.right.rot[0], safePose.right.rot[1], safePose.right.rot[2], 'XYZ');
      rightTarget.quat.setFromEuler(tempEuler);
    }
    if(safePose?.weapon){
      weaponTarget.pos.set(safePose.weapon.pos[0], safePose.weapon.pos[1], safePose.weapon.pos[2]);
      tempEuler.set(safePose.weapon.rot[0], safePose.weapon.rot[1], safePose.weapon.rot[2], 'XYZ');
      weaponTarget.quat.setFromEuler(tempEuler);
    }
  }

  const rig = {
    group,
    left,
    right,
    weapon,
    weaponMesh,
    weaponMaterial,
    weaponId: 1,
    fireTimer: 0,
    fireTimerTotal: 0,
    time: 0,
    setWeapon(id, immediate){
      if(!weaponConfigById.has(id)) return;
      this.weaponId = id;
      this.time = 0;
      this.fireTimer = 0;
      this.fireTimerTotal = 0;
      const cfg = weaponConfigById.get(id) || weaponConfigs[0];
      const appearance = cfg.appearance || weaponConfigs[0].appearance;
      if(appearance){
        if(appearance.color !== undefined) this.weaponMaterial.color.setHex(appearance.color);
        if(appearance.emissive !== undefined) this.weaponMaterial.emissive.setHex(appearance.emissive);
        if(appearance.emissiveIntensity !== undefined) this.weaponMaterial.emissiveIntensity = appearance.emissiveIntensity;
        if(appearance.thickness !== undefined){
          weaponMesh.scale.x = appearance.thickness;
          weaponMesh.scale.z = appearance.thickness;
        }
        if(appearance.length !== undefined){
          weaponMesh.scale.y = appearance.length;
        }
      }
      this.applyPose('idle', immediate);
    },
    applyPose(poseName, immediate){
      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      const pose = (cfg.poses && cfg.poses[poseName]) || (cfg.poses && cfg.poses.idle) || weaponConfigs[0].poses.idle;
      setTargetsForPose(pose);
      if(immediate){
        left.position.copy(leftTarget.pos);
        left.quaternion.copy(leftTarget.quat);
        right.position.copy(rightTarget.pos);
        right.quaternion.copy(rightTarget.quat);
        weapon.position.copy(weaponTarget.pos);
        weapon.quaternion.copy(weaponTarget.quat);
      }
    },
    triggerFire(){
      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      this.fireTimer = cfg?.firePoseDuration ?? 0.15;
      this.fireTimerTotal = this.fireTimer;
      this.applyPose('fire');
    },
    update(dt){
      if(typeof player !== 'undefined'){
        group.visible = !player.thirdPerson;
      }
      this.time += dt;
      const lerpAlpha = Math.max(0, Math.min(1, dt * 12));
      left.position.lerp(leftTarget.pos, lerpAlpha);
      left.quaternion.slerp(leftTarget.quat, lerpAlpha);
      right.position.lerp(rightTarget.pos, lerpAlpha);
      right.quaternion.slerp(rightTarget.quat, lerpAlpha);
      weapon.position.lerp(weaponTarget.pos, lerpAlpha);
      weapon.quaternion.slerp(weaponTarget.quat, lerpAlpha);

      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      const swayCfg = cfg?.sway || {};
      const swaySpeed = swayCfg.speed ?? 3.5;
      const swayAmount = swayCfg.amplitude ?? 0.01;
      const tiltAmount = swayCfg.tilt ?? 0.02;
      const fireInfluence = this.fireTimer > 0 && this.fireTimerTotal > 0 ? Math.max(0.3, this.fireTimer / this.fireTimerTotal) : 1;
      group.position.set(baseGroupPosition.x, baseGroupPosition.y + Math.sin(this.time * swaySpeed) * swayAmount * fireInfluence, baseGroupPosition.z);
      group.rotation.set(0, 0, Math.cos(this.time * swaySpeed * 0.5) * tiltAmount * fireInfluence);
      if(this.fireTimer <= 0){
        const bob = Math.sin(this.time * swaySpeed * 1.4) * swayAmount * 0.6;
        left.position.y += bob;
        right.position.y += bob;
        weapon.position.y += bob * 0.6;
      }

      if(this.fireTimer > 0){
        this.fireTimer -= dt;
        if(this.fireTimer <= 0){
          this.applyPose('idle');
        }
      }
    }
  };

  rig.applyPose('idle', true);
  return rig;
}

buildWeaponWheel();

/* Player */
const player = {
  pos: new THREE.Vector3(0,0.5,0),
  velocity: new THREE.Vector3(),
  speed: 4.6,
  height: 1.6,
  radius: 0.45,
  gravity: 9.8,
  yaw: 0,
  pitch: 0,
  hp: 1,
  alive: true,
  thirdPerson: false,
  weapon: 1,
  jumpSpeed: 5.5,
  grounded: true,
  groundHeight: 0.5,
  coyoteTimer: 0,
  wallNormal: new THREE.Vector3(),
  wallTouchTimer: 0,
  isSliding: false,
  slideTimer: 0,
  slideCooldown: 0,
  slideDirection: new THREE.Vector3(),
  maxJumpCharges: 2,
  airJumpsRemaining: 1,
  dashTimer: 0,
  dashCooldown: 0,
  dashVector: new THREE.Vector3(),
  climbing: false,
  climbTimer: 0,
  climbSpeed: 3.6,
  anim: { mode:'idle', speed:0, variant:0 },
  id: Math.random().toString(36).slice(2,9),
  name: 'me'
};

const alexMesh = new THREE.Group();
scene.add(alexMesh);
alexMesh.add(cloneTemplate(getActivePlayerTemplate()));
const armRig = createArmRig();
equipWeapon(player.weapon, {immediate:true});

/* Controls */
let keys = {};
window.addEventListener('keydown', e=>{
  keys[e.code]=true;
  updateKeyboardState();
  if(e.code==='KeyY') player.thirdPerson = !player.thirdPerson;
  if(e.code==='KeyH' && !e.repeat){ toggleHighQualityMode(); }
  if(e.code==='Space' && !e.repeat){ attemptJump(); }
  if(!e.repeat && (e.code==='ControlLeft' || e.code==='ControlRight' || e.code==='KeyX')){
    triggerDash();
  }
  if(e.code.startsWith('Digit')){
    const digit = parseInt(e.code.slice(5), 10);
    if(!Number.isNaN(digit)){
      equipWeapon(digit);
    }
  }
  if(e.code==='KeyQ' && !e.repeat){ openWeaponWheel(); }
});
window.addEventListener('keyup', e=>{
  keys[e.code]=false;
  updateKeyboardState();
  if(e.code==='KeyQ'){ closeWeaponWheel(); }
  if(e.code==='ShiftLeft' || e.code==='ShiftRight'){
    if(player.isSliding && (!keys['ShiftLeft'] && !keys['ShiftRight'])){
      player.isSliding = false;
    }
  }
});
function updateKeyboardState(){
  keyboardState.moveX = 0;
  keyboardState.moveY = 0;
  if(keys['KeyA'] || keys['ArrowLeft']) keyboardState.moveX -= 1;
  if(keys['KeyD'] || keys['ArrowRight']) keyboardState.moveX += 1;
  if(keys['KeyW'] || keys['ArrowUp']) keyboardState.moveY += 1;
  if(keys['KeyS'] || keys['ArrowDown']) keyboardState.moveY -= 1;
  const len = Math.hypot(keyboardState.moveX, keyboardState.moveY);
  if(len > 1){
    keyboardState.moveX /= len;
    keyboardState.moveY /= len;
  }
  keyboardState.jumpHeld = !!keys['Space'];
  keyboardState.slideHeld = !!(keys['ShiftLeft'] || keys['ShiftRight']);
  keyboardState.dashHeld = !!(keys['ControlLeft'] || keys['ControlRight'] || keys['KeyX']);
  keyboardState.wheelHeld = !!keys['KeyQ'];
}
updateKeyboardState();
window.addEventListener('keydown', e=>{ if(e.code==='Escape') document.exitPointerLock?.(); });
let isLocked = false;
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
document.addEventListener('pointerlockchange', ()=>{
  isLocked = (document.pointerLockElement === renderer.domElement);
  if(!isLocked){
    shootState.down = false;
    shootState.mouseDown = false;
  }
});
document.addEventListener('mousemove', e=>{
  if(weaponWheelState.open){
    if(isLocked){
      weaponWheelState.pointer.x = Math.max(0, Math.min(innerWidth, weaponWheelState.pointer.x + e.movementX));
      weaponWheelState.pointer.y = Math.max(0, Math.min(innerHeight, weaponWheelState.pointer.y + e.movementY));
    } else {
      weaponWheelState.pointer.x = e.clientX;
      weaponWheelState.pointer.y = e.clientY;
    }
    updateWeaponWheelSelection();
    return;
  }
  if(!isLocked) return;
  player.yaw -= e.movementX*0.002;
  player.pitch -= e.movementY*0.002;
  player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));
});

const coarsePointer = window.matchMedia ? window.matchMedia('(hover: none) and (pointer: coarse)') : null;
function refreshTouchControls(){
  if(!touchControlsEl) return;
  const show = coarsePointer ? coarsePointer.matches : false;
  touchControlsEl.classList.toggle('active', show);
}
if(coarsePointer && coarsePointer.addEventListener){
  coarsePointer.addEventListener('change', refreshTouchControls);
}
refreshTouchControls();

const TOUCH_RADIUS = 70;
function resetJoystickVisual(el){
  if(!el) return;
  el.style.setProperty('--jx', '0px');
  el.style.setProperty('--jy', '0px');
}
function startJoystick(type, touch){
  if(type === 'move'){
    touchState.moveId = touch.identifier;
    touchState.moveStart = {x: touch.clientX, y: touch.clientY};
    touchState.moveOffset.set(0,0);
    resetJoystickVisual(touchMoveEl);
  } else {
    touchState.lookId = touch.identifier;
    touchState.lookStart = {x: touch.clientX, y: touch.clientY};
    touchState.lookOffset.set(0,0);
    resetJoystickVisual(touchLookEl);
  }
}
function updateJoystick(type, touch){
  const start = type === 'move' ? touchState.moveStart : touchState.lookStart;
  if(!start) return;
  const dx = touch.clientX - start.x;
  const dy = touch.clientY - start.y;
  const dist = Math.hypot(dx, dy);
  const limit = TOUCH_RADIUS;
  const scale = dist > limit ? (limit / dist) : 1;
  const pxX = dx * scale;
  const pxY = dy * scale;
  const normX = pxX / limit;
  const normY = pxY / limit;
  if(type === 'move'){
    touchState.moveOffset.set(normX, -normY);
    if(touchMoveEl){
      touchMoveEl.style.setProperty('--jx', `${pxX}px`);
      touchMoveEl.style.setProperty('--jy', `${-pxY}px`);
    }
  } else {
    touchState.lookOffset.set(normX, -normY);
    if(touchLookEl){
      touchLookEl.style.setProperty('--jx', `${pxX}px`);
      touchLookEl.style.setProperty('--jy', `${-pxY}px`);
    }
  }
}
function endJoystick(type){
  if(type === 'move'){
    touchState.moveId = null;
    touchState.moveStart = null;
    touchState.moveOffset.set(0,0);
    resetJoystickVisual(touchMoveEl);
  } else {
    touchState.lookId = null;
    touchState.lookStart = null;
    touchState.lookOffset.set(0,0);
    resetJoystickVisual(touchLookEl);
  }
}
function handleJoystickStart(type, event){
  const touches = Array.from(event.changedTouches || []);
  for(const touch of touches){
    if((type === 'move' && touchState.moveId === null) || (type === 'look' && touchState.lookId === null)){
      startJoystick(type, touch);
      event.preventDefault();
      break;
    }
  }
}
function handleJoystickMove(event){
  let handled = false;
  const touches = Array.from(event.changedTouches || []);
  for(const touch of touches){
    if(touch.identifier === touchState.moveId){
      updateJoystick('move', touch);
      handled = true;
    }
    if(touch.identifier === touchState.lookId){
      updateJoystick('look', touch);
      handled = true;
    }
  }
  if(handled){ event.preventDefault(); }
}
function handleJoystickEnd(event){
  const touches = Array.from(event.changedTouches || []);
  let handled = false;
  for(const touch of touches){
    if(touch.identifier === touchState.moveId){
      endJoystick('move');
      handled = true;
    }
    if(touch.identifier === touchState.lookId){
      endJoystick('look');
      handled = true;
    }
  }
  if(handled){ event.preventDefault(); }
}
if(touchMoveEl){
  touchMoveEl.addEventListener('touchstart', e=> handleJoystickStart('move', e), {passive:false});
}
if(touchLookEl){
  touchLookEl.addEventListener('touchstart', e=> handleJoystickStart('look', e), {passive:false});
}
window.addEventListener('touchmove', handleJoystickMove, {passive:false});
window.addEventListener('touchend', handleJoystickEnd, {passive:false});
window.addEventListener('touchcancel', handleJoystickEnd, {passive:false});
if(touchControlsEl){
  touchControlsEl.addEventListener('contextmenu', e=> e.preventDefault());
}

function setTouchButtonState(action, pressed, el){
  if(el){ el.classList.toggle('active', pressed); }
  switch(action){
    case 'jump': touchState.jump = pressed; break;
    case 'dash': touchState.dash = pressed; break;
    case 'slide': touchState.slide = pressed; break;
    case 'wheel': touchState.wheel = pressed; break;
    case 'shoot': touchState.fire = pressed; break;
  }
}
touchButtons.forEach(btn=>{
  const action = btn.dataset.action;
  if(!action) return;
  btn.addEventListener('touchstart', e=>{ setTouchButtonState(action, true, btn); e.preventDefault(); });
  btn.addEventListener('touchend', e=>{ setTouchButtonState(action, false, btn); e.preventDefault(); });
  btn.addEventListener('touchcancel', e=>{ setTouchButtonState(action, false, btn); e.preventDefault(); });
});

function updateTouchFlags(){
  touchState.justJumped = touchState.jump && !touchState.prevJump;
  touchState.justDashed = touchState.dash && !touchState.prevDash;
  touchState.justSlid = touchState.slide && !touchState.prevSlide;
  touchState.justWheel = touchState.wheel && !touchState.prevWheel;
  touchState.justFired = touchState.fire && !touchState.prevFire;
  touchState.prevJump = touchState.jump;
  touchState.prevDash = touchState.dash;
  touchState.prevSlide = touchState.slide;
  touchState.prevWheel = touchState.wheel;
  touchState.prevFire = touchState.fire;
}

function applyDeadZone(value, threshold=0.18){
  return Math.abs(value) < threshold ? 0 : value;
}
function pollGamepads(){
  const pads = (typeof navigator !== 'undefined' && navigator.getGamepads) ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
  if(!pads.length){
    if(gamepadState.connected){
      gamepadState.connected = false;
      gamepadState.moveX = 0;
      gamepadState.moveY = 0;
      gamepadState.lookX = 0;
      gamepadState.lookY = 0;
      gamepadState.jump = false;
      gamepadState.dash = false;
      gamepadState.slide = false;
      gamepadState.wheel = false;
      gamepadState.fire = false;
      gamepadState.viewToggle = false;
      gamepadState.justJumped = false;
      gamepadState.justDashed = false;
      gamepadState.justSlid = false;
      gamepadState.justWheel = false;
      gamepadState.justFire = false;
      gamepadState.justToggledView = false;
      gamepadState.prevJump = false;
      gamepadState.prevDash = false;
      gamepadState.prevSlide = false;
      gamepadState.prevWheel = false;
      gamepadState.prevFire = false;
      gamepadState.prevViewToggle = false;
    }
    return;
  }
  const pad = pads[0];
  gamepadState.connected = true;
  gamepadState.moveX = applyDeadZone(pad.axes?.[0] ?? 0);
  gamepadState.moveY = -applyDeadZone(pad.axes?.[1] ?? 0);
  gamepadState.lookX = applyDeadZone(pad.axes?.[2] ?? 0, 0.12);
  gamepadState.lookY = -applyDeadZone(pad.axes?.[3] ?? 0, 0.12);
  const buttons = pad.buttons || [];
  const pressed = idx=> !!(buttons[idx] && (buttons[idx].pressed || buttons[idx].value > 0.5));
  const jump = pressed(0);
  const slide = pressed(1);
  const dash = pressed(2);
  const view = pressed(3);
  const wheel = pressed(6);
  const fire = pressed(7) || pressed(5);
  gamepadState.justJumped = jump && !gamepadState.prevJump;
  gamepadState.justSlid = slide && !gamepadState.prevSlide;
  gamepadState.justDashed = dash && !gamepadState.prevDash;
  gamepadState.justWheel = wheel && !gamepadState.prevWheel;
  gamepadState.justFire = fire && !gamepadState.prevFire;
  gamepadState.justToggledView = view && !gamepadState.prevViewToggle;
  gamepadState.prevJump = jump;
  gamepadState.prevSlide = slide;
  gamepadState.prevDash = dash;
  gamepadState.prevWheel = wheel;
  gamepadState.prevFire = fire;
  gamepadState.prevViewToggle = view;
  gamepadState.jump = jump;
  gamepadState.slide = slide;
  gamepadState.dash = dash;
  gamepadState.wheel = wheel;
  gamepadState.fire = fire;
  gamepadState.viewToggle = view;
}

function updateAggregatedInput(dt){
  pollGamepads();
  updateTouchFlags();

  const moveX = keyboardState.moveX + gamepadState.moveX + touchState.moveOffset.x;
  const moveY = keyboardState.moveY + gamepadState.moveY + touchState.moveOffset.y;
  let mx = moveX;
  let my = moveY;
  const len = Math.hypot(mx, my);
  if(len > 1){ mx /= len; my /= len; }
  aggregatedInput.move.set(mx, my);

  aggregatedInput.jumpHeld = keyboardState.jumpHeld || gamepadState.jump || touchState.jump;
  aggregatedInput.jumpPressed = gamepadState.justJumped || touchState.justJumped;

  const slideHeld = keyboardState.slideHeld || gamepadState.slide || touchState.slide;
  aggregatedInput.slideHeld = slideHeld;
  aggregatedInput.slidePressed = (!aggregatedInput.prevSlideHeld && slideHeld) || gamepadState.justSlid || touchState.justSlid;
  aggregatedInput.prevSlideHeld = slideHeld;

  aggregatedInput.dashPressed = gamepadState.justDashed || touchState.justDashed;

  const wheelHeld = gamepadState.wheel || touchState.wheel || keyboardState.wheelHeld;
  aggregatedInput.wheelHeld = wheelHeld;
  aggregatedInput.wheelPressed = (!aggregatedInput.prevWheelHeld && wheelHeld) || gamepadState.justWheel || touchState.justWheel;
  aggregatedInput.prevWheelHeld = wheelHeld;

  aggregatedInput.fireHeld = shootState.mouseDown || gamepadState.fire || touchState.fire;
  aggregatedInput.firePressed = gamepadState.justFire || touchState.justFired;

  if(aggregatedInput.firePressed && !weaponWheelState.open){
    shoot();
  }
  shootState.down = aggregatedInput.fireHeld;

  if((gamepadState.justJumped || touchState.justJumped) && !weaponWheelState.open){
    attemptJump();
  }
  if(aggregatedInput.dashPressed && !weaponWheelState.open){
    triggerDash();
  }

  if(aggregatedInput.wheelPressed && !weaponWheelState.open && !keys['KeyQ']){
    openWeaponWheel();
  }
  if(weaponWheelState.open && !aggregatedInput.wheelHeld && !keys['KeyQ']){
    closeWeaponWheel();
  }

  const lookPadSpeed = 2.6;
  const lookTouchSpeed = 2.4;
  if(!weaponWheelState.open){
    player.yaw -= gamepadState.lookX * lookPadSpeed * dt;
    player.pitch -= gamepadState.lookY * lookPadSpeed * dt;
    player.yaw -= touchState.lookOffset.x * lookTouchSpeed * dt;
    player.pitch -= touchState.lookOffset.y * lookTouchSpeed * dt;
  }
  player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));

  if(gamepadState.justToggledView){
    player.thirdPerson = !player.thirdPerson;
  }
}

function attemptJump(){
  if(weaponWheelState.open) return false;
  const canGroundJump = player.grounded || player.coyoteTimer > 0;
  if(canGroundJump){
    player.velocity.y = player.jumpSpeed;
    player.grounded = false;
    player.coyoteTimer = 0;
    player.isSliding = false;
    player.slideTimer = 0;
    player.climbing = false;
    player.climbTimer = 0;
    player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    player.dashTimer = 0;
    return true;
  }
  if(player.climbing){
    player.velocity.y = player.jumpSpeed * 1.05;
    if(player.wallNormal.lengthSq()>0){
      player.velocity.addScaledVector(player.wallNormal.clone().negate(), player.speed * 0.6);
    }
    player.climbing = false;
    player.climbTimer = 0;
    player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    return true;
  }
  if(player.wallTouchTimer > 0 && player.wallNormal.lengthSq()>0){
    player.velocity.y = player.jumpSpeed * 1.05;
    player.velocity.addScaledVector(player.wallNormal, player.speed * 2.2);
    player.wallTouchTimer = 0;
    player.isSliding = false;
    player.slideTimer = 0;
    player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    return true;
  }
  if(player.airJumpsRemaining > 0){
    player.velocity.y = player.jumpSpeed * 0.92;
    player.airJumpsRemaining -= 1;
    player.isSliding = false;
    player.slideTimer = 0;
    player.dashTimer = 0;
    player.dashVector.set(0,0,0);
    return true;
  }
  return false;
}

function triggerDash(direction){
  if(weaponWheelState.open) return false;
  if(player.dashTimer > 0 || player.dashCooldown > 0.05) return false;
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));
  const inputDir = direction ? direction.clone() : new THREE.Vector3();
  if(!direction){
    const move = aggregatedInput.move.clone();
    if(move.lengthSq() > 0){
      inputDir.addScaledVector(forward, move.y);
      inputDir.addScaledVector(right, move.x);
    } else {
      inputDir.copy(forward);
    }
  }
  if(inputDir.lengthSq() === 0) return false;
  inputDir.normalize();
  player.dashVector.copy(inputDir);
  player.dashTimer = 0.24;
  player.dashCooldown = 0.7;
  player.isSliding = false;
  player.slideTimer = 0;
  return true;
}

/* Enemies & bullets */
const enemies=[]; const enemyGroup = new THREE.Group(); scene.add(enemyGroup);
function spawnEnemy(){
  const template = getActiveEnemyTemplate();
  const clone = cloneTemplate(template);
  const angle=Math.random()*Math.PI*2;
  const dist=10+Math.random()*10;
  clone.position.set(Math.cos(angle)*dist,0.5,Math.sin(angle)*dist);
  clone.userData = {...(clone.userData||{}), hp:2, speed:1.2, fleeTimer:0};
  enemyGroup.add(clone);
  enemies.push(clone);
  updateHUD();
}

const bullets=[];

function createShotsForWeapon(cfg, origin, dir){
  const forward = dir.clone().normalize();
  const thirdPerson = player.thirdPerson;
  const offset = thirdPerson ? 0.9 : 0.35;
  const baseOrigin = origin.clone().add(forward.clone().multiplyScalar(offset));
  if(cfg.type === 'pulse'){
    return [{
      type:'pulse',
      pos: baseOrigin.toArray(),
      dir: forward.toArray(),
      speed: 14,
      size: 0.1,
      color: cfg.appearance?.color ?? 0xffff66,
      damage: 1,
      ttl: 2.2,
      hitRadius: 0.45,
      pierce: 0
    }];
  }
  if(cfg.type === 'rocket'){
    return [{
      type:'rocket',
      pos: baseOrigin.toArray(),
      dir: forward.toArray(),
      speed: 9,
      size: 0.32,
      color: cfg.appearance?.color ?? 0xff5a2f,
      damage: 2,
      ttl: 4,
      hitRadius: 0.6,
      explode: 1.8,
      pierce: 0
    }];
  }
  if(cfg.type === 'scatter'){
    const shots = [];
    const pelletCount = 6;
    const euler = new THREE.Euler();
    const quat = new THREE.Quaternion();
    for(let i=0;i<pelletCount;i++){
      const spreadYaw = (Math.random()-0.5) * 0.3;
      const spreadPitch = (Math.random()-0.5) * 0.22;
      euler.set(spreadPitch, spreadYaw, 0, 'YXZ');
      quat.setFromEuler(euler);
      const pelletDir = forward.clone().applyQuaternion(quat).normalize();
      const pelletOrigin = origin.clone().add(pelletDir.clone().multiplyScalar(thirdPerson ? 0.9 : 0.32));
      shots.push({
        type:'pellet',
        pos: pelletOrigin.toArray(),
        dir: pelletDir.toArray(),
        speed: 11,
        size: 0.08,
        color: cfg.appearance?.color ?? 0xfff1c1,
        damage: 1,
        ttl: 0.55,
        hitRadius: 0.35,
        pierce: 0
      });
    }
    return shots;
  }
  if(cfg.type === 'pee'){
    const stream = cfg.stream || {};
    const shots = [];
    const dropletCount = stream.count || 8;
    const euler = new THREE.Euler();
    const quat = new THREE.Quaternion();
    for(let i=0;i<dropletCount;i++){
      const spreadYaw = (Math.random()-0.5) * (stream.spreadYaw || 0.22);
      const spreadPitch = (Math.random()-0.5) * (stream.spreadPitch || 0.18);
      euler.set(spreadPitch, spreadYaw, 0, 'YXZ');
      quat.setFromEuler(euler);
      const dropletDir = forward.clone().applyQuaternion(quat).normalize();
      const dropletOrigin = origin.clone()
        .add(dropletDir.clone().multiplyScalar(thirdPerson ? 0.9 : 0.36))
        .add(new THREE.Vector3((Math.random()-0.5)*0.06, (Math.random()-0.5)*0.04, (Math.random()-0.5)*0.06));
      shots.push({
        type:'pee',
        pos: dropletOrigin.toArray(),
        dir: dropletDir.toArray(),
        speed: stream.speed || 12,
        size: stream.size || 0.06,
        color: cfg.appearance?.color ?? 0xfff57a,
        damage: stream.damage || 0.03,
        ttl: stream.ttl || 0.6,
        hitRadius: stream.hitRadius || 0.28,
        gravity: stream.gravity || 4.2,
        pierce: 0
      });
    }
    return shots;
  }
  const beamOrigin = origin.clone().add(forward.clone().multiplyScalar(thirdPerson ? 1.0 : 0.45));
  return [{
    type:'beam',
    pos: beamOrigin.toArray(),
    dir: forward.toArray(),
    color: cfg.appearance?.color ?? 0x5ad4ff,
    duration: 0.18,
    length: 12,
    width: 0.14,
    damage: 2,
    hitRadius: 0.75
  }];
}

function spawnBulletFromShot(shot, ownerId){
  const dir = new THREE.Vector3(...(shot.dir || [0,0,-1])).normalize();
  if(shot.type === 'beam'){
    const length = shot.length ?? 10;
    const width = shot.width ?? 0.12;
    const geometry = new THREE.CylinderGeometry(width, width, length, 16, 1, true);
    const material = new THREE.MeshStandardMaterial({color: shot.color ?? 0x5ad4ff, emissive: new THREE.Color(shot.color ?? 0x5ad4ff).multiplyScalar(0.35), transparent:true, opacity:0.7, roughness:0.25, metalness:0.1});
    const mesh = new THREE.Mesh(geometry, material);
    const origin = new THREE.Vector3(...shot.pos);
    const midpoint = origin.clone().add(dir.clone().multiplyScalar(length/2));
    mesh.position.copy(midpoint);
    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
    mesh.userData = {
      type:'beam',
      owner: ownerId,
      origin,
      dir,
      length,
      damage: shot.damage ?? 2,
      life: shot.duration ?? 0.15,
      duration: shot.duration ?? 0.15,
      hitRadius: shot.hitRadius ?? 0.7,
      hitIds: new Set()
    };
    scene.add(mesh); bullets.push(mesh);
    return mesh;
  }
  const radius = shot.size ?? 0.1;
  const geometry = new THREE.SphereGeometry(radius, 12, 12);
  const baseColor = shot.color ?? 0xffffff;
  const emissiveColor = new THREE.Color(baseColor).multiplyScalar(shot.type === 'pee' ? 0.08 : 0.3);
  const materialConfig = {
    color: baseColor,
    emissive: emissiveColor,
    roughness: shot.type === 'pee' ? 0.68 : 0.35,
    metalness: shot.type === 'pee' ? 0.04 : 0.15
  };
  if(shot.type === 'pee'){
    materialConfig.transparent = true;
    materialConfig.opacity = 0.78;
    materialConfig.depthWrite = false;
  }
  const material = new THREE.MeshStandardMaterial(materialConfig);
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(shot.pos[0], shot.pos[1], shot.pos[2]);
  const velocity = dir.clone().multiplyScalar(shot.speed ?? 0);
  mesh.userData = {
    type: shot.type || 'pulse',
    owner: ownerId,
    dir,
    speed: shot.speed ?? 10,
    velocity,
    damage: shot.damage ?? 1,
    life: shot.ttl ?? 2,
    maxLife: shot.ttl ?? 2,
    hitRadius: shot.hitRadius ?? radius*2,
    explode: shot.explode ?? 0,
    pierce: shot.pierce ?? 0,
    gravity: shot.gravity ?? 0
  };
  scene.add(mesh); bullets.push(mesh);
  return mesh;
}

function cleanupBullet(index){
  const mesh = bullets[index];
  if(!mesh) return;
  scene.remove(mesh);
  bullets.splice(index,1);
}

function scareEnemy(enemy){
  if(!enemy || !enemy.userData) return;
  const data = enemy.userData;
  const fleeDuration = 2.4;
  const fleeSpeed = 4.5;
  data.fleeTimer = Math.max(data.fleeTimer || 0, fleeDuration);
  data.fleeSpeed = Math.max(data.fleeSpeed || 0, fleeSpeed);
}

function damageEnemyAtIndex(idx, amount, onSurvive){
  const enemy = enemies[idx];
  if(!enemy) return false;
  if(typeof enemy.userData.hp !== 'number'){ enemy.userData.hp = 2; }
  enemy.userData.hp -= amount;
  if(enemy.userData.hp <= 0){
    enemyGroup.remove(enemy);
    enemies.splice(idx,1);
    score += 10;
    updateHUD();
    return true;
  }
  if(typeof onSurvive === 'function') onSurvive(enemy);
  return false;
}

function applyExplosion(position, radius, damage){
  for(let j=enemies.length-1;j>=0;j--){
    const enemy = enemies[j];
    if(!enemy) continue;
    if(enemy.position.distanceTo(position) <= radius){
      damageEnemyAtIndex(j, damage);
    }
  }
}

function applyBeamDamage(beam){
  const data = beam.userData;
  if(!data || !data.origin || !data.dir) return;
  const origin = data.origin;
  const dir = data.dir;
  if(!data.hitIds) data.hitIds = new Set();
  for(let j=enemies.length-1;j>=0;j--){
    const enemy = enemies[j];
    if(!enemy || data.hitIds.has(enemy.uuid)) continue;
    const toEnemy = new THREE.Vector3().subVectors(enemy.position, origin);
    const projection = toEnemy.dot(dir);
    if(projection < 0 || projection > data.length) continue;
    const perpendicularSq = toEnemy.lengthSq() - projection*projection;
    const radiusSq = (data.hitRadius ?? 0.7) ** 2;
    if(perpendicularSq > radiusSq) continue;
    data.hitIds.add(enemy.uuid);
    damageEnemyAtIndex(j, data.damage ?? 2);
  }
}

function shoot(){
  if(!player.alive || weaponWheelState.open) return false;
  const cfg = weaponConfigById.get(player.weapon) || weaponConfigs[0];
  const interval = cfg.fireInterval ?? 0.3;
  if(shootState.cooldown > 0) return false;
  shootState.cooldown = interval;
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  const origin = player.thirdPerson ? player.pos.clone().add(new THREE.Vector3(0,0.7,0)) : camera.getWorldPosition(new THREE.Vector3());
  const shots = createShotsForWeapon(cfg, origin, dir);
  const serialized = [];
  shots.forEach(shot=>{
    spawnBulletFromShot(shot, player.id);
    serialized.push({...shot});
  });
  const weaponId = cfg?.id ?? player.weapon;
  sendData({t:'shoot', w: weaponId, shots: serialized});
  if(armRig) armRig.triggerFire();
  return true;
}

window.addEventListener('mousedown', e=>{
  if(e.button===0){
    shootState.mouseDown = true;
    shootState.down = true;
    shoot();
  }
});
window.addEventListener('mouseup', e=>{
  if(e.button===0){
    shootState.mouseDown = false;
    if(!gamepadState.fire && !touchState.fire){
      shootState.down = false;
    }
  }
});
window.addEventListener('blur', ()=>{
  shootState.down = false;
  shootState.mouseDown = false;
});

/* HUD update */
let score = 0;
function updateHUD(){ hud.textContent = `Score: ${score} | Enemies: ${enemies.length} | HP: ${player.hp} | Signaling: ${connectionLabel}`; }
function updatePlayers(){
  let txt = `Players: ${nameInput.value || player.name || 'me'}`;
  let count = 1;
  for(const id in remotePlayers){
    const r = remotePlayers[id];
    txt += '\n' + (r.name || id);
    count += 1;
  }
  playersDiv.textContent = txt;
  updatePopulationSign(count, activeLobbyName);
}

/* Game Over / Retry */
const gameOverDiv = document.getElementById('gameOver');
document.getElementById('retry').addEventListener('click', ()=>{
  // reset player
  player.hp = 1; player.alive = true; player.pos.set(0,0.5,0); player.velocity.set(0,0,0);
  // clear bullets & enemies and reset spawn
  bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
  enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
  SPAWN_INTERVAL = 2500; spawnAccumulator = 0; score = 0;
  // broadcast reset to peers
  sendData({t:'reset'});
  gameOverDiv.style.display = 'none';
  updateHUD(); updatePlayers();
});

/* --------------------------
   Networking: WebSocket assisted P2P
   -------------------------- */
const btnHost = document.getElementById('btnHost');
const btnJoin = document.getElementById('btnJoin');
const btnHide = document.getElementById('btnHide');
let peerConnections = {}; // peerId -> RTCPeerConnection
let dataChannels = {};    // peerId -> DataChannel
let menuOpen = false;
let isHost = false;
let signalingSocket = null;
let localPeerId = '';
let activeRoomCode = '';
let connectionLabel = 'disconnected';
let pendingHostMeta = null;
let lobbyState = { list: [], selected: null };
const SIGNALING_PING_INTERVAL = 5000;
let signalingHeartbeat = null;
let manualSignalingDisconnect = false;
let manualDisconnectMessage = '';
let lastSignalingPong = 0;

/* pause when menu open */
function setMenuOpen(open){
  menuOpen = open;
}

function setSignalingStatus(text, mode='info'){
  connectionLabel = text;
  statusEl.textContent = `Status: ${text}`;
  if(mode === 'connected'){
    statusEl.style.color = '#8f8';
  } else if(mode === 'error'){
    statusEl.style.color = '#f88';
  } else if(mode === 'warning'){
    statusEl.style.color = '#ffd27f';
  } else if(mode === 'connecting'){
    statusEl.style.color = '#ffd27f';
  } else {
    statusEl.style.color = '#fff';
  }
  updateHUD();
}

function logNetwork(msg){
  const now = new Date();
  const stamp = now.toLocaleTimeString();
  networkLogEl.textContent = `${stamp} â€” ${msg}\n${networkLogEl.textContent}`.slice(0, 4000);
}

function stopSignalingHeartbeat(){
  if(signalingHeartbeat){
    clearInterval(signalingHeartbeat);
    signalingHeartbeat = null;
  }
}

function startSignalingHeartbeat(){
  stopSignalingHeartbeat();
  signalingHeartbeat = setInterval(()=>{
    if(!signalingSocket || signalingSocket.readyState !== WebSocket.OPEN) return;
    try{ signalingSocket.send(JSON.stringify({ type:'ping' })); }
    catch(e){}
  }, SIGNALING_PING_INTERVAL);
}

function handleSignalingSocketClosed(wasManual, message){
  stopSignalingHeartbeat();
  if(signalingSocket){
    signalingSocket.onopen = null;
    signalingSocket.onclose = null;
    signalingSocket.onerror = null;
    signalingSocket.onmessage = null;
    signalingSocket = null;
  }
  const note = message || (wasManual ? 'Disconnected.' : 'Signaling connection lost. Existing peers remain connected.');
  manualSignalingDisconnect = false;
  manualDisconnectMessage = '';
  localPeerId = '';
  pendingHostMeta = null;
  setActiveLobbyName('Alexland');
  if(wasManual){
    activeRoomCode = '';
    resetNetworkButtons();
    setSignalingStatus('disconnected');
    if(note) logNetwork(note);
    closeAllPeers();
    if(!lobbyBrowserEl.classList.contains('open')){
      setMenuOpen(false);
    }
  } else {
    resetNetworkButtons();
    setSignalingStatus('relay disconnected', 'warning');
    if(note) logNetwork(note);
  }
}

function clampCapacity(value){
  const num = Number.parseInt(value, 10);
  if(Number.isFinite(num)){
    return Math.min(16, Math.max(1, num));
  }
  return 10;
}

function persistCurrentNetworkForm(){
  const capacityVal = Number.parseInt(lobbyMaxInput.value, 10);
  const clamped = Number.isFinite(capacityVal) ? clampCapacity(capacityVal) : 10;
  savePersistedNetworkSettings({
    server: (serverUrlInput.value || '').trim() || DEFAULT_SIGNALING_URL,
    name: (nameInput.value || '').trim(),
    room: (roomInput.value || '').trim(),
    lobbyName: (lobbyNameInput.value || '').trim(),
    capacity: clamped
  });
}

[nameInput, serverUrlInput, roomInput, lobbyNameInput, lobbyMaxInput].forEach(el=>{
  if(!el) return;
  const handler = ()=> persistCurrentNetworkForm();
  el.addEventListener('change', handler);
  if(el !== lobbyMaxInput){
    el.addEventListener('input', handler);
  }
});

function slugifyRoomName(name){
  if(!name) return '';
  return name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').slice(0, 40);
}

function websocketToHttp(url){
  try{
    const parsed = new URL(url);
    if(parsed.protocol === 'ws:') parsed.protocol = 'http:';
    if(parsed.protocol === 'wss:') parsed.protocol = 'https:';
    return parsed.toString().replace(/\/$/, '');
  }catch(err){
    if(url.startsWith('http')) return url.replace(/\/$/, '');
    return `http://${url.replace(/\/$/, '')}`;
  }
}

function resetLobbySelection(){
  lobbyState.selected = null;
  lobbyDetailNameEl.textContent = 'Select a lobby';
  lobbyDetailMetaEl.textContent = 'Pick a room from the list to see who is inside.';
  lobbyPlayersEl.textContent = 'No lobby selected';
  lobbyPlayersEl.classList.add('empty');
  btnJoinLobby.disabled = true;
  lobbyListEl.querySelectorAll('.lobby-entry').forEach(el=> el.classList.remove('active'));
}

let autoConnectTriggered = false;
function attemptAutoConnectFromStorage(){
  if(autoConnectTriggered) return;
  autoConnectTriggered = true;
  const settings = persistedNetworkSettings || {};
  if(!settings.autoConnect) return;
  const role = settings.lastRole;
  const room = settings.lastRoom;
  if(!role || !room) return;
  if(!roomInput.value){
    roomInput.value = room;
  }
  if(role === 'host' && settings.lastLobbyName && !lobbyNameInput.value){
    lobbyNameInput.value = settings.lastLobbyName;
  }
  setTimeout(()=>{
    beginSignaling(role === 'host' ? 'host' : 'join');
  }, 200);
}

window.addEventListener('load', ()=> attemptAutoConnectFromStorage());

function renderLobbyList(list){
  lobbyListEl.innerHTML = '';
  lobbyState.list = list;
  if(!list.length){
    const empty = document.createElement('div');
    empty.textContent = 'No public lobbies online';
    empty.style.opacity = '0.6';
    empty.style.padding = '12px';
    lobbyListEl.appendChild(empty);
    resetLobbySelection();
    return;
  }
  list.forEach(lobby=>{
    const entry = document.createElement('div');
    entry.className = 'lobby-entry';
    entry.dataset.code = lobby.code;
    const nameSpan = document.createElement('div');
    nameSpan.textContent = lobby.name || lobby.code;
    const countSpan = document.createElement('div');
    countSpan.textContent = `${lobby.players.length}/${lobby.capacity}`;
    countSpan.style.opacity = '0.8';
    entry.appendChild(nameSpan);
    entry.appendChild(countSpan);
    entry.addEventListener('click', ()=>{
      selectLobby(lobby.code);
    });
    lobbyListEl.appendChild(entry);
  });
  resetLobbySelection();
}

function selectLobby(code){
  const lobby = lobbyState.list.find(l=>l.code === code);
  lobbyListEl.querySelectorAll('.lobby-entry').forEach(el=>{
    el.classList.toggle('active', el.dataset.code === code);
  });
  if(!lobby){
    resetLobbySelection();
    return;
  }
  lobbyState.selected = lobby;
  lobbyDetailNameEl.textContent = lobby.name || lobby.code;
  lobbyDetailMetaEl.textContent = `${lobby.players.length}/${lobby.capacity} players`;
  lobbyPlayersEl.classList.toggle('empty', lobby.players.length === 0);
  lobbyPlayersEl.innerHTML = '';
  if(!lobby.players.length){
    const empty = document.createElement('div');
    empty.textContent = 'Be the first to join!';
    empty.style.opacity = '0.75';
    lobbyPlayersEl.appendChild(empty);
  } else {
    lobby.players.forEach(p=>{
      const row = document.createElement('div');
      row.textContent = p.name || p.id;
      lobbyPlayersEl.appendChild(row);
    });
  }
  const full = lobby.players.length >= lobby.capacity;
  btnJoinLobby.disabled = full;
  if(full){
    lobbyDetailMetaEl.textContent += ' (Full)';
  }
}

async function refreshLobbyList(){
  const base = websocketToHttp((serverUrlInput.value || 'ws://localhost:3000').trim());
  try{
    const res = await fetch(`${base}/rooms`, { cache: 'no-store', headers: { 'Accept': 'application/json' } });
    if(!res.ok){
      throw new Error(`Server responded with ${res.status}`);
    }
    const raw = await res.text();
    let data;
    try{
      data = JSON.parse(raw);
    }catch(parseErr){
      const snippet = raw.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim().slice(0, 120);
      throw new Error(snippet ? `Invalid JSON: ${snippet}...` : 'Invalid JSON response');
    }
    renderLobbyList(Array.isArray(data.rooms) ? data.rooms : []);
    logNetwork(`Loaded ${Array.isArray(data.rooms) ? data.rooms.length : 0} lobby entries`);
  }catch(err){
    logNetwork(`Failed to load lobbies: ${err.message || err}`);
    renderLobbyList([]);
  }
}

function openLobbyBrowser(){
  lobbyBrowserEl.classList.add('open');
  setMenuOpen(true);
  refreshLobbyList();
}

function closeLobbyBrowser(){
  lobbyBrowserEl.classList.remove('open');
  resetLobbySelection();
  if(!signalingSocket){
    setMenuOpen(false);
  }
}

function gatherHostMeta(){
  const lobbyName = lobbyNameInput.value.trim();
  const capacity = clampCapacity(lobbyMaxInput.value);
  return { lobbyName, capacity };
}

function ensureRoomCode(meta){
  if(roomInput.value.trim()) return;
  const fromName = slugifyRoomName(meta.lobbyName);
  if(fromName){
    roomInput.value = fromName;
  } else {
    roomInput.value = `room-${Math.floor(Math.random()*9000 + 1000)}`;
  }
}

function joinSelectedLobby(){
  if(!lobbyState.selected) return;
  if(signalingSocket && signalingSocket.readyState === WebSocket.OPEN){
    alert('Already connected to a lobby. Disconnect first.');
    return;
  }
  roomInput.value = lobbyState.selected.code;
  closeLobbyBrowser();
  beginSignaling('join');
}

function resetNetworkButtons(){
  btnHost.disabled = false;
  btnJoin.disabled = false;
  btnDisconnect.disabled = true;
}

/* Hide/Show UI behavior */
btnHide.onclick = ()=>{
  const networkDiv = document.getElementById('network');
  const collapsed = networkDiv.dataset.collapsed === '1';
  if(collapsed){
    networkDiv.dataset.collapsed = '';
    networkDiv.style.maxHeight = '';
    networkDiv.style.overflow = '';
    btnHide.textContent = 'Hide UI';
    setMenuOpen(true);
  } else {
    networkDiv.dataset.collapsed = '1';
    networkDiv.style.maxHeight = '32px';
    networkDiv.style.overflow = 'hidden';
    btnHide.textContent = 'Show UI';
    setMenuOpen(false);
  }
};

function closeAllPeers(reason){
  for(const id in dataChannels){
    try{ dataChannels[id].close(); }catch(e){}
  }
  for(const id in peerConnections){
    try{ peerConnections[id].close(); }catch(e){}
  }
  dataChannels = {};
  peerConnections = {};
  const remoteIds = Object.keys(remotePlayers);
  remoteIds.forEach(id=> removeRemote(id));
  if(reason) logNetwork(reason);
}

function disconnectFromSignaling(message){
  const note = message || 'Disconnected.';
  manualSignalingDisconnect = true;
  manualDisconnectMessage = note;
  savePersistedNetworkSettings({ autoConnect: false });
  if(signalingSocket && (signalingSocket.readyState === WebSocket.OPEN || signalingSocket.readyState === WebSocket.CONNECTING || signalingSocket.readyState === WebSocket.CLOSING)){
    try{ signalingSocket.close(); }catch(e){}
    return;
  }
  handleSignalingSocketClosed(true, note);
}

btnDisconnect.onclick = ()=>{
  disconnectFromSignaling('Disconnected by user');
};

function sendSignal(obj){
  if(!signalingSocket || signalingSocket.readyState !== WebSocket.OPEN) return;
  const payload = {...obj, room: activeRoomCode};
  if(localPeerId){
    payload.from = localPeerId;
  }
  try{
    signalingSocket.send(JSON.stringify(payload));
  }catch(err){
    logNetwork(`Failed to send signal: ${err.message || err}`);
  }
}

function beginSignaling(role, meta = null){
  if(signalingSocket && signalingSocket.readyState === WebSocket.OPEN){
    logNetwork('Already connected to signaling server.');
    return;
  }
  isHost = role === 'host';
  manualSignalingDisconnect = false;
  manualDisconnectMessage = '';
  stopSignalingHeartbeat();
  if(isHost){
    const hostMeta = meta || gatherHostMeta();
    pendingHostMeta = { lobbyName: hostMeta.lobbyName || '', capacity: hostMeta.capacity || 10 };
    ensureRoomCode(pendingHostMeta);
  } else {
    pendingHostMeta = null;
  }
  player.name = nameInput.value || (isHost ? 'Host' : 'Player');
  updatePlayers();
  persistCurrentNetworkForm();
  const url = (serverUrlInput.value || 'ws://localhost:3000').trim();
  if(!url){
    alert('Enter a signaling server URL');
    return;
  }
  activeRoomCode = (roomInput.value || '').trim();
  if(!activeRoomCode){
    alert('Enter or generate a room code.');
    return;
  }
  if(isHost && pendingHostMeta){
    setActiveLobbyName(pendingHostMeta.lobbyName || activeRoomCode);
  } else {
    setActiveLobbyName(activeRoomCode);
  }
  savePersistedNetworkSettings({
    autoConnect: true,
    server: url,
    name: player.name,
    room: activeRoomCode,
    lobbyName: isHost && pendingHostMeta ? (pendingHostMeta.lobbyName || activeRoomCode) : activeLobbyName,
    capacity: isHost && pendingHostMeta ? pendingHostMeta.capacity : Number.parseInt(lobbyMaxInput.value, 10) || 10,
    lastRole: isHost ? 'host' : 'join',
    lastRoom: activeRoomCode,
    lastLobbyName: activeLobbyName
  });
  try{
    signalingSocket = new WebSocket(url);
  }catch(err){
    logNetwork(`Failed to connect: ${err.message || err}`);
    setSignalingStatus('connection failed', 'error');
    resetNetworkButtons();
    return;
  }
  setMenuOpen(true);
  btnHost.disabled = true;
  btnJoin.disabled = true;
  btnDisconnect.disabled = true;
  setSignalingStatus('connecting...', 'connecting');
  logNetwork(`Connecting to ${url} as ${isHost ? 'host' : 'joiner'} (room ${activeRoomCode})`);
  if(lobbyBrowserEl.classList.contains('open')){
    closeLobbyBrowser();
  }

  signalingSocket.onopen = ()=>{
    setSignalingStatus('connected', 'connected');
    btnDisconnect.disabled = false;
    const hello = { type:'hello', role: isHost ? 'host' : 'join', room: activeRoomCode, name: player.name, playerId: player.id };
    if(isHost && pendingHostMeta){
      if(pendingHostMeta.lobbyName){
        hello.lobbyName = pendingHostMeta.lobbyName;
      }
      hello.capacity = pendingHostMeta.capacity || 10;
    }
    try{ signalingSocket.send(JSON.stringify(hello)); }catch(err){ logNetwork(`Failed to register: ${err.message || err}`); }
    lastSignalingPong = performance.now();
    startSignalingHeartbeat();
    try{ signalingSocket.send(JSON.stringify({ type:'ping' })); }
    catch(e){}
  };
  signalingSocket.onclose = ()=>{
    const wasManual = manualSignalingDisconnect;
    const note = wasManual ? (manualDisconnectMessage || 'Disconnected.') : 'Signaling connection closed. Existing peers remain connected.';
    handleSignalingSocketClosed(wasManual, note);
  };
  signalingSocket.onerror = err=>{
    let detail = '';
    if(err && typeof err === 'object'){
      if('message' in err && err.message){
        detail = err.message;
      } else if('type' in err && err.type){
        detail = err.type;
      } else {
        try{ detail = JSON.stringify(err); }
        catch(e){ detail = String(err); }
      }
    } else {
      detail = String(err);
    }
    logNetwork(`Signaling error: ${detail}`);
  };
  signalingSocket.onmessage = ev=>{
    let msg;
    try{ msg = JSON.parse(ev.data); }catch(e){ return; }
    handleSignalMessage(msg);
  };
}

btnHost.onclick = ()=>{
  const meta = gatherHostMeta();
  ensureRoomCode(meta);
  beginSignaling('host', meta);
};
btnJoin.onclick = ()=> beginSignaling('join');
btnCreateLobby.onclick = ()=>{
  const meta = gatherHostMeta();
  if(!meta.lobbyName){
    alert('Enter a lobby name before creating a lobby.');
    return;
  }
  ensureRoomCode(meta);
  beginSignaling('host', meta);
};
btnBrowseLobbies.onclick = ()=>{
  if(signalingSocket && signalingSocket.readyState === WebSocket.OPEN){
    alert('Disconnect before browsing other lobbies.');
    return;
  }
  openLobbyBrowser();
};
btnRefreshLobbies.onclick = ()=> refreshLobbyList();
btnCloseLobbyBrowser.onclick = ()=> closeLobbyBrowser();
btnJoinLobby.onclick = ()=> joinSelectedLobby();

function handleSignalMessage(msg){
  if(msg.type === 'pong'){
    lastSignalingPong = performance.now();
    return;
  }
  if(msg.type === 'welcome'){
    localPeerId = msg.id;
    logNetwork(`Registered on server as ${localPeerId}`);
    if(msg.meta && msg.meta.name){
      setActiveLobbyName(msg.meta.name);
    }
    savePersistedNetworkSettings({
      autoConnect: true,
      lastRole: isHost ? 'host' : 'join',
      lastRoom: activeRoomCode,
      lastLobbyName: activeLobbyName
    });
    return;
  }
  if(msg.type === 'error'){
    setSignalingStatus('error', 'error');
    logNetwork(`Server error: ${msg.message}`);
    btnDisconnect.disabled = false;
    return;
  }
  if(msg.type === 'join-request' && isHost){
    logNetwork(`Join request from ${msg.name || msg.peerId}`);
    createOfferForPeer(msg.peerId, msg.name, msg.playerId);
    return;
  }
  if(msg.type === 'offer' && !isHost){
    receiveOfferFromHost(msg);
    return;
  }
  if(msg.type === 'answer' && isHost){
    applyAnswerFromPeer(msg);
    return;
  }
  if(msg.type === 'ice'){
    applyRemoteIceCandidate(msg);
    return;
  }
  if(msg.type === 'peer-left'){
    logNetwork(`Peer ${msg.peerId} left`);
    removeRemote(msg.peerId);
    if(peerConnections[msg.peerId]){
      try{ peerConnections[msg.peerId].close(); }catch(e){}
      delete peerConnections[msg.peerId];
    }
    if(dataChannels[msg.peerId]) delete dataChannels[msg.peerId];
    updatePlayers();
  }
}

function createOfferForPeer(peerId, displayName, playerId){
  const pc = makePeer(peerId, playerId);
  const channel = pc.createDataChannel('game');
  setupDataChannel(peerId, channel, displayName, playerId);
  pc.createOffer().then(offer=>{
    return pc.setLocalDescription(offer);
  }).then(()=>{
    sendSignal({type:'offer', target: peerId, sdp: pc.localDescription});
  }).catch(err=>{
    logNetwork(`Offer error for ${peerId}: ${err.message || err}`);
  });
}

function receiveOfferFromHost(msg){
  const peerId = msg.peerId;
  const pc = makePeer(peerId, msg.playerId);
  pc.ondatachannel = ev=> setupDataChannel(peerId, ev.channel, msg.name, msg.playerId);
  const remoteDesc = new RTCSessionDescription(msg.sdp);
  pc.setRemoteDescription(remoteDesc).then(()=>{
    return pc.createAnswer();
  }).then(answer=>{
    return pc.setLocalDescription(answer);
  }).then(()=>{
    sendSignal({type:'answer', target: peerId, sdp: pc.localDescription});
  }).catch(err=>{
    logNetwork(`Answer error: ${err.message || err}`);
  });
}

function applyAnswerFromPeer(msg){
  const pc = peerConnections[msg.peerId];
  if(!pc) return;
  const remoteDesc = new RTCSessionDescription(msg.sdp);
  pc.setRemoteDescription(remoteDesc).catch(err=>{
    logNetwork(`Remote desc error: ${err.message || err}`);
  });
}

function applyRemoteIceCandidate(msg){
  const pc = peerConnections[msg.peerId];
  if(!pc || !msg.candidate) return;
  pc.addIceCandidate(new RTCIceCandidate(msg.candidate)).catch(err=>{
    logNetwork(`ICE candidate error: ${err.message || err}`);
  });
}

/* helper to make a new RTCPeerConnection */
function makePeer(peerId, remotePlayerId){
  const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  peerConnections[peerId] = pc;
  pc.onicecandidate = ev=>{
    if(ev.candidate){
      sendSignal({type:'ice', target: peerId, candidate: ev.candidate});
    }
  };
  pc.onconnectionstatechange = ()=>{
    if(pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed'){
      removeRemote(peerId);
      delete peerConnections[peerId];
      delete dataChannels[peerId];
      updatePlayers();
    }
  };
  pc.ondatachannel = ev=>{
    setupDataChannel(peerId, ev.channel, undefined, remotePlayerId);
  };
  return pc;
}

/* set up datachannel handlers */
function setupDataChannel(peerId, ch, displayName, remotePlayerId){
  dataChannels[peerId] = ch;
  if(displayName){
    if(!remotePlayers[peerId]) remotePlayers[peerId] = {id: remotePlayerId || peerId, pos:new THREE.Vector3(), yaw:0, pitch:0, name:displayName};
    updatePlayers();
  }
  ch.onopen = ()=>{ logNetwork(`Data channel open: ${peerId}`); };
  ch.onmessage = ev=>{
    try{
      const msg = JSON.parse(ev.data);
      handleRemoteMessage(peerId, msg);
    }catch(e){}
  };
  ch.onclose = ()=>{
    logNetwork(`Data channel closed: ${peerId}`);
    delete dataChannels[peerId];
    delete peerConnections[peerId];
    removeRemote(peerId);
    if(isHost){
      broadcast({t:'peer_left', from:peerId}, peerId);
    }
  };
}

/* broadcast object to all open DCs */
function sendData(obj, skipId){
  const str = JSON.stringify(obj);
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(id === skipId) continue;
    if(ch && ch.readyState === 'open'){
      try{ ch.send(str); }catch(e){}
    }
  }
}

function broadcast(obj, skipId){
  sendData(obj, skipId);
}

function removeRemote(remoteId){
  const rp = remotePlayers[remoteId];
  if(!rp) return;
  if(rp.mesh){ scene.remove(rp.mesh); }
  delete remotePlayers[remoteId];
  updatePlayers();
}

/* handle incoming messages from peers */
function handleRemoteMessage(peerId, msg){
  const sourceId = (peerId === 'host' && msg.from) ? msg.from : peerId;

  if(isHost && peerId !== 'host'){
    const forward = {...msg, from: peerId};
    broadcast(forward, peerId);
  }

  if(msg.t === 'peer_left'){
    removeRemote(sourceId);
    return;
  }

  if(msg.t === 'state'){
    if(!remotePlayers[sourceId]) remotePlayers[sourceId] = {id:sourceId, pos:new THREE.Vector3(), yaw:0, pitch:0, name:msg.name||sourceId};
    const rp = remotePlayers[sourceId];
    rp.pos.set(msg.p[0], msg.p[1], msg.p[2]);
    rp.yaw = msg.y; rp.pitch = msg.r; rp.hp = msg.hp; rp.name = msg.name || sourceId;
    const animMsg = msg.a || {};
    rp.anim = {
      mode: animMsg.m || (rp.anim ? rp.anim.mode : 'idle'),
      speed: typeof animMsg.s === 'number' ? animMsg.s : (rp.anim ? rp.anim.speed : 0),
      variant: typeof animMsg.v === 'number' ? animMsg.v : (rp.anim ? rp.anim.variant : 0)
    };
    updatePlayers();
  }
  if(msg.t === 'shoot'){
    if(Array.isArray(msg.shots)){
      msg.shots.forEach(shot=> spawnBulletFromShot(shot, sourceId));
    } else if(msg.p && msg.d){
      let fallbackType = 'pulse';
      if(msg.w === 2) fallbackType = 'rocket';
      else if(msg.w === 3) fallbackType = 'pellet';
      else if(msg.w === 4) fallbackType = 'pee';
      const fallback = {
        type: fallbackType,
        pos: msg.p,
        dir: msg.d,
        speed: msg.w === 2 ? 8 : msg.w === 4 ? 12 : 12,
        size: msg.w === 2 ? 0.3 : msg.w === 4 ? 0.06 : 0.1,
        color: msg.w === 2 ? 0xffaa00 : msg.w === 4 ? 0xfff57a : 0xffff00,
        damage: msg.w === 2 ? 2 : msg.w === 4 ? 0.03 : 1,
        ttl: msg.w === 2 ? 4 : msg.w === 4 ? 0.6 : 2,
        hitRadius: msg.w === 2 ? 0.6 : msg.w === 4 ? 0.28 : 0.45,
        explode: msg.w === 2 ? 1.8 : 0,
        gravity: msg.w === 4 ? 4.2 : 0
      };
      spawnBulletFromShot(fallback, sourceId);
    }
  }
  if(msg.t === 'reset'){
    bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
    enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
    SPAWN_INTERVAL = 2500; spawnAccumulator = 0; score = 0; updateHUD();
  }
}

/* periodic state broadcast */
setInterval(()=>{
  const payload = {
    t:'state',
    id:player.id,
    p:[player.pos.x, player.pos.y, player.pos.z],
    y:player.yaw,
    r:player.pitch,
    hp:player.hp,
    name: nameInput.value || player.name,
    a: { m: player.anim.mode, s: Number((player.anim.speed||0).toFixed(2)), v: player.anim.variant || 0 }
  };
  sendData(payload);
}, 80);

/* -------------------------
   Game logic & physics
   ------------------------- */
/* Movement vectors: CORRECT so W is forward */
function updatePlayer(dt){
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));
  const inputMove = aggregatedInput.move.clone();
  const move = new THREE.Vector3();
  if(inputMove.lengthSq()>0){
    move.addScaledVector(forward, inputMove.y);
    move.addScaledVector(right, inputMove.x);
    if(move.lengthSq()>0) move.normalize();
  }
  const wasGrounded = player.grounded;
  player.slideCooldown = Math.max(0, player.slideCooldown - dt);
  player.dashCooldown = Math.max(0, player.dashCooldown - dt);
  const dashWasActive = player.dashTimer > 0;
  if(player.dashTimer > 0){
    player.dashTimer = Math.max(0, player.dashTimer - dt);
    if(player.dashTimer <= 0){
      player.dashVector.set(0,0,0);
    }
  }

  const slidePressed = aggregatedInput.slidePressed && player.grounded && move.lengthSq()>0 && player.slideCooldown <= 0 && !player.isSliding;
  if(slidePressed){
    player.isSliding = true;
    player.slideTimer = 0.65;
    player.slideDirection.copy(move.lengthSq()>0 ? move : forward);
    player.slideCooldown = 0.95;
  }
  if(player.isSliding){
    player.slideTimer -= dt;
    const releaseSlide = !aggregatedInput.slideHeld && player.slideTimer < 0.3;
    if(player.slideTimer <= 0 || releaseSlide){
      player.isSliding = false;
    } else if(move.lengthSq()>0){
      player.slideDirection.lerp(move, Math.min(1, dt*6));
      if(player.slideDirection.lengthSq()>0){ player.slideDirection.normalize(); }
    }
  }

  const sprinting = keyboardState.slideHeld && !player.isSliding && player.grounded && move.lengthSq()>0;
  const controlDir = player.isSliding ? player.slideDirection.clone() : move.clone();
  const baseSpeed = player.isSliding ? player.speed * 2.6 : player.speed * (player.grounded ? (sprinting ? 1.35 : 1) : 0.78);
  controlDir.multiplyScalar(baseSpeed);

  if(dashWasActive){
    player.velocity.x = player.dashVector.x * 11;
    player.velocity.z = player.dashVector.z * 11;
  } else {
    const accel = player.grounded ? 12 : 4.5;
    player.velocity.x = THREE.MathUtils.damp(player.velocity.x, controlDir.x, accel, dt);
    player.velocity.z = THREE.MathUtils.damp(player.velocity.z, controlDir.z, accel, dt);
  }

  const nextPos = player.pos.clone();
  nextPos.x += player.velocity.x * dt;
  nextPos.z += player.velocity.z * dt;
  const collision = resolveWorldCollisions(nextPos);
  player.pos.x = collision.position.x;
  player.pos.z = collision.position.z;
  if(collision.normal){
    if(!player.grounded){
      player.wallNormal.copy(collision.normal);
      player.wallTouchTimer = 0.28;
    } else {
      player.wallTouchTimer = 0;
    }
    if(player.climbing){
      player.pos.addScaledVector(collision.normal, -0.02);
    }
    if(!player.isSliding){
      // keep facing consistent
    }
  } else {
    player.wallTouchTimer = Math.max(0, player.wallTouchTimer - dt);
  }
  if(player.wallTouchTimer <= 0){
    player.wallNormal.set(0,0,0);
    if(!player.grounded){
      player.climbing = false;
    }
  }

  if(!player.climbing && player.wallTouchTimer > 0 && aggregatedInput.jumpHeld && !player.grounded){
    player.climbing = true;
    player.climbTimer = 0.6;
  }
  if(player.climbing){
    player.climbTimer = Math.max(0, player.climbTimer - dt);
    if(player.climbTimer <= 0 || !aggregatedInput.jumpHeld){
      player.climbing = false;
    }
  }

  player.velocity.y -= player.gravity * dt;
  if(player.climbing){
    player.velocity.y = Math.max(player.velocity.y, player.climbSpeed);
    if(player.wallNormal.lengthSq()>0){
      player.pos.addScaledVector(player.wallNormal, -0.02);
    }
  }
  player.pos.y += player.velocity.y * dt;

  if(player.pos.y <= player.groundHeight){
    if(player.velocity.y < 0) player.velocity.y = 0;
    player.pos.y = player.groundHeight;
    if(!player.grounded){
      player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    }
    player.grounded = true;
    player.climbing = false;
    player.climbTimer = 0;
  } else {
    player.grounded = false;
  }

  if(player.grounded){
    player.coyoteTimer = 0.14;
    player.wallTouchTimer = 0;
  } else {
    player.coyoteTimer = wasGrounded ? 0.14 : Math.max(0, player.coyoteTimer - dt);
  }

  const horizontalSpeed = Math.sqrt(player.velocity.x*player.velocity.x + player.velocity.z*player.velocity.z);
  player.anim.speed = Math.min(1.5, horizontalSpeed / player.speed);
  if(player.isSliding){
    player.anim.mode = 'slide';
  } else if(player.dashTimer > 0){
    player.anim.mode = 'dash';
  } else if(player.climbing){
    player.anim.mode = 'climb';
  } else if(!player.grounded){
    player.anim.mode = 'air';
  } else if(player.anim.speed > 0.15){
    player.anim.mode = sprinting ? 'sprint' : 'run';
  } else {
    player.anim.mode = 'idle';
  }
  player.anim.variant = sprinting ? 1 : 0;

  // camera
  if(player.thirdPerson){
    alexMesh.visible = true;
    const distance = 5;
    const phi = Math.PI/2 + player.pitch;
    const theta = player.yaw;
    const camX = player.pos.x + distance * Math.sin(phi) * Math.sin(theta);
    const camY = player.pos.y + distance * Math.cos(phi);
    const camZ = player.pos.z + distance * Math.sin(phi) * Math.cos(theta);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(player.pos.x, player.pos.y + 0.7, player.pos.z);
  } else {
    alexMesh.visible = false;
    const camHeight = player.isSliding ? 0.45 : 0.7;
    camera.position.copy(player.pos.clone().add(new THREE.Vector3(0,camHeight,0)));
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
  }

  alexMesh.position.copy(player.pos);
  if(player.isSliding){
    alexMesh.position.y -= 0.15;
  }
  alexMesh.rotation.y = player.yaw;
  const avatar = alexMesh.children[0];
  if(avatar){
    updateHumanoidRig(avatar, player.anim, dt);
  }
}

/* bullets & enemies update */
function isPlayerJumping(){
  return !player.grounded;
}

function updateBullets(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    const data = b.userData || {};
    if(typeof data.life === 'number'){
      data.life -= dt;
    } else {
      data.life = 3;
    }

    if(data.type === 'beam'){
      if(b.material && typeof b.material.opacity === 'number' && data.duration){
        b.material.opacity = Math.max(0, (data.life / data.duration) * 0.7);
      }
      applyBeamDamage(b);
      if(data.life <= 0){
        cleanupBullet(i);
      }
      continue;
    }

    if(data.velocity){
      if(data.gravity){
        data.velocity.y -= data.gravity * dt;
      }
      b.position.addScaledVector(data.velocity, dt);
    } else if(data.dir){
      b.position.addScaledVector(data.dir, (data.speed ?? 0) * dt);
    }

    if(data.type === 'pee' && b.material && typeof b.material.opacity === 'number' && data.maxLife){
      const lifeRatio = Math.max(0, Math.min(1, data.life / data.maxLife));
      b.material.opacity = 0.25 + lifeRatio * 0.55;
    }

    let removed = false;
    for(let j=enemies.length-1;j>=0;j--){
      const enemy = enemies[j];
      if(!enemy) continue;
      const dist = b.position.distanceTo(enemy.position);
      if(dist <= (data.hitRadius ?? 0.45)){
        if(data.type === 'rocket' && data.explode){
          applyExplosion(b.position, data.explode, data.damage ?? 2);
        } else {
          const shouldScare = data.type === 'pee' && data.owner === player.id && isPlayerJumping();
          const onSurvive = shouldScare ? scareEnemy : undefined;
          damageEnemyAtIndex(j, data.damage ?? 1, onSurvive);
        }
        if(data.pierce && data.pierce > 0){
          data.pierce -= 1;
          continue;
        }
        removed = true;
        break;
      }
    }

    if(removed){
      cleanupBullet(i);
      continue;
    }

    if(data.life <= 0){
      if(data.type === 'rocket' && data.explode){
        applyExplosion(b.position, data.explode, data.damage ?? 2);
      }
      cleanupBullet(i);
    }
  }
}
const enemyScratch = new THREE.Vector3();
function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(!e) continue;
    const data = e.userData || (e.userData = {});
    enemyScratch.copy(player.pos).sub(e.position);
    enemyScratch.y = 0;
    const dist = enemyScratch.length();
    if(dist === 0) continue;
    let animSpeed = 0.6;
    if(data.fleeTimer && data.fleeTimer > 0){
      data.fleeTimer = Math.max(0, data.fleeTimer - dt);
      const fleeDir = enemyScratch.normalize().negate();
      const fleeSpeed = data.fleeSpeed || 4.5;
      animSpeed = Math.min(1.4, fleeSpeed / 4);
      e.position.addScaledVector(fleeDir, fleeSpeed * dt);
    } else {
      const chaseDir = enemyScratch.normalize();
      const chaseSpeed = data.speed || 1.2;
      animSpeed = Math.min(1.2, chaseSpeed / 1.5);
      e.position.addScaledVector(chaseDir, chaseSpeed * dt);
      if(dist < 1.0 && player.alive){ player.hp = 0; player.alive = false; updateHUD(); gameOverDiv.style.display = 'block'; }
    }
    updateHumanoidRig(e, {mode:'run', speed:animSpeed}, dt);
  }
}

/* render remote players */
function renderRemotes(dt){
  const template = getActivePlayerTemplate();
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(!rp.mesh){
      rp.mesh = cloneTemplate(template);
      scene.add(rp.mesh);
    }
    if(rp.pos) rp.mesh.position.copy(rp.pos);
    rp.mesh.rotation.y = rp.yaw || 0;
    if(rp.mesh){
      updateHumanoidRig(rp.mesh, rp.anim || {mode:'idle', speed:0}, dt);
    }
  }
}

/* spawn timer */
let SPAWN_INTERVAL = 2500;
let spawnAccumulator = 0;

/* pause logic controlled by menuOpen */
function gameTick(now){
  const rawDt = Math.min(0.05, (now - (gameTick.last||now))/1000);
  gameTick.last = now;
  updateAggregatedInput(rawDt);
  const slowMoActive = weaponWheelState.open && !weaponWheelIsMultiplayer();
  const timeScale = slowMoActive ? 0.25 : 1;
  const dt = rawDt * timeScale;
  shootState.cooldown = Math.max(0, shootState.cooldown - rawDt);

  if(!menuOpen){
    spawnAccumulator += dt;
    while(spawnAccumulator * 1000 >= SPAWN_INTERVAL){
      spawnEnemy();
      spawnAccumulator -= SPAWN_INTERVAL / 1000;
      if(SPAWN_INTERVAL > 500) SPAWN_INTERVAL *= 0.995;
    }
    if(player.alive){
      updatePlayer(dt);
      updateBullets(dt);
      updateEnemies(dt);
      if(shootState.down){
        shoot();
      }
    }
    renderRemotes(dt);
  }

  if(armRig){
    armRig.update(dt);
  }

  updateHUD();
  updatePlayers();
  renderer.render(scene, camera);
  requestAnimationFrame(gameTick);
}
requestAnimationFrame(gameTick);

/* Expose debugging objects */
window._peers = peerConnections;
window._dcs = dataChannels;
window._remote = remotePlayers;
window._send = sendData;

window.addEventListener('beforeunload', ()=>{
  try{ sendData({t:'peer_left', from: isHost ? 'host' : 'self'}); }catch(e){}
});

</script>
</body>
</html>
