<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Shooter — LAN P2P (manual SDP)</title>
<style>
  :root{--bg:#000;--ui-bg:rgba(0,0,0,0.35);--btn:#222}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  canvas{display:block}
  .hud{position:absolute;left:8px;top:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px);font-size:14px}
  .players{position:absolute;left:8px;top:96px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px);white-space:pre-line;font-size:13px}
  .instructions{position:absolute;right:8px;top:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:260px;font-size:13px}
  .crosshair{position:absolute;left:50%;top:50%;width:12px;height:12px;margin:-6px 0 0 -6px;pointer-events:none;z-index:40}
  .crosshair:before,.crosshair:after{content:'';position:absolute;background:#fff}
  .crosshair:before{left:50%;top:0;transform:translateX(-50%);width:2px;height:12px}
  .crosshair:after{top:50%;left:0;transform:translateY(-50%);height:2px;width:12px}
  .weapon-wheel{position:absolute;left:50%;top:50%;width:260px;height:260px;margin:-130px 0 0 -130px;border-radius:50%;background:rgba(0,0,0,0.6);border:2px solid rgba(255,255,255,0.2);display:none;z-index:70;pointer-events:none;box-shadow:0 0 30px rgba(0,0,0,0.5)}
  .weapon-wheel.open{display:block}
  .weapon-wheel::after{content:'';position:absolute;left:50%;top:50%;width:80px;height:80px;margin:-40px 0 0 -40px;border-radius:50%;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.25)}
  .weapon-wheel-option{position:absolute;width:90px;height:90px;border-radius:14px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;text-align:center;font-size:13px;line-height:1.3;padding:8px;transform:translate(-50%,-50%);transition:background 0.15s,border 0.15s,transform 0.15s}
  .weapon-wheel-option strong{display:block;font-size:14px;margin-bottom:4px}
  .weapon-wheel-option span{display:block;font-size:12px;opacity:0.75}
  .weapon-wheel-option.active{background:rgba(255,255,255,0.25);border-color:rgba(255,255,255,0.55);transform:translate(-50%,-50%) scale(1.08)}
  .weapon-wheel-center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;font-size:16px;line-height:1.4}
  .weapon-wheel-center span{display:block;font-size:12px;opacity:0.7}
  .weapon-wheel-hint{position:absolute;left:50%;bottom:-34px;transform:translateX(-50%);font-size:12px;color:#ddd;text-align:center;opacity:0.9}
  #gameOver{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:90;padding:16px;background:rgba(0,0,0,0.9);display:none;text-align:center;border-radius:10px}
  #network{position:absolute;left:8px;bottom:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px)}
  textarea{width:480px;height:120px;background:#111;color:#fff;border:1px solid #333;padding:6px;border-radius:6px;resize:vertical}
  @media(max-width:640px){ textarea{width:calc(100vw - 32px)} .instructions{max-width:140px;font-size:12px} .hud,.players,.instructions,#network{padding:6px;font-size:13px} }
  button{padding:6px 10px;margin:4px;border-radius:8px;border:none;background:var(--btn);color:#fff;cursor:pointer}
  input[type="text"]{padding:6px;border-radius:6px;border:1px solid #333;background:#111;color:#fff}
  label{font-size:13px;margin-right:8px}
  .small{font-size:12px}
</style>
</head>
<body>
<div id="container">
  <div class="hud" id="hud">Score: 0 | Enemies: 0 | HP: 1 | Host IP: N/A</div>

  <div class="players" id="players">Players: me</div>

  <div class="instructions">
    <strong>Controls</strong><br>
    WASD - move<br>Mouse - look<br>Click - shoot (hold to spray)<br>Space - jump<br>Y - toggle view<br>Esc - release mouse<br>1-4 - quick swap weapons<br>Hold Q - weapon wheel<br>Weapons: 1 Pulse | 2 Rocket | 3 Scatter | 4 Pee Stream
  </div>

  <div class="crosshair"></div>

  <div id="weaponWheel" class="weapon-wheel">
    <div class="weapon-wheel-hint">Move the mouse to highlight a weapon</div>
  </div>

  <div id="gameOver">
    <div style="font-size:20px">Game Over</div>
    <img src="backflip.gif" alt="backflip" style="width:180px">
    <br><button id="retry">Retry</button>
  </div>

  <div id="network">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>Name: <input id="nameInput" type="text" placeholder="Your name" style="width:140px"></label>
      <label>Host IP (display only): <input id="hostIp" type="text" placeholder="e.g. 25.x.x.x" style="width:140px"></label>
      <button id="btnHost">Host</button>
      <button id="btnJoin">Join</button>
      <button id="btnHide">Hide UI</button>
    </div>

    <div id="hostControls" style="margin-top:8px;display:none">
      <div><button id="createOffer">Create Offer (for a joiner)</button></div>
      <div style="margin-top:6px">Offer (copy → give to joiner):</div>
      <textarea id="offerOut" readonly placeholder="Offer will appear here..."></textarea>
      <div style="margin-top:6px">Paste Answer from joiner:</div>
      <textarea id="answerIn" placeholder="Paste joiner's answer JSON here"></textarea>
      <div><button id="acceptAnswer">Accept Answer</button></div>
    </div>

    <div id="joinControls" style="margin-top:8px;display:none">
      <div>Paste Host Offer here:</div>
      <textarea id="offerIn" placeholder="Paste host offer JSON here"></textarea>
      <div style="margin-top:6px"><button id="createAnswer">Create Answer</button></div>
      <div style="margin-top:6px">Answer (copy → send to host):</div>
      <textarea id="answerOut" readonly placeholder="Answer will appear here..."></textarea>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';

/* -------------------------
   Scene + basic game setup
   ------------------------- */
const container = document.getElementById('container');
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0a0a);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,0.7,0);
const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight); container.appendChild(renderer.domElement);
window.addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); positionWeaponWheelOptions(); weaponWheelState.pointer = {x: innerWidth/2, y: innerHeight/2}; });

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,10,5); scene.add(dir);
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1e1e1e})); ground.rotation.x=-Math.PI/2; scene.add(ground);

/* HUD elements */
const hud = document.getElementById('hud');
const playersDiv = document.getElementById('players');
const nameInput = document.getElementById('nameInput');
const hostIpInput = document.getElementById('hostIp');
const weaponWheelEl = document.getElementById('weaponWheel');

const weaponConfigs = [
  {
    id: 1,
    label: 'Pulse Blaster',
    desc: 'Fast, accurate shot',
    type: 'pulse',
    fireInterval: 0.22,
    firePoseDuration: 0.14,
    sway: {amplitude: 0.012, speed: 3.4, tilt: 0.02},
    appearance: {color: 0xffff66, emissive: 0x332200, emissiveIntensity: 0.55, length: 0.95, thickness: 0.95},
    poses: {
      idle: {
        left: {pos: [-0.32, -0.08, -0.32], rot: [-0.35, 0.25, 1.4]},
        right: {pos: [0.22, -0.12, -0.4], rot: [-0.45, -0.05, -1.45]},
        weapon: {pos: [0, -0.1, -0.5], rot: [-0.08, 0, 0]}
      },
      fire: {
        left: {pos: [-0.3, -0.05, -0.25], rot: [-0.25, 0.4, 1.3]},
        right: {pos: [0.25, -0.1, -0.32], rot: [-0.35, 0.05, -1.35]},
        weapon: {pos: [0, -0.06, -0.58], rot: [-0.15, 0, 0]}
      }
    }
  },
  {
    id: 2,
    label: 'Burst Rocket',
    desc: 'Slow but explosive',
    type: 'rocket',
    fireInterval: 0.95,
    firePoseDuration: 0.28,
    sway: {amplitude: 0.008, speed: 2.6, tilt: 0.018},
    appearance: {color: 0xff5a2f, emissive: 0x401000, emissiveIntensity: 0.65, length: 1.35, thickness: 1.25},
    poses: {
      idle: {
        left: {pos: [-0.28, -0.18, -0.24], rot: [-0.2, 0.1, 1.55]},
        right: {pos: [0.15, -0.25, -0.34], rot: [-0.1, -0.2, -1.45]},
        weapon: {pos: [0, -0.22, -0.58], rot: [0.1, 0.05, 0]}
      },
      fire: {
        left: {pos: [-0.26, -0.16, -0.18], rot: [-0.1, 0.18, 1.4]},
        right: {pos: [0.18, -0.22, -0.26], rot: [0.02, -0.15, -1.35]},
        weapon: {pos: [0, -0.18, -0.72], rot: [0.18, 0.1, 0.05]}
      }
    }
  },
  {
    id: 3,
    label: 'Scatter Cycler',
    desc: 'Wide pellet burst',
    type: 'scatter',
    fireInterval: 0.58,
    firePoseDuration: 0.2,
    sway: {amplitude: 0.014, speed: 3.1, tilt: 0.024},
    appearance: {color: 0xfff1c1, emissive: 0x3a2c15, emissiveIntensity: 0.45, length: 1.05, thickness: 1.1},
    poses: {
      idle: {
        left: {pos: [-0.34, -0.12, -0.3], rot: [-0.55, 0.28, 1.7]},
        right: {pos: [0.2, -0.16, -0.38], rot: [-0.65, -0.12, -1.6]},
        weapon: {pos: [0, -0.14, -0.54], rot: [-0.28, 0, 0]}
      },
      fire: {
        left: {pos: [-0.32, -0.09, -0.24], rot: [-0.42, 0.4, 1.55]},
        right: {pos: [0.22, -0.14, -0.32], rot: [-0.5, 0, -1.45]},
        weapon: {pos: [0, -0.1, -0.64], rot: [-0.32, 0.08, 0]}
      }
    }
  },
  {
    id: 4,
    label: 'Pee Stream',
    desc: 'Rapid droplet spray',
    type: 'pee',
    fireInterval: 0.12,
    firePoseDuration: 0.1,
    sway: {amplitude: 0.018, speed: 4.2, tilt: 0.03},
    appearance: {color: 0xfff57a, emissive: 0x463800, emissiveIntensity: 0.35, length: 1.2, thickness: 0.75},
    stream: {count: 8, spreadYaw: 0.26, spreadPitch: 0.2, speed: 12, size: 0.06, damage: 0.015, ttl: 0.6, hitRadius: 0.28, gravity: 4.2},
    poses: {
      idle: {
        left: {pos: [-0.18, -0.07, -0.44], rot: [-0.35, 0.05, 1.2]},
        right: {pos: [0.08, -0.1, -0.52], rot: [-0.4, -0.04, -1.2]},
        weapon: {pos: [0, -0.06, -0.72], rot: [-0.45, 0, 0]}
      },
      fire: {
        left: {pos: [-0.16, -0.06, -0.4], rot: [-0.2, 0.12, 1.05]},
        right: {pos: [0.1, -0.08, -0.46], rot: [-0.28, 0, -1.05]},
        weapon: {pos: [0, -0.03, -0.82], rot: [-0.52, 0.05, 0]}
      }
    }
  }
];
const weaponConfigById = new Map(weaponConfigs.map(cfg=>[cfg.id, cfg]));

const weaponWheelState = {
  open: false,
  pointer: {x: innerWidth/2, y: innerHeight/2},
  selected: 0,
  options: weaponConfigs.map(cfg=>({id:cfg.id, label:cfg.label, desc:cfg.desc})),
  optionEls: [],
  centerEl: null
};
const shootState = {down:false, cooldown:0};

function buildWeaponWheel(){
  weaponWheelEl.innerHTML = '<div class="weapon-wheel-hint">Move the mouse to highlight a weapon</div>';
  weaponWheelState.optionEls = weaponWheelState.options.map((opt, idx)=>{
    const el = document.createElement('div');
    el.className = 'weapon-wheel-option';
    el.innerHTML = `<div><strong>${opt.label}</strong>${opt.desc ? `<span>${opt.desc}</span>` : ''}</div>`;
    el.dataset.index = idx;
    weaponWheelEl.appendChild(el);
    return el;
  });
  weaponWheelState.centerEl = document.createElement('div');
  weaponWheelState.centerEl.className = 'weapon-wheel-center';
  weaponWheelEl.appendChild(weaponWheelState.centerEl);
  positionWeaponWheelOptions();
  updateWeaponWheelHighlight();
}

function positionWeaponWheelOptions(){
  const center = 130;
  const radius = 90;
  const total = weaponWheelState.options.length;
  weaponWheelState.optionEls.forEach((el, idx)=>{
    const angle = (idx/total) * Math.PI * 2 - Math.PI/2;
    const x = center + Math.cos(angle) * radius;
    const y = center + Math.sin(angle) * radius;
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
  });
}

function updateWeaponWheelHighlight(){
  weaponWheelState.optionEls.forEach((el, idx)=>{
    el.classList.toggle('active', idx === weaponWheelState.selected);
  });
  if(weaponWheelState.centerEl){
    const opt = weaponWheelState.options[weaponWheelState.selected];
    if(opt){
      weaponWheelState.centerEl.innerHTML = `<div>${opt.label}</div>${opt.desc ? `<span>${opt.desc}</span>` : ''}`;
    }
  }
}

function weaponWheelIsMultiplayer(){
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(ch && ch.readyState === 'open') return true;
  }
  return false;
}

function openWeaponWheel(){
  if(weaponWheelState.open) return;
  weaponWheelState.open = true;
  weaponWheelEl.classList.add('open');
  weaponWheelState.pointer = {x: innerWidth/2, y: innerHeight/2};
  const currentIndex = weaponWheelState.options.findIndex(opt=>opt.id === player.weapon);
  if(currentIndex >= 0) weaponWheelState.selected = currentIndex;
  const hint = weaponWheelEl.querySelector('.weapon-wheel-hint');
  if(hint){
    hint.textContent = weaponWheelIsMultiplayer() ? 'Multiplayer: slow motion disabled' : 'Move the mouse to highlight a weapon';
  }
  updateWeaponWheelHighlight();
}

function closeWeaponWheel(){
  if(!weaponWheelState.open) return;
  weaponWheelState.open = false;
  weaponWheelEl.classList.remove('open');
  const chosen = weaponWheelState.options[weaponWheelState.selected];
  if(chosen){
    equipWeapon(chosen.id);
  }
}

function updateWeaponWheelSelection(){
  if(!weaponWheelState.open) return;
  const centerX = innerWidth/2;
  const centerY = innerHeight/2;
  const dx = weaponWheelState.pointer.x - centerX;
  const dy = weaponWheelState.pointer.y - centerY;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if(dist < 20){
    return;
  }
  const total = weaponWheelState.options.length;
  if(total === 0) return;
  let angle = Math.atan2(dy, dx);
  angle = (angle + Math.PI*2) % (Math.PI*2);
  const slice = (Math.PI*2) / total;
  const index = Math.floor((angle + slice/2) / slice) % total;
  if(index !== weaponWheelState.selected){
    weaponWheelState.selected = index;
    updateWeaponWheelHighlight();
  }
}

function equipWeapon(id, options={}){
  const cfg = weaponConfigById.get(id);
  if(!cfg) return;
  if(typeof player !== 'undefined'){
    player.weapon = id;
  }
  const idx = weaponWheelState.options.findIndex(opt=>opt.id===id);
  if(idx>=0){
    weaponWheelState.selected = idx;
    updateWeaponWheelHighlight();
  }
  if(typeof armRig !== 'undefined' && armRig){
    armRig.setWeapon(id, options.immediate);
  }
  shootState.cooldown = 0;
}

function createArmRig(){
  const group = new THREE.Group();
  group.position.set(0, -0.12, 0.08);
  group.rotation.set(0, 0, 0);
  const baseGroupPosition = group.position.clone();

  const skinMaterial = new THREE.MeshStandardMaterial({color:0xffcaa6, roughness:0.55, metalness:0.1});
  const armGeometry = new THREE.CylinderGeometry(0.09, 0.12, 0.6, 14);
  armGeometry.translate(0, -0.3, 0);

  const left = new THREE.Group();
  const leftMesh = new THREE.Mesh(armGeometry, skinMaterial);
  left.add(leftMesh);

  const right = new THREE.Group();
  const rightMesh = new THREE.Mesh(armGeometry, skinMaterial.clone());
  right.add(rightMesh);

  const weapon = new THREE.Group();
  const weaponGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1, 18);
  weaponGeometry.translate(0, -0.5, 0);
  const weaponMaterial = new THREE.MeshStandardMaterial({color:0xffff66, roughness:0.3, metalness:0.45, emissive:0x222200, emissiveIntensity:0.6});
  const weaponMesh = new THREE.Mesh(weaponGeometry, weaponMaterial);
  weaponMesh.rotation.x = Math.PI/2;
  weapon.add(weaponMesh);

  group.add(left);
  group.add(right);
  group.add(weapon);

  camera.add(group);

  const leftTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const rightTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const weaponTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const tempEuler = new THREE.Euler();

  function setTargetsForPose(pose){
    const safePose = pose || (weaponConfigs[0]?.poses.idle);
    if(safePose?.left){
      leftTarget.pos.set(safePose.left.pos[0], safePose.left.pos[1], safePose.left.pos[2]);
      tempEuler.set(safePose.left.rot[0], safePose.left.rot[1], safePose.left.rot[2], 'XYZ');
      leftTarget.quat.setFromEuler(tempEuler);
    }
    if(safePose?.right){
      rightTarget.pos.set(safePose.right.pos[0], safePose.right.pos[1], safePose.right.pos[2]);
      tempEuler.set(safePose.right.rot[0], safePose.right.rot[1], safePose.right.rot[2], 'XYZ');
      rightTarget.quat.setFromEuler(tempEuler);
    }
    if(safePose?.weapon){
      weaponTarget.pos.set(safePose.weapon.pos[0], safePose.weapon.pos[1], safePose.weapon.pos[2]);
      tempEuler.set(safePose.weapon.rot[0], safePose.weapon.rot[1], safePose.weapon.rot[2], 'XYZ');
      weaponTarget.quat.setFromEuler(tempEuler);
    }
  }

  const rig = {
    group,
    left,
    right,
    weapon,
    weaponMesh,
    weaponMaterial,
    weaponId: 1,
    fireTimer: 0,
    fireTimerTotal: 0,
    time: 0,
    setWeapon(id, immediate){
      if(!weaponConfigById.has(id)) return;
      this.weaponId = id;
      this.time = 0;
      this.fireTimer = 0;
      this.fireTimerTotal = 0;
      const cfg = weaponConfigById.get(id) || weaponConfigs[0];
      const appearance = cfg.appearance || weaponConfigs[0].appearance;
      if(appearance){
        if(appearance.color !== undefined) this.weaponMaterial.color.setHex(appearance.color);
        if(appearance.emissive !== undefined) this.weaponMaterial.emissive.setHex(appearance.emissive);
        if(appearance.emissiveIntensity !== undefined) this.weaponMaterial.emissiveIntensity = appearance.emissiveIntensity;
        if(appearance.thickness !== undefined){
          weaponMesh.scale.x = appearance.thickness;
          weaponMesh.scale.z = appearance.thickness;
        }
        if(appearance.length !== undefined){
          weaponMesh.scale.y = appearance.length;
        }
      }
      this.applyPose('idle', immediate);
    },
    applyPose(poseName, immediate){
      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      const pose = (cfg.poses && cfg.poses[poseName]) || (cfg.poses && cfg.poses.idle) || weaponConfigs[0].poses.idle;
      setTargetsForPose(pose);
      if(immediate){
        left.position.copy(leftTarget.pos);
        left.quaternion.copy(leftTarget.quat);
        right.position.copy(rightTarget.pos);
        right.quaternion.copy(rightTarget.quat);
        weapon.position.copy(weaponTarget.pos);
        weapon.quaternion.copy(weaponTarget.quat);
      }
    },
    triggerFire(){
      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      this.fireTimer = cfg?.firePoseDuration ?? 0.15;
      this.fireTimerTotal = this.fireTimer;
      this.applyPose('fire');
    },
    update(dt){
      if(typeof player !== 'undefined'){
        group.visible = !player.thirdPerson;
      }
      this.time += dt;
      const lerpAlpha = Math.max(0, Math.min(1, dt * 12));
      left.position.lerp(leftTarget.pos, lerpAlpha);
      left.quaternion.slerp(leftTarget.quat, lerpAlpha);
      right.position.lerp(rightTarget.pos, lerpAlpha);
      right.quaternion.slerp(rightTarget.quat, lerpAlpha);
      weapon.position.lerp(weaponTarget.pos, lerpAlpha);
      weapon.quaternion.slerp(weaponTarget.quat, lerpAlpha);

      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      const swayCfg = cfg?.sway || {};
      const swaySpeed = swayCfg.speed ?? 3.5;
      const swayAmount = swayCfg.amplitude ?? 0.01;
      const tiltAmount = swayCfg.tilt ?? 0.02;
      const fireInfluence = this.fireTimer > 0 && this.fireTimerTotal > 0 ? Math.max(0.3, this.fireTimer / this.fireTimerTotal) : 1;
      group.position.set(baseGroupPosition.x, baseGroupPosition.y + Math.sin(this.time * swaySpeed) * swayAmount * fireInfluence, baseGroupPosition.z);
      group.rotation.set(0, 0, Math.cos(this.time * swaySpeed * 0.5) * tiltAmount * fireInfluence);
      if(this.fireTimer <= 0){
        const bob = Math.sin(this.time * swaySpeed * 1.4) * swayAmount * 0.6;
        left.position.y += bob;
        right.position.y += bob;
        weapon.position.y += bob * 0.6;
      }

      if(this.fireTimer > 0){
        this.fireTimer -= dt;
        if(this.fireTimer <= 0){
          this.applyPose('idle');
        }
      }
    }
  };

  rig.applyPose('idle', true);
  return rig;
}

buildWeaponWheel();

/* Player */
const player = {
  pos: new THREE.Vector3(0,0.5,0),
  velocity: new THREE.Vector3(),
  speed: 4,
  yaw: 0,
  pitch: 0,
  hp: 1,
  alive: true,
  thirdPerson: false,
  weapon: 1,
  jumpSpeed: 5,
  canJump: true,
  id: Math.random().toString(36).slice(2,9),
  name: 'me'
};

const alexMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x6699ff})); scene.add(alexMesh);
const armRig = createArmRig();
equipWeapon(player.weapon, {immediate:true});

/* Controls */
let keys = {};
window.addEventListener('keydown', e=>{
  keys[e.code]=true;
  if(e.code==='KeyY') player.thirdPerson = !player.thirdPerson;
  if(e.code.startsWith('Digit')){
    const digit = parseInt(e.code.slice(5), 10);
    if(!Number.isNaN(digit)){
      equipWeapon(digit);
    }
  }
  if(e.code==='KeyQ' && !e.repeat){ openWeaponWheel(); }
});
window.addEventListener('keyup', e=>{
  keys[e.code]=false;
  if(e.code==='KeyQ'){ closeWeaponWheel(); }
});
window.addEventListener('keydown', e=>{ if(e.code==='Escape') document.exitPointerLock?.(); });
window.addEventListener('keydown', e=>{ if(e.code==='Space' && player.canJump){ player.velocity.y = player.jumpSpeed; player.canJump=false; }});
let isLocked = false;
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
document.addEventListener('pointerlockchange', ()=>{
  isLocked = (document.pointerLockElement === renderer.domElement);
  if(!isLocked){
    shootState.down = false;
  }
});
document.addEventListener('mousemove', e=>{
  if(weaponWheelState.open){
    if(isLocked){
      weaponWheelState.pointer.x = Math.max(0, Math.min(innerWidth, weaponWheelState.pointer.x + e.movementX));
      weaponWheelState.pointer.y = Math.max(0, Math.min(innerHeight, weaponWheelState.pointer.y + e.movementY));
    } else {
      weaponWheelState.pointer.x = e.clientX;
      weaponWheelState.pointer.y = e.clientY;
    }
    updateWeaponWheelSelection();
    return;
  }
  if(!isLocked) return;
  player.yaw -= e.movementX*0.002;
  player.pitch -= e.movementY*0.002;
  player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));
});

/* Enemies & bullets */
const ooferTemplate = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xff5555}));
const enemies=[]; const enemyGroup = new THREE.Group(); scene.add(enemyGroup);
function spawnEnemy(){ const clone = ooferTemplate.clone(); const angle=Math.random()*Math.PI*2; const dist=10+Math.random()*10; clone.position.set(Math.cos(angle)*dist,0.5,Math.sin(angle)*dist); clone.userData={hp:2}; enemyGroup.add(clone); enemies.push(clone); updateHUD(); }

const bullets=[];

function createShotsForWeapon(cfg, origin, dir){
  const forward = dir.clone().normalize();
  const thirdPerson = player.thirdPerson;
  const offset = thirdPerson ? 0.9 : 0.35;
  const baseOrigin = origin.clone().add(forward.clone().multiplyScalar(offset));
  if(cfg.type === 'pulse'){
    return [{
      type:'pulse',
      pos: baseOrigin.toArray(),
      dir: forward.toArray(),
      speed: 14,
      size: 0.1,
      color: cfg.appearance?.color ?? 0xffff66,
      damage: 1,
      ttl: 2.2,
      hitRadius: 0.45,
      pierce: 0
    }];
  }
  if(cfg.type === 'rocket'){
    return [{
      type:'rocket',
      pos: baseOrigin.toArray(),
      dir: forward.toArray(),
      speed: 9,
      size: 0.32,
      color: cfg.appearance?.color ?? 0xff5a2f,
      damage: 2,
      ttl: 4,
      hitRadius: 0.6,
      explode: 1.8,
      pierce: 0
    }];
  }
  if(cfg.type === 'scatter'){
    const shots = [];
    const pelletCount = 6;
    const euler = new THREE.Euler();
    const quat = new THREE.Quaternion();
    for(let i=0;i<pelletCount;i++){
      const spreadYaw = (Math.random()-0.5) * 0.3;
      const spreadPitch = (Math.random()-0.5) * 0.22;
      euler.set(spreadPitch, spreadYaw, 0, 'YXZ');
      quat.setFromEuler(euler);
      const pelletDir = forward.clone().applyQuaternion(quat).normalize();
      const pelletOrigin = origin.clone().add(pelletDir.clone().multiplyScalar(thirdPerson ? 0.9 : 0.32));
      shots.push({
        type:'pellet',
        pos: pelletOrigin.toArray(),
        dir: pelletDir.toArray(),
        speed: 11,
        size: 0.08,
        color: cfg.appearance?.color ?? 0xfff1c1,
        damage: 1,
        ttl: 0.55,
        hitRadius: 0.35,
        pierce: 0
      });
    }
    return shots;
  }
  if(cfg.type === 'pee'){
    const stream = cfg.stream || {};
    const shots = [];
    const dropletCount = stream.count || 8;
    const euler = new THREE.Euler();
    const quat = new THREE.Quaternion();
    for(let i=0;i<dropletCount;i++){
      const spreadYaw = (Math.random()-0.5) * (stream.spreadYaw || 0.22);
      const spreadPitch = (Math.random()-0.5) * (stream.spreadPitch || 0.18);
      euler.set(spreadPitch, spreadYaw, 0, 'YXZ');
      quat.setFromEuler(euler);
      const dropletDir = forward.clone().applyQuaternion(quat).normalize();
      const dropletOrigin = origin.clone()
        .add(dropletDir.clone().multiplyScalar(thirdPerson ? 0.9 : 0.36))
        .add(new THREE.Vector3((Math.random()-0.5)*0.06, (Math.random()-0.5)*0.04, (Math.random()-0.5)*0.06));
      shots.push({
        type:'pee',
        pos: dropletOrigin.toArray(),
        dir: dropletDir.toArray(),
        speed: stream.speed || 12,
        size: stream.size || 0.06,
        color: cfg.appearance?.color ?? 0xfff57a,
        damage: stream.damage || 0.015,
        ttl: stream.ttl || 0.6,
        hitRadius: stream.hitRadius || 0.28,
        gravity: stream.gravity || 4.2,
        pierce: 0
      });
    }
    return shots;
  }
  const beamOrigin = origin.clone().add(forward.clone().multiplyScalar(thirdPerson ? 1.0 : 0.45));
  return [{
    type:'beam',
    pos: beamOrigin.toArray(),
    dir: forward.toArray(),
    color: cfg.appearance?.color ?? 0x5ad4ff,
    duration: 0.18,
    length: 12,
    width: 0.14,
    damage: 2,
    hitRadius: 0.75
  }];
}

function spawnBulletFromShot(shot, ownerId){
  const dir = new THREE.Vector3(...(shot.dir || [0,0,-1])).normalize();
  if(shot.type === 'beam'){
    const length = shot.length ?? 10;
    const width = shot.width ?? 0.12;
    const geometry = new THREE.CylinderGeometry(width, width, length, 16, 1, true);
    const material = new THREE.MeshStandardMaterial({color: shot.color ?? 0x5ad4ff, emissive: new THREE.Color(shot.color ?? 0x5ad4ff).multiplyScalar(0.35), transparent:true, opacity:0.7, roughness:0.25, metalness:0.1});
    const mesh = new THREE.Mesh(geometry, material);
    const origin = new THREE.Vector3(...shot.pos);
    const midpoint = origin.clone().add(dir.clone().multiplyScalar(length/2));
    mesh.position.copy(midpoint);
    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
    mesh.userData = {
      type:'beam',
      owner: ownerId,
      origin,
      dir,
      length,
      damage: shot.damage ?? 2,
      life: shot.duration ?? 0.15,
      duration: shot.duration ?? 0.15,
      hitRadius: shot.hitRadius ?? 0.7,
      hitIds: new Set()
    };
    scene.add(mesh); bullets.push(mesh);
    return mesh;
  }
  const radius = shot.size ?? 0.1;
  const geometry = new THREE.SphereGeometry(radius, 12, 12);
  const baseColor = shot.color ?? 0xffffff;
  const emissiveColor = new THREE.Color(baseColor).multiplyScalar(shot.type === 'pee' ? 0.08 : 0.3);
  const materialConfig = {
    color: baseColor,
    emissive: emissiveColor,
    roughness: shot.type === 'pee' ? 0.68 : 0.35,
    metalness: shot.type === 'pee' ? 0.04 : 0.15
  };
  if(shot.type === 'pee'){
    materialConfig.transparent = true;
    materialConfig.opacity = 0.78;
    materialConfig.depthWrite = false;
  }
  const material = new THREE.MeshStandardMaterial(materialConfig);
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(shot.pos[0], shot.pos[1], shot.pos[2]);
  const velocity = dir.clone().multiplyScalar(shot.speed ?? 0);
  mesh.userData = {
    type: shot.type || 'pulse',
    owner: ownerId,
    dir,
    speed: shot.speed ?? 10,
    velocity,
    damage: shot.damage ?? 1,
    life: shot.ttl ?? 2,
    maxLife: shot.ttl ?? 2,
    hitRadius: shot.hitRadius ?? radius*2,
    explode: shot.explode ?? 0,
    pierce: shot.pierce ?? 0,
    gravity: shot.gravity ?? 0
  };
  scene.add(mesh); bullets.push(mesh);
  return mesh;
}

function cleanupBullet(index){
  const mesh = bullets[index];
  if(!mesh) return;
  scene.remove(mesh);
  bullets.splice(index,1);
}

function damageEnemyAtIndex(idx, amount){
  const enemy = enemies[idx];
  if(!enemy) return false;
  enemy.userData.hp -= amount;
  if(enemy.userData.hp <= 0){
    enemyGroup.remove(enemy);
    enemies.splice(idx,1);
    score += 10;
    updateHUD();
    return true;
  }
  return false;
}

function applyExplosion(position, radius, damage){
  for(let j=enemies.length-1;j>=0;j--){
    const enemy = enemies[j];
    if(!enemy) continue;
    if(enemy.position.distanceTo(position) <= radius){
      damageEnemyAtIndex(j, damage);
    }
  }
}

function applyBeamDamage(beam){
  const data = beam.userData;
  if(!data || !data.origin || !data.dir) return;
  const origin = data.origin;
  const dir = data.dir;
  if(!data.hitIds) data.hitIds = new Set();
  for(let j=enemies.length-1;j>=0;j--){
    const enemy = enemies[j];
    if(!enemy || data.hitIds.has(enemy.uuid)) continue;
    const toEnemy = new THREE.Vector3().subVectors(enemy.position, origin);
    const projection = toEnemy.dot(dir);
    if(projection < 0 || projection > data.length) continue;
    const perpendicularSq = toEnemy.lengthSq() - projection*projection;
    const radiusSq = (data.hitRadius ?? 0.7) ** 2;
    if(perpendicularSq > radiusSq) continue;
    data.hitIds.add(enemy.uuid);
    damageEnemyAtIndex(j, data.damage ?? 2);
  }
}

function shoot(){
  if(!player.alive || weaponWheelState.open) return false;
  const cfg = weaponConfigById.get(player.weapon) || weaponConfigs[0];
  const interval = cfg.fireInterval ?? 0.3;
  if(shootState.cooldown > 0) return false;
  shootState.cooldown = interval;
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  const origin = player.thirdPerson ? player.pos.clone().add(new THREE.Vector3(0,0.7,0)) : camera.getWorldPosition(new THREE.Vector3());
  const shots = createShotsForWeapon(cfg, origin, dir);
  const serialized = [];
  shots.forEach(shot=>{
    spawnBulletFromShot(shot, player.id);
    serialized.push({...shot});
  });
  const weaponId = cfg?.id ?? player.weapon;
  sendData({t:'shoot', w: weaponId, shots: serialized});
  if(armRig) armRig.triggerFire();
  return true;
}

window.addEventListener('mousedown', e=>{
  if(e.button===0){
    shootState.down = true;
    shoot();
  }
});
window.addEventListener('mouseup', e=>{ if(e.button===0) shootState.down = false; });
window.addEventListener('blur', ()=>{ shootState.down = false; });

/* HUD update */
let score = 0;
function updateHUD(){ hud.textContent = `Score: ${score} | Enemies: ${enemies.length} | HP: ${player.hp} | Host IP: ${hostIpInput.value || 'N/A'}`; }
function updatePlayers(){ let txt = `Players: ${nameInput.value || player.name || 'me'}`; for(const id in remotePlayers){ const r = remotePlayers[id]; txt += '\n' + (r.name || id); } playersDiv.textContent = txt; }

/* Game Over / Retry */
const gameOverDiv = document.getElementById('gameOver');
document.getElementById('retry').addEventListener('click', ()=>{
  // reset player
  player.hp = 1; player.alive = true; player.pos.set(0,0.5,0); player.velocity.set(0,0,0);
  // clear bullets & enemies and reset spawn
  bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
  enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
  SPAWN_INTERVAL = 2500; spawnAccumulator = 0; score = 0;
  // broadcast reset to peers
  sendData({t:'reset'});
  gameOverDiv.style.display = 'none';
  updateHUD(); updatePlayers();
});

/* --------------------------
   Networking: manual SDP P2P
   -------------------------- */
const btnHost = document.getElementById('btnHost');
const btnJoin = document.getElementById('btnJoin');
const btnHide = document.getElementById('btnHide');
const hostControls = document.getElementById('hostControls');
const joinControls = document.getElementById('joinControls');
const createOfferBtn = document.getElementById('createOffer');
const acceptAnswerBtn = document.getElementById('acceptAnswer');
const createAnswerBtn = document.getElementById('createAnswer');
const offerOut = document.getElementById('offerOut');
const answerIn = document.getElementById('answerIn');
const offerIn = document.getElementById('offerIn');
const answerOut = document.getElementById('answerOut');

let peerConnections = {}; // peerId -> RTCPeerConnection
let dataChannels = {};    // peerId -> DataChannel
let remotePlayers = {};   // peerId -> state
let nextPeerIndex = 1;
let menuOpen = false;
let isHost = false;

/* pause when menu open */
function setMenuOpen(open){
  menuOpen = open;
}

/* Hide/Show UI behavior */
btnHide.onclick = ()=>{
  const networkDiv = document.getElementById('network');
  if(networkDiv.style.height === '24px'){
    networkDiv.style.height = '';
    btnHide.textContent = 'Hide UI';
    setMenuOpen(true);
  } else {
    // collapse host/join controls only (keep top row)
    hostControls.style.display = 'none';
    joinControls.style.display = 'none';
    setMenuOpen(false);
    btnHide.textContent = 'Show UI';
  }
};

/* Host / Join mode toggles */
btnHost.onclick = ()=>{
  hostControls.style.display = 'block';
  joinControls.style.display = 'none';
  btnHost.disabled = true; btnJoin.disabled = true;
  setMenuOpen(true);
  isHost = true;
  player.name = nameInput.value || 'Host';
  updatePlayers();
};
btnJoin.onclick = ()=>{
  joinControls.style.display = 'block';
  hostControls.style.display = 'none';
  btnHost.disabled = true; btnJoin.disabled = true;
  setMenuOpen(true);
  isHost = false;
  player.name = nameInput.value || 'Player';
  updatePlayers();
};

/* helper to make a new RTCPeerConnection */
function makePeer(peerId){
  const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  pc.onicecandidate = ev=>{
    // we rely on SDP after a small timeout; ICE candidates may still trickle but manual flow often works on LAN/Hamachi
  };
  pc.ondatachannel = ev=>{
    setupDataChannel(peerId, ev.channel);
  };
  return pc;
}

/* set up datachannel handlers */
function setupDataChannel(peerId, ch){
  dataChannels[peerId] = ch;
  ch.onopen = ()=>{ console.log('DataChannel open', peerId); };
  ch.onmessage = ev=>{
    try{
      const msg = JSON.parse(ev.data);
      handleRemoteMessage(peerId, msg);
    }catch(e){}
  };
  ch.onclose = ()=>{
    console.log('DC closed', peerId);
    delete dataChannels[peerId];
    delete peerConnections[peerId];
    removeRemote(peerId);
    if(isHost){
      broadcast({t:'peer_left', from:peerId}, peerId);
    }
  };
}

/* create offer (host creates one offer per joiner) */
createOfferBtn.onclick = async ()=>{
  const peerId = 'peer'+(nextPeerIndex++);
  const pc = makePeer(peerId);
  peerConnections[peerId] = pc;
  const ch = pc.createDataChannel('game');
  setupDataChannel(peerId, ch);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  setTimeout(()=>{ offerOut.value = JSON.stringify(pc.localDescription); alert('Offer created. Copy the Offer text and send to the joiner. After joiner sends their Answer paste it into "Paste Answer" and click Accept Answer.'); }, 700);
};

/* accept answer (host pastes joiner's answer for last created peer) */
acceptAnswerBtn.onclick = async ()=>{
  const txt = answerIn.value.trim();
  if(!txt){ alert('Paste joiner Answer first'); return; }
  const ids = Object.keys(peerConnections);
  if(ids.length===0){ alert('No pending offer — create Offer first'); return; }
  const lastId = ids[ids.length-1];
  const pc = peerConnections[lastId];
  try{
    const remoteDesc = JSON.parse(txt);
    await pc.setRemoteDescription(remoteDesc);
    answerIn.value = '';
    alert('Answer accepted. Connection should establish shortly.');
  }catch(err){ alert('Could not set remote description: '+err); }
};

/* joiner creates answer after pasting host offer */
createAnswerBtn.onclick = async ()=>{
  const txt = offerIn.value.trim();
  if(!txt){ alert('Paste host Offer first'); return; }
  try{
    const remoteDesc = JSON.parse(txt);
    const pc = makePeer('host');
    peerConnections['host'] = pc;
    pc.ondatachannel = ev=> setupDataChannel('host', ev.channel);
    await pc.setRemoteDescription(remoteDesc);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    setTimeout(()=>{ answerOut.value = JSON.stringify(pc.localDescription); alert('Answer created. Copy Answer text and send to host.'); }, 700);
  }catch(err){ alert('Invalid Offer or error: '+err); }
};

/* broadcast object to all open DCs */
function sendData(obj, skipId){
  const str = JSON.stringify(obj);
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(id === skipId) continue;
    if(ch && ch.readyState === 'open'){
      try{ ch.send(str); }catch(e){}
    }
  }
}

function broadcast(obj, skipId){
  sendData(obj, skipId);
}

function removeRemote(remoteId){
  const rp = remotePlayers[remoteId];
  if(!rp) return;
  if(rp.mesh){ scene.remove(rp.mesh); }
  delete remotePlayers[remoteId];
  updatePlayers();
}

/* handle incoming messages from peers */
function handleRemoteMessage(peerId, msg){
  const sourceId = (peerId === 'host' && msg.from) ? msg.from : peerId;

  if(isHost && peerId !== 'host'){
    const forward = {...msg, from: peerId};
    broadcast(forward, peerId);
  }

  if(msg.t === 'peer_left'){
    removeRemote(sourceId);
    return;
  }

  if(msg.t === 'state'){
    if(!remotePlayers[sourceId]) remotePlayers[sourceId] = {id:sourceId, pos:new THREE.Vector3(), yaw:0, pitch:0, name:msg.name||sourceId};
    const rp = remotePlayers[sourceId];
    rp.pos.set(msg.p[0], msg.p[1], msg.p[2]);
    rp.yaw = msg.y; rp.pitch = msg.r; rp.hp = msg.hp; rp.name = msg.name || sourceId;
    updatePlayers();
  }
  if(msg.t === 'shoot'){
    if(Array.isArray(msg.shots)){
      msg.shots.forEach(shot=> spawnBulletFromShot(shot, sourceId));
    } else if(msg.p && msg.d){
      let fallbackType = 'pulse';
      if(msg.w === 2) fallbackType = 'rocket';
      else if(msg.w === 3) fallbackType = 'pellet';
      else if(msg.w === 4) fallbackType = 'pee';
      const fallback = {
        type: fallbackType,
        pos: msg.p,
        dir: msg.d,
        speed: msg.w === 2 ? 8 : msg.w === 4 ? 12 : 12,
        size: msg.w === 2 ? 0.3 : msg.w === 4 ? 0.06 : 0.1,
        color: msg.w === 2 ? 0xffaa00 : msg.w === 4 ? 0xfff57a : 0xffff00,
        damage: msg.w === 2 ? 2 : msg.w === 4 ? 0.12 : 1,
        ttl: msg.w === 2 ? 4 : msg.w === 4 ? 0.6 : 2,
        hitRadius: msg.w === 2 ? 0.6 : msg.w === 4 ? 0.28 : 0.45,
        explode: msg.w === 2 ? 1.8 : 0,
        gravity: msg.w === 4 ? 4.2 : 0
      };
      spawnBulletFromShot(fallback, sourceId);
    }
  }
  if(msg.t === 'reset'){
    bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
    enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
    SPAWN_INTERVAL = 2500; spawnAccumulator = 0; score = 0; updateHUD();
  }
}

/* periodic state broadcast */
setInterval(()=>{
  const payload = { t:'state', id:player.id, p:[player.pos.x, player.pos.y, player.pos.z], y:player.yaw, r:player.pitch, hp:player.hp, name: nameInput.value || player.name };
  sendData(payload);
}, 80);

/* -------------------------
   Game logic & physics
   ------------------------- */
/* Movement vectors: CORRECT so W is forward */
function updatePlayer(dt){
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));
  let move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyA']) move.sub(right);
  if(keys['KeyD']) move.add(right);
  if(move.lengthSq()>0) move.normalize();
  player.velocity.x = move.x * player.speed;
  player.velocity.z = move.z * player.speed;

  // gravity & integrate
  player.velocity.y -= 9.8 * dt;
  player.pos.add(player.velocity.clone().multiplyScalar(dt));
  if(player.pos.y <= 0.5){ player.pos.y = 0.5; player.velocity.y = 0; player.canJump = true; }

  // camera
  if(player.thirdPerson){
    alexMesh.visible = true;
    const distance = 5;
    const phi = Math.PI/2 + player.pitch;
    const theta = player.yaw;
    const camX = player.pos.x + distance * Math.sin(phi) * Math.sin(theta);
    const camY = player.pos.y + distance * Math.cos(phi);
    const camZ = player.pos.z + distance * Math.sin(phi) * Math.cos(theta);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(player.pos.x, player.pos.y + 0.7, player.pos.z);
  } else {
    alexMesh.visible = false;
    camera.position.copy(player.pos.clone().add(new THREE.Vector3(0,0.7,0)));
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
  }

  alexMesh.position.copy(player.pos);
  alexMesh.rotation.y = player.yaw;
}

/* bullets & enemies update */
function updateBullets(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    const data = b.userData || {};
    if(typeof data.life === 'number'){
      data.life -= dt;
    } else {
      data.life = 3;
    }

    if(data.type === 'beam'){
      if(b.material && typeof b.material.opacity === 'number' && data.duration){
        b.material.opacity = Math.max(0, (data.life / data.duration) * 0.7);
      }
      applyBeamDamage(b);
      if(data.life <= 0){
        cleanupBullet(i);
      }
      continue;
    }

    if(data.velocity){
      if(data.gravity){
        data.velocity.y -= data.gravity * dt;
      }
      b.position.addScaledVector(data.velocity, dt);
    } else if(data.dir){
      b.position.addScaledVector(data.dir, (data.speed ?? 0) * dt);
    }

    if(data.type === 'pee' && b.material && typeof b.material.opacity === 'number' && data.maxLife){
      const lifeRatio = Math.max(0, Math.min(1, data.life / data.maxLife));
      b.material.opacity = 0.25 + lifeRatio * 0.55;
    }

    let removed = false;
    for(let j=enemies.length-1;j>=0;j--){
      const enemy = enemies[j];
      if(!enemy) continue;
      const dist = b.position.distanceTo(enemy.position);
      if(dist <= (data.hitRadius ?? 0.45)){
        if(data.type === 'rocket' && data.explode){
          applyExplosion(b.position, data.explode, data.damage ?? 2);
        } else {
          damageEnemyAtIndex(j, data.damage ?? 1);
        }
        if(data.pierce && data.pierce > 0){
          data.pierce -= 1;
          continue;
        }
        removed = true;
        break;
      }
    }

    if(removed){
      cleanupBullet(i);
      continue;
    }

    if(data.life <= 0){
      if(data.type === 'rocket' && data.explode){
        applyExplosion(b.position, data.explode, data.damage ?? 2);
      }
      cleanupBullet(i);
    }
  }
}
function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    const dir = new THREE.Vector3().subVectors(player.pos, e.position); dir.y = 0;
    const dist = dir.length(); dir.normalize();
    e.position.add(dir.multiplyScalar(1.2 * dt));
    if(dist < 1.0 && player.alive){ player.hp = 0; player.alive = false; updateHUD(); gameOverDiv.style.display = 'block'; }
  }
}

/* render remote players */
function renderRemotes(){
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(!rp.mesh){
      rp.mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xffaa66}));
      scene.add(rp.mesh);
    }
    if(rp.pos) rp.mesh.position.copy(rp.pos);
    rp.mesh.rotation.y = rp.yaw || 0;
  }
}

/* spawn timer */
let SPAWN_INTERVAL = 2500;
let spawnAccumulator = 0;

/* pause logic controlled by menuOpen */
function gameTick(now){
  const rawDt = Math.min(0.05, (now - (gameTick.last||now))/1000);
  gameTick.last = now;
  const slowMoActive = weaponWheelState.open && !weaponWheelIsMultiplayer();
  const timeScale = slowMoActive ? 0.25 : 1;
  const dt = rawDt * timeScale;
  shootState.cooldown = Math.max(0, shootState.cooldown - rawDt);

  if(!menuOpen){
    spawnAccumulator += dt;
    while(spawnAccumulator * 1000 >= SPAWN_INTERVAL){
      spawnEnemy();
      spawnAccumulator -= SPAWN_INTERVAL / 1000;
      if(SPAWN_INTERVAL > 500) SPAWN_INTERVAL *= 0.995;
    }
    if(player.alive){
      updatePlayer(dt);
      updateBullets(dt);
      updateEnemies(dt);
      if(shootState.down){
        shoot();
      }
    }
    renderRemotes();
  }

  if(armRig){
    armRig.update(dt);
  }

  updateHUD();
  updatePlayers();
  renderer.render(scene, camera);
  requestAnimationFrame(gameTick);
}
requestAnimationFrame(gameTick);

/* Expose debugging objects */
window._peers = peerConnections;
window._dcs = dataChannels;
window._remote = remotePlayers;
window._send = sendData;

window.addEventListener('beforeunload', ()=>{
  try{ sendData({t:'peer_left', from: isHost ? 'host' : 'self'}); }catch(e){}
});

</script>
</body>
</html>
