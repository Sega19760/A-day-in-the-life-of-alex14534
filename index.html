<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Shooter â€” LAN P2P (manual SDP)</title>
<style>
  :root{--bg:#000;--ui-bg:rgba(0,0,0,0.35);--btn:#222}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #container{width:100%;height:100%;position:relative;overflow:hidden}
  canvas{display:block}
  .hud{position:absolute;left:8px;top:8px;z-index:60;background:var(--ui-bg);padding:8px 10px;border-radius:10px;max-width:calc(100% - 16px);font-size:14px;line-height:1.35}
  .players{position:absolute;left:8px;top:96px;z-index:60;background:var(--ui-bg);padding:8px 10px;border-radius:10px;max-width:calc(100% - 16px);white-space:pre-line;font-size:13px;line-height:1.35}
  .instructions{position:absolute;right:8px;top:8px;z-index:60;background:var(--ui-bg);padding:10px 12px;border-radius:12px;max-width:300px;font-size:13px;line-height:1.4}
  .crosshair{position:absolute;left:50%;top:50%;width:12px;height:12px;margin:-6px 0 0 -6px;pointer-events:none;z-index:40}
  .crosshair:before,.crosshair:after{content:'';position:absolute;background:#fff}
  .crosshair:before{left:50%;top:0;transform:translateX(-50%);width:2px;height:12px}
  .crosshair:after{top:50%;left:0;transform:translateY(-50%);height:2px;width:12px}
  .weapon-wheel{position:absolute;left:50%;top:50%;width:260px;height:260px;margin:-130px 0 0 -130px;border-radius:50%;background:rgba(0,0,0,0.6);border:2px solid rgba(255,255,255,0.2);display:none;z-index:70;pointer-events:none;box-shadow:0 0 30px rgba(0,0,0,0.5)}
  .weapon-wheel.open{display:block}
  .weapon-wheel::after{content:'';position:absolute;left:50%;top:50%;width:80px;height:80px;margin:-40px 0 0 -40px;border-radius:50%;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.25)}
  .weapon-wheel-option{position:absolute;width:90px;height:90px;border-radius:14px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;text-align:center;font-size:13px;line-height:1.3;padding:8px;transform:translate(-50%,-50%);transition:background 0.15s,border 0.15s,transform 0.15s}
  .weapon-wheel-option strong{display:block;font-size:14px;margin-bottom:4px}
  .weapon-wheel-option span{display:block;font-size:12px;opacity:0.75}
  .weapon-wheel-option.active{background:rgba(255,255,255,0.25);border-color:rgba(255,255,255,0.55);transform:translate(-50%,-50%) scale(1.08)}
  .weapon-wheel-center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;font-size:16px;line-height:1.4}
  .weapon-wheel-center span{display:block;font-size:12px;opacity:0.7}
  .weapon-wheel-hint{position:absolute;left:50%;bottom:-34px;transform:translateX(-50%);font-size:12px;color:#ddd;text-align:center;opacity:0.9}
  #gameOver{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:90;padding:16px;background:rgba(0,0,0,0.9);display:none;text-align:center;border-radius:10px}
  #network{position:absolute;left:8px;bottom:8px;z-index:60;background:var(--ui-bg);padding:8px;border-radius:8px;max-width:calc(100% - 16px)}
  .lobby-browser{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:120;background:rgba(7,7,7,0.92);border-radius:16px;padding:18px;display:none;min-width:520px;min-height:320px;box-shadow:0 18px 50px rgba(0,0,0,0.55)}
  .lobby-browser.open{display:flex;flex-direction:column;gap:12px}
  .lobby-browser-header{display:flex;justify-content:space-between;align-items:center;font-size:16px;font-weight:600}
  .lobby-browser-body{display:flex;gap:12px;flex:1;min-height:220px}
  .lobby-list{flex:1;display:flex;flex-direction:column;gap:6px;overflow-y:auto;padding-right:4px}
  .lobby-entry{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-radius:10px;background:rgba(255,255,255,0.06);cursor:pointer;border:1px solid transparent;transition:background 0.15s,border 0.15s}
  .lobby-entry:hover{background:rgba(255,255,255,0.12)}
  .lobby-entry.active{background:rgba(255,255,255,0.18);border-color:rgba(255,255,255,0.35)}
  .lobby-detail{flex:1.1;display:flex;flex-direction:column;gap:10px;padding:12px;border-radius:12px;background:rgba(255,255,255,0.04)}
  .lobby-detail h3{margin:0;font-size:18px}
  .lobby-player-list{flex:1;overflow-y:auto;background:rgba(0,0,0,0.25);border-radius:10px;padding:8px;font-size:13px}
  .lobby-player-list.empty{display:flex;align-items:center;justify-content:center;opacity:0.7}
  .lobby-actions{display:flex;gap:8px;justify-content:flex-end}
  .lobby-stage{position:absolute;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;z-index:190;background:rgba(4,8,14,0.78);backdrop-filter:blur(6px)}
  .lobby-stage.open{display:flex}
  .lobby-stage-panel{background:rgba(12,18,32,0.95);border-radius:22px;padding:24px 28px;width:90vw;max-width:920px;color:#e6f3ff;display:flex;flex-direction:column;gap:18px;box-shadow:0 26px 70px rgba(0,0,0,0.55)}
  .lobby-stage-header{display:flex;justify-content:space-between;align-items:center}
  .lobby-stage-header h2{margin:0;font-size:24px;letter-spacing:0.08em;text-transform:uppercase;color:#7cc4ff}
  .lobby-stage-status{font-size:13px;opacity:0.75}
  .lobby-stage-body{display:flex;gap:18px;flex-wrap:wrap}
  .lobby-stage-roster{flex:1.4;min-width:260px;background:rgba(0,0,0,0.32);border-radius:16px;padding:16px;display:flex;flex-direction:column;gap:12px}
  .lobby-stage-roster h3{margin:0;font-size:18px;letter-spacing:0.06em;text-transform:uppercase;color:#a6d4ff}
  .lobby-roster-list{flex:1;max-height:320px;overflow-y:auto;display:flex;flex-direction:column;gap:10px}
  .lobby-roster-entry{display:flex;align-items:center;justify-content:space-between;background:rgba(255,255,255,0.06);border-radius:12px;padding:10px 14px;font-size:14px}
  .lobby-roster-entry .name{display:flex;align-items:center;gap:8px}
  .lobby-roster-entry .crown{color:#ffd15f;font-size:16px}
  .lobby-roster-entry .ping{font-size:12px;opacity:0.8}
  .lobby-stage-options{flex:1;min-width:240px;display:flex;flex-direction:column;gap:16px}
  .lobby-stage-card{background:rgba(0,0,0,0.28);border-radius:14px;padding:14px 16px;display:flex;flex-direction:column;gap:10px}
  .lobby-stage-card h4{margin:0;font-size:16px;letter-spacing:0.05em;text-transform:uppercase;color:#8fbfff}
  .lobby-option-grid{display:flex;flex-direction:column;gap:8px}
  .lobby-option-grid label{display:flex;align-items:center;gap:10px;font-size:14px}
  .lobby-option-grid select,.lobby-option-grid button{padding:8px 10px;border-radius:10px;border:1px solid rgba(124,196,255,0.25);background:rgba(8,16,28,0.85);color:#e6f3ff}
  .lobby-stage-actions{display:flex;justify-content:flex-end;gap:12px;flex-wrap:wrap}
  .lobby-stage-actions button{padding:10px 18px;border-radius:999px;border:none;background:#3da6ff;color:#fff;font-weight:600;cursor:pointer;box-shadow:0 10px 24px rgba(0,0,0,0.45)}
  .lobby-stage-actions button:disabled{opacity:0.55;cursor:not-allowed;box-shadow:none}
  .lobby-ready-toggle{background:rgba(0,0,0,0.35)!important;border:1px solid rgba(124,196,255,0.35)!important}
  textarea{width:480px;height:120px;background:#111;color:#fff;border:1px solid #333;padding:6px;border-radius:6px;resize:vertical}
  @media(max-width:640px){ textarea{width:calc(100vw - 32px)} .instructions{max-width:140px;font-size:12px} .hud,.players,.instructions,#network{padding:6px;font-size:13px} }
  button{padding:6px 10px;margin:4px;border-radius:8px;border:none;background:var(--btn);color:#fff;cursor:pointer}
  input[type="text"]{padding:6px;border-radius:6px;border:1px solid #333;background:#111;color:#fff}
  label{font-size:13px;margin-right:8px}
  .small{font-size:12px}
  .touch-controls{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:80;display:none}
  .touch-controls.active{display:block}
  .touch-joystick{position:absolute;width:150px;height:150px;border-radius:50%;border:2px solid rgba(255,255,255,0.25);background:rgba(0,0,0,0.25);pointer-events:auto;touch-action:none;z-index:82}
  .touch-joystick::after{content:'';position:absolute;left:50%;top:50%;width:60px;height:60px;margin:-30px 0 0 -30px;border-radius:50%;background:rgba(255,255,255,0.3);transition:transform 0.06s ease;transform:translate(var(--jx,0px),var(--jy,0px))}
  .touch-joystick.move{left:24px;bottom:24px}
  .touch-look-area{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;touch-action:none;z-index:81;background:transparent}
  .touch-buttons{position:absolute;right:26px;top:calc(50% - 120px);display:flex;flex-direction:column;gap:16px;pointer-events:auto}
  .touch-button{width:110px;padding:10px 0;border-radius:28px;background:rgba(0,0,0,0.45);border:2px solid rgba(255,255,255,0.25);color:#fff;text-align:center;font-size:14px;font-weight:600;touch-action:none}
  .touch-button.small{width:86px;font-size:12px;align-self:flex-end}
  .touch-button.active{background:rgba(255,255,255,0.25);border-color:rgba(255,255,255,0.55)}
  .parry-flash{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;background:rgba(255,255,255,0.65);opacity:0;transition:opacity 0.18s ease;mix-blend-mode:screen;z-index:140}
  @media(hover:none) and (pointer:coarse){
    .touch-controls{display:block}
  }
  .wave-banner{position:absolute;left:50%;top:40%;transform:translate(-50%,-50%);padding:18px 28px;background:rgba(0,0,0,0.65);border-radius:14px;border:2px solid rgba(255,80,80,0.8);color:#ff8080;font-size:26px;font-weight:700;letter-spacing:1px;text-transform:uppercase;opacity:0;pointer-events:none;transition:opacity 0.3s ease;z-index:110;text-align:center}
  .wave-banner.show{opacity:1}
  .menu-screen{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.75);z-index:200}
  .menu-panel{background:rgba(12,20,32,0.92);border-radius:18px;padding:28px 32px;min-width:320px;max-width:90vw;color:#f2f6ff;box-shadow:0 20px 60px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:20px}
  .menu-panel h1{margin:0;font-size:26px;text-align:center;letter-spacing:0.08em;text-transform:uppercase;color:#7cc4ff}
  .menu-tabs{display:flex;gap:12px;justify-content:center}
  .menu-tab{padding:8px 16px;border-radius:999px;background:rgba(124,196,255,0.18);border:1px solid rgba(124,196,255,0.35);color:#e0f4ff;cursor:pointer;font-size:14px;letter-spacing:0.04em;text-transform:uppercase;transition:background 0.2s,border 0.2s}
  .menu-tab.active{background:rgba(124,196,255,0.38);border-color:rgba(124,196,255,0.85)}
  .menu-section{display:none;flex-direction:column;gap:16px;align-items:center;text-align:center}
  .menu-section.active{display:flex}
  .menu-section button{padding:12px 26px;border-radius:999px;font-size:15px;font-weight:600;background:#3da6ff;border:none;color:#fff;cursor:pointer;box-shadow:0 8px 18px rgba(0,0,0,0.35);transition:transform 0.15s}
  .menu-section button:hover{transform:translateY(-1px)}
  .menu-section label{display:flex;align-items:center;gap:12px;font-size:14px}
  .menu-subsection{display:flex;flex-direction:column;gap:16px;align-items:center}
  .menu-subsection.hidden{display:none}
  .menu-field{flex-direction:column;align-items:flex-start;width:100%;max-width:260px}
  .menu-field input{width:100%;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.18);background:rgba(5,12,20,0.65);color:#eaf6ff}
  .menu-mode-buttons{display:flex;flex-direction:column;gap:10px;width:100%;max-width:260px}
  .menu-mode-buttons button{width:100%}
  .menu-link{background:transparent!important;border:1px solid rgba(124,196,255,0.4)!important;color:#7cc4ff!important;box-shadow:none!important}
  .menu-link:hover{transform:none}
  .menu-color-preview{width:54px;height:54px;border-radius:12px;border:2px solid rgba(255,255,255,0.35);box-shadow:0 6px 18px rgba(0,0,0,0.4)}
  .menu-note{font-size:12px;opacity:0.7}
  .menu-toggle{display:flex;align-items:center;gap:10px;font-size:14px}
  .menu-toggle input{width:18px;height:18px}
  @media(max-width:520px){
    .menu-panel{width:92vw;padding:22px 20px}
    .menu-panel h1{font-size:22px}
    .menu-tabs{flex-direction:column;gap:8px}
  }
  @media(max-width:720px){
    .hud{left:50%;top:8px;transform:translateX(-50%);max-width:calc(100% - 24px);text-align:center;padding:8px 12px;font-size:13px}
    .players{left:50%;top:auto;bottom:8px;transform:translateX(-50%);max-width:calc(100% - 24px);text-align:center;padding:8px 12px;font-size:12px}
    .instructions{left:50%;right:auto;top:auto;bottom:calc(8px + 120px);transform:translateX(-50%);max-width:calc(100% - 40px);font-size:12px;padding:8px 12px}
    .touch-buttons{right:16px;top:auto;bottom:24px;flex-direction:column-reverse}
  }
</style>
</head>
<body>
<div id="container">
  <div class="hud" id="hud">Score: 0 | Enemies: 0 | HP: 1 | Host IP: N/A</div>

  <div class="players" id="players">Players: me</div>

  <div class="instructions">
    <strong>Controls</strong><br>
    WASD / Left Stick - move<br>Mouse / Right Stick - look<br>Click / RT / Touch Shoot - fire (hold to spray)<br>Space / A - jump & double jump (hold near walls to climb)<br>Shift / B - slide boost (tap in air to vault)<br>Ctrl / X - forward dash<br>F - punch up close<br>Y / View - toggle camera<br>Esc - pause / release mouse<br>1-4 - quick swap weapons<br>Hold Q / LT / Touch Wheel - weapon wheel<br>H - toggle high quality<br>Touch players: use the on-screen sticks & buttons<br>Weapons: 1 Pulse | 2 Rocket | 3 Scatter | 4 Pee Stream
  </div>

  <div class="crosshair"></div>

  <div id="parryFlash" class="parry-flash"></div>

  <div id="weaponWheel" class="weapon-wheel">
    <div class="weapon-wheel-hint">Move the mouse to highlight a weapon</div>
  </div>

  <div id="gameOver">
    <div style="font-size:20px">Game Over</div>
    <img src="backflip.gif" alt="backflip" style="width:180px">
    <br><button id="retry">Retry</button>
  </div>

  <div id="network">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label style="display:none">Name: <input id="nameInput" type="text" placeholder="Your name" style="width:140px"></label>
      <label>Server URL: <input id="serverUrl" type="text" placeholder="wss://example.ngrok-free.app" value="wss://unswarming-etha-unscanned.ngrok-free.dev" style="width:210px"></label>
      <label>Room Code: <input id="roomCode" type="text" placeholder="my-room" style="width:110px"></label>
      <button id="btnHost">Quick Host</button>
      <button id="btnJoin">Quick Join</button>
      <button id="btnDisconnect" disabled>Disconnect</button>
      <button id="btnHide">Hide UI</button>
    </div>

    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px">
      <label>Lobby Name: <input id="lobbyName" type="text" placeholder="City Showdown" style="width:170px"></label>
      <label>Max Players: <input id="lobbyMax" type="number" min="1" max="16" value="10" style="width:60px"></label>
      <button id="btnCreateLobby">Create Lobby</button>
      <button id="btnBrowseLobbies">Browse Lobbies</button>
    </div>

    <div id="connectionStatus" class="small" style="margin-top:6px">Status: disconnected</div>
    <div id="networkLog" class="small" style="margin-top:6px;max-height:140px;overflow:auto;white-space:pre-line"></div>
  </div>

  <div id="waveBanner" class="wave-banner"></div>

  <div id="mainMenu" class="menu-screen">
    <div class="menu-panel">
      <h1>A day in the life of alex14534</h1>
      <div class="menu-tabs">
        <button class="menu-tab active" data-tab="play">Play</button>
        <button class="menu-tab" data-tab="customize">Customize</button>
        <button class="menu-tab" data-tab="options">Options</button>
      </div>
      <div class="menu-section active" data-content="play">
        <div id="playIntro" class="menu-subsection">
          <button id="btnStartGame">Play</button>
          <div class="menu-note">Get ready to pick how you want to jump in.</div>
        </div>
        <div id="playModeSelect" class="menu-subsection hidden">
          <label class="menu-field">Room Code
            <input type="text" id="menuRoomCode" placeholder="room-1234">
          </label>
          <label class="menu-field">Player Name
            <input type="text" id="menuPlayerName" placeholder="Alex">
          </label>
          <div class="menu-note">Choose singleplayer or hop online.</div>
          <div class="menu-mode-buttons">
            <button id="btnPlaySolo">Singleplayer</button>
            <button id="btnPlayHost">Create Lobby</button>
            <button id="btnPlayJoin">Join Lobby</button>
          </div>
          <button id="btnPlayBack" class="menu-link">Back</button>
        </div>
      </div>
      <div class="menu-section" data-content="customize">
        <label>Cube Color
          <input type="color" id="cubeColor" value="#01c119">
        </label>
        <div class="menu-color-preview" id="cubePreview"></div>
        <div class="menu-note">Saved automatically (cookies).</div>
      </div>
      <div class="menu-section" data-content="options">
        <label class="menu-toggle"><input type="checkbox" id="alexlandToggle"> Alexland Mode</label>
        <div class="menu-note">Replace every texture with the victory flip gif.</div>
      </div>
    </div>
  </div>
</div>

<div id="pauseMenu" class="menu-screen" style="display:none">
  <div class="menu-panel" style="gap:16px;min-width:260px">
    <h1>Paused</h1>
    <div class="menu-subsection" style="width:100%">
      <label class="menu-field" style="width:100%">Player Name
        <input type="text" id="pauseNameInput" placeholder="Player">
      </label>
      <label class="menu-field" style="width:100%">Cube Color
        <input type="color" id="pauseColorInput" value="#01c119">
      </label>
      <button id="btnResume">Resume</button>
      <button id="btnPauseMenu" class="menu-link">Main Menu</button>
    </div>
  </div>
</div>

<div id="lobbyBrowser" class="lobby-browser">
  <div class="lobby-browser-header">
    <span>Lobby Browser</span>
    <div>
      <button id="btnRefreshLobbies" style="margin:0 6px 0 0">Refresh</button>
      <button id="btnCloseLobbyBrowser">Close</button>
    </div>
  </div>
  <div class="lobby-browser-body">
    <div id="lobbyList" class="lobby-list"></div>
    <div class="lobby-detail">
      <h3 id="lobbyDetailName">Select a lobby</h3>
      <div id="lobbyDetailMeta" class="small" style="opacity:0.8">Pick a room from the list to see who is inside.</div>
      <div id="lobbyPlayers" class="lobby-player-list empty">No lobby selected</div>
      <div class="lobby-actions">
        <button id="btnJoinLobby" disabled>Join Lobby</button>
      </div>
    </div>
  </div>
</div>

<div id="lobbyStage" class="lobby-stage">
  <div class="lobby-stage-panel">
    <div class="lobby-stage-header">
      <h2 id="lobbyStageTitle">Lobby</h2>
      <div id="lobbyStageStatus" class="lobby-stage-status">Waiting for playersâ€¦</div>
    </div>
    <div class="lobby-stage-body">
      <div class="lobby-stage-roster">
        <h3>Players</h3>
        <div id="lobbyRosterList" class="lobby-roster-list"></div>
      </div>
      <div class="lobby-stage-options">
        <div class="lobby-stage-card">
          <h4>Gamemode</h4>
          <div class="lobby-option-grid">
            <label><input type="radio" name="lobbyMode" value="classic"> Classic (Waves)</label>
            <label><input type="radio" name="lobbyMode" value="deathmatch"> Deathmatch</label>
            <label><input type="radio" name="lobbyMode" value="pee"> Pee Deathmatch</label>
            <label><input type="radio" name="lobbyMode" value="random"> Random</label>
          </div>
        </div>
        <div class="lobby-stage-card">
          <h4>Map</h4>
          <div class="lobby-option-grid">
            <label>Choose Map
              <select id="lobbyMapSelect">
                <option value="alexland">Alexland</option>
                <option value="duel">1v1 Showdown</option>
                <option value="skyline">Skyline Rush</option>
              </select>
            </label>
            <label><input type="checkbox" id="lobbyFriendlyFire"> Enable Friendly Fire</label>
          </div>
        </div>
      </div>
    </div>
    <div class="lobby-stage-actions">
      <button id="lobbyLeaveButton" class="lobby-ready-toggle">Leave Lobby</button>
      <button id="lobbyReadyButton" class="lobby-ready-toggle">Ready Up</button>
      <button id="lobbyStartButton" disabled>Start Game</button>
    </div>
  </div>
</div>

<div id="touchControls" class="touch-controls">
  <div id="touchMove" class="touch-joystick move"></div>
  <div id="touchLook" class="touch-look-area"></div>
  <div class="touch-buttons">
    <div class="touch-button" data-action="jump">Jump</div>
    <div class="touch-button" data-action="dash">Dash</div>
    <div class="touch-button" data-action="slide">Slide</div>
    <div class="touch-button" data-action="punch">Punch</div>
    <div class="touch-button small" data-action="wheel">Wheel</div>
    <div class="touch-button" data-action="shoot">Shoot</div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
import { OBJLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/OBJLoader.js?module';
import { MTLLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/MTLLoader.js?module';

/* -------------------------
   Scene + basic game setup
   ------------------------- */
const container = document.getElementById('container');
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87b9ff);
scene.fog = new THREE.Fog(0x87b9ff, 40, 180);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,0.7,0);
scene.add(camera);
const renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth, innerHeight); container.appendChild(renderer.domElement);
window.addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); positionWeaponWheelOptions(); weaponWheelState.pointer = {x: innerWidth/2, y: innerHeight/2}; });

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(-10,10,5); scene.add(dir);

const environment = new THREE.Group();
scene.add(environment);

let alexlandTexture = null;
const alexlandMaterials = new Map();
let alexlandMode = false;

function loadAlexlandTexture(){
  if(alexlandTexture) return alexlandTexture;
  const loader = new THREE.TextureLoader();
  alexlandTexture = loader.load('backflip.gif', tex=>{
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(4,4);
    tex.needsUpdate = true;
  });
  if(alexlandTexture){
    alexlandTexture.wrapS = alexlandTexture.wrapT = THREE.RepeatWrapping;
    alexlandTexture.repeat.set(4,4);
    alexlandTexture.minFilter = THREE.LinearFilter;
    alexlandTexture.magFilter = THREE.LinearFilter;
    if('colorSpace' in alexlandTexture){
      alexlandTexture.colorSpace = THREE.SRGBColorSpace;
    }
  }
  return alexlandTexture;
}

function registerForAlexland(object){
  if(!object) return;
  object.traverse(node=>{
    if(node.isMesh){
      const mats = Array.isArray(node.material) ? node.material : [node.material];
      mats.forEach(mat=>{
        if(!mat || !mat.isMaterial) return;
        if(!alexlandMaterials.has(mat)){
          alexlandMaterials.set(mat, {
            color: mat.color ? mat.color.clone() : null,
            emissive: mat.emissive ? mat.emissive.clone() : null,
            map: mat.map || null,
            emissiveMap: mat.emissiveMap || null
          });
        }
        if(alexlandMode){
          applyAlexlandMaterial(mat);
        }
      });
    }
  });
}

function refreshAlexlandBaseline(object){
  if(!object) return;
  object.traverse(node=>{
    if(node.isMesh){
      const mats = Array.isArray(node.material) ? node.material : [node.material];
      mats.forEach(mat=>{
        if(!mat || !mat.isMaterial) return;
        const record = alexlandMaterials.get(mat);
        if(record){
          record.color = mat.color ? mat.color.clone() : null;
          record.emissive = mat.emissive ? mat.emissive.clone() : null;
          if(!alexlandMode){
            record.map = mat.map || null;
            record.emissiveMap = mat.emissiveMap || null;
          }
          if(alexlandMode){
            applyAlexlandMaterial(mat);
          }
        }
      });
    }
  });
}

function applyAlexlandMaterial(mat){
  const tex = loadAlexlandTexture();
  if(tex){
    mat.map = tex;
    mat.map.needsUpdate = true;
  }
  if(mat.color){ mat.color.setHex(0xffffff); }
  if(mat.emissive){
    const baseline = alexlandMaterials.get(mat);
    if(baseline && baseline.emissive){
      mat.emissive.copy(baseline.emissive);
    } else {
      mat.emissive.setHex(0x202020);
    }
  }
  if('emissiveIntensity' in mat && typeof mat.emissiveIntensity === 'number'){
    mat.emissiveIntensity = Math.min(1, Math.max(0.1, mat.emissiveIntensity));
  }
  mat.emissiveMap = null;
  mat.needsUpdate = true;
}

function restoreAlexlandMaterial(mat){
  const record = alexlandMaterials.get(mat);
  if(!record) return;
  mat.map = record.map || null;
  if(mat.color && record.color){ mat.color.copy(record.color); }
  if(mat.emissive && record.emissive){ mat.emissive.copy(record.emissive); }
  mat.emissiveMap = record.emissiveMap || null;
  mat.needsUpdate = true;
}

function setAlexlandMode(enabled){
  alexlandMode = !!enabled;
  if(alexlandToggleInput){
    alexlandToggleInput.checked = alexlandMode;
  }
  alexlandMaterials.forEach((_, mat)=>{
    if(alexlandMode){
      applyAlexlandMaterial(mat);
    } else {
      restoreAlexlandMaterial(mat);
    }
  });
}

const staticColliders = [];

let activeMapKey = 'alexland';
let activeLobbyName = 'Alexland';
let populationSignUpdater = ()=>{};
let remotePlayers = {}; // peerId -> state

function createAlexlandMap(){
  const group = new THREE.Group();
  const colliders = [];
  const addCollider = (minX, minY, minZ, maxX, maxY, maxZ)=>{
    colliders.push(new THREE.Box3(new THREE.Vector3(minX, minY, minZ), new THREE.Vector3(maxX, maxY, maxZ)));
  };

  const groundMaterial = new THREE.MeshStandardMaterial({color:0x3d9a4a, roughness:0.85, metalness:0.08});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), groundMaterial);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  group.add(ground);

  const path = new THREE.Mesh(new THREE.PlaneGeometry(8,26), new THREE.MeshStandardMaterial({color:0x9a7b55, roughness:0.92, metalness:0.05}));
  path.rotation.x = -Math.PI/2;
  path.position.set(0,0.02,-9);
  group.add(path);

  const houseGroup = new THREE.Group();
  const houseBase = new THREE.Mesh(new THREE.BoxGeometry(5.4,3.2,5.4), new THREE.MeshStandardMaterial({color:0xa0785a, roughness:0.72}));
  houseBase.position.y = 1.6;
  houseGroup.add(houseBase);
  const roof = new THREE.Mesh(new THREE.ConeGeometry(4.3,2.8,4), new THREE.MeshStandardMaterial({color:0x7a2a22, roughness:0.45}));
  roof.position.y = 3.8;
  roof.rotation.y = Math.PI/4;
  houseGroup.add(roof);
  const door = new THREE.Mesh(new THREE.BoxGeometry(1.2,2.2,0.2), new THREE.MeshStandardMaterial({color:0x3b281a, roughness:0.6}));
  door.position.set(0,1.1,2.7);
  houseGroup.add(door);
  const windowMat = new THREE.MeshStandardMaterial({color:0x8fd5ff, emissive:0x1a2a33, emissiveIntensity:0.25, roughness:0.2});
  const windowLeft = new THREE.Mesh(new THREE.PlaneGeometry(1.2,1.2), windowMat);
  windowLeft.position.set(-1.6,1.6,2.71);
  windowLeft.rotation.y = Math.PI;
  houseGroup.add(windowLeft);
  const windowRight = windowLeft.clone();
  windowRight.position.x = 1.6;
  houseGroup.add(windowRight);
  houseGroup.position.set(9,0,-6);
  group.add(houseGroup);
  addCollider(9-2.8, 0, -6-2.8, 9+2.8, 2.2, -6+2.8);

  const mountain = new THREE.Mesh(new THREE.ConeGeometry(7.5,10,6), new THREE.MeshStandardMaterial({color:0x61615f, roughness:0.96}));
  mountain.position.set(-12,5,14);
  group.add(mountain);
  addCollider(-12-5, 0, 14-5, -12+5, 10, 14+5);

  const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2.4,0), new THREE.MeshStandardMaterial({color:0x5a534c, roughness:0.88}));
  rock.position.set(-4,1.2,-3);
  group.add(rock);
  addCollider(-6.2,0,-5.2,-1.8,2.4,-0.8);

  const shrubGeometry = new THREE.ConeGeometry(0.6,1.2,6);
  const shrubMaterial = new THREE.MeshStandardMaterial({color:0x2f7c34, roughness:0.9});
  [[ -2, -11 ], [ 5, -4 ], [ -8, 6 ], [ 3, 10 ], [ 11, -2 ]].forEach(([x,z])=>{
    const shrub = new THREE.Mesh(shrubGeometry, shrubMaterial);
    shrub.position.set(x,0.6,z);
    group.add(shrub);
  });

  function createTree(x, z, height=3.6){
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.26,height*0.6,10), new THREE.MeshStandardMaterial({color:0x6b4b2a, roughness:0.8}));
    trunk.position.set(x, height*0.3, z);
    const canopy = new THREE.Mesh(new THREE.ConeGeometry(height*0.35, height*0.8, 12), new THREE.MeshStandardMaterial({color:0x2f8344, roughness:0.7}));
    canopy.position.set(x, height*0.9, z);
    group.add(trunk);
    group.add(canopy);
    addCollider(x-0.45, 0, z-0.45, x+0.45, height*0.9, z+0.45);
  }
  [[ -14, -8 ], [ -10, -3 ], [ -6, 11 ], [ 6, 14 ], [ 12, 3 ], [ 15, -5 ]].forEach(([x,z], idx)=> createTree(x, z, 3.3 + (idx%3)*0.45));

  const pond = new THREE.Mesh(new THREE.CylinderGeometry(4.2,4.2,0.2,28), new THREE.MeshStandardMaterial({color:0x4ab6ff, transparent:true, opacity:0.82, roughness:0.12, metalness:0.32}));
  pond.position.set(-5,0.09,-12);
  group.add(pond);
  addCollider(-5-4.2, 0, -12-4.2, -5+4.2, 0.4, -12+4.2);

  const dock = new THREE.Mesh(new THREE.BoxGeometry(2.8,0.18,1.6), new THREE.MeshStandardMaterial({color:0x8b7252, roughness:0.85}));
  dock.position.set(-1.6,0.18,-12.2);
  group.add(dock);
  addCollider(dock.position.x-1.4, 0, dock.position.z-0.8, dock.position.x+1.4, dock.position.y+0.2, dock.position.z+0.8);

  const campfire = new THREE.Group();
  const fireRocks = new THREE.Mesh(new THREE.TorusGeometry(0.6,0.12,8,16), new THREE.MeshStandardMaterial({color:0x777777, roughness:0.9}));
  campfire.add(fireRocks);
  const flame = new THREE.Mesh(new THREE.ConeGeometry(0.28,0.7,8), new THREE.MeshStandardMaterial({color:0xffc164, emissive:0xff8632, emissiveIntensity:0.8, transparent:true, opacity:0.9}));
  flame.position.y = 0.45;
  campfire.add(flame);
  campfire.position.set(2.4,0,-3.6);
  group.add(campfire);
  addCollider(2.4-0.7,0,-3.6-0.7,2.4+0.7,0.8,-3.6+0.7);

  const bench = new THREE.Group();
  const benchSeat = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.12,0.42), new THREE.MeshStandardMaterial({color:0xa6855c, roughness:0.72}));
  benchSeat.position.y = 0.42;
  bench.add(benchSeat);
  const benchLegMaterial = new THREE.MeshStandardMaterial({color:0x57422d, roughness:0.8});
  [[ -0.7, -0.16 ], [ 0.7, -0.16 ], [ -0.7, 0.16 ], [ 0.7, 0.16 ]].forEach(([lx, lz])=>{
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.42,0.1), benchLegMaterial);
    leg.position.set(lx,0.21,lz);
    bench.add(leg);
  });
  bench.position.set(3.4,0,-2.4);
  bench.rotation.y = Math.PI/6;
  group.add(bench);
  addCollider(bench.position.x-0.9,0,bench.position.z-0.35, bench.position.x+0.9, bench.position.y+0.6, bench.position.z+0.35);

  const houseSteps = new THREE.Group();
  const stepMaterial = new THREE.MeshStandardMaterial({color:0x9f8a6f, roughness:0.7});
  for(let i=0;i<4;i++){
    const step = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.34,1.2), stepMaterial);
    step.position.set(7.1, 0.17 + i*0.32, -6.9 + i*0.88);
    houseSteps.add(step);
    addCollider(step.position.x-0.8, 0, step.position.z-0.6, step.position.x+0.8, step.position.y+0.2, step.position.z+0.6);
  }
  const railing = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,2.2,8), new THREE.MeshStandardMaterial({color:0xceb27a, roughness:0.6}));
  railing.position.set(7.8,1.2,-4.8);
  railing.rotation.z = Math.PI/2.3;
  houseSteps.add(railing);
  houseSteps.position.x += 0.2;
  group.add(houseSteps);

  const rooftopWalk = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.18,4.4), new THREE.MeshStandardMaterial({color:0xcab99a, roughness:0.68}));
  rooftopWalk.position.set(8.6, 1.35, -4.3);
  rooftopWalk.rotation.y = -0.12;
  group.add(rooftopWalk);
  addCollider(rooftopWalk.position.x-0.9, rooftopWalk.position.y-0.1, rooftopWalk.position.z-2.2, rooftopWalk.position.x+0.9, rooftopWalk.position.y+0.2, rooftopWalk.position.z+2.2);
  const rooftopRamp = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.22,1.6), new THREE.MeshStandardMaterial({color:0xbfa983, roughness:0.7}));
  rooftopRamp.position.set(9.2, 2.05, -2.8);
  group.add(rooftopRamp);
  addCollider(rooftopRamp.position.x-0.6, rooftopRamp.position.y-0.1, rooftopRamp.position.z-0.8, rooftopRamp.position.x+0.6, rooftopRamp.position.y+0.2, rooftopRamp.position.z+0.8);

  const lookoutPlatform = new THREE.Mesh(new THREE.BoxGeometry(3.2,0.24,2.6), new THREE.MeshStandardMaterial({color:0xb7a57a, roughness:0.75}));
  lookoutPlatform.position.set(9,2.45,-1.8);
  group.add(lookoutPlatform);
  addCollider(lookoutPlatform.position.x-1.6, lookoutPlatform.position.y, lookoutPlatform.position.z-1.3, lookoutPlatform.position.x+1.6, lookoutPlatform.position.y+0.4, lookoutPlatform.position.z+1.3);

  const signCanvas = document.createElement('canvas');
  signCanvas.width = 512;
  signCanvas.height = 256;
  const signCtx = signCanvas.getContext('2d');
  const signTexture = new THREE.CanvasTexture(signCanvas);
  signTexture.anisotropy = 4;
  if('colorSpace' in signTexture){
    signTexture.colorSpace = THREE.SRGBColorSpace;
  }
  const signMaterial = new THREE.MeshStandardMaterial({map: signTexture, transparent: true, roughness:0.82, metalness:0.12, side:THREE.DoubleSide});
  const signBoard = new THREE.Mesh(new THREE.PlaneGeometry(4.6,2.3), signMaterial);
  signBoard.position.set(0,1.6,0.12);
  const signPostMaterial = new THREE.MeshStandardMaterial({color:0x8e6b42, roughness:0.9});
  const signPostLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,2.4,10), signPostMaterial);
  signPostLeft.position.set(-0.9,1.2,0);
  const signPostRight = signPostLeft.clone();
  signPostRight.position.x = 0.9;
  const signGroup = new THREE.Group();
  signGroup.add(signBoard);
  signGroup.add(signPostLeft);
  signGroup.add(signPostRight);
  const signBeam = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.18,0.2), signPostMaterial);
  signBeam.position.set(0,2.2,0);
  signGroup.add(signBeam);
  signGroup.position.set(2.5,0,-14);
  group.add(signGroup);
  addCollider(signGroup.position.x - 0.5, 0, signGroup.position.z - 0.5, signGroup.position.x + 0.5, 2.6, signGroup.position.z + 0.5);

  function updateSign(count, lobbyName = activeLobbyName){
    const display = Math.max(1, Math.round(count));
    const name = (lobbyName || 'Alexland').trim() || 'Alexland';
    const key = `${display}|${name}`;
    if(updateSign.last === key) return;
    updateSign.last = key;
    signCtx.fillStyle = '#2f6b24';
    signCtx.fillRect(0,0,signCanvas.width,signCanvas.height);
    signCtx.fillStyle = '#1c4815';
    signCtx.fillRect(18,18,signCanvas.width-36,signCanvas.height-36);
    signCtx.lineWidth = 6;
    signCtx.strokeStyle = '#d7cfa2';
    signCtx.strokeRect(18,18,signCanvas.width-36,signCanvas.height-36);
    signCtx.fillStyle = '#f2eccb';
    signCtx.textAlign = 'left';
    signCtx.textBaseline = 'top';
    const trimmed = name.length > 20 ? `${name.slice(0, 19)}â€¦` : name;
    const titleSize = trimmed.length > 14 ? 44 : 52;
    const popSize = trimmed.length > 16 ? 38 : 44;
    signCtx.font = `bold ${titleSize}px "Segoe UI", sans-serif`;
    signCtx.fillText(`Welcome to ${trimmed}`, 32, 52);
    signCtx.font = `bold ${popSize}px "Segoe UI", sans-serif`;
    signCtx.fillText(`Population: ${display}`, 32, 140);
    signTexture.needsUpdate = true;
  }

  return { group, colliders, updateSign };
}

function createDuelMap(){
  const group = new THREE.Group();
  const colliders = [];
  const addCollider = (minX, minY, minZ, maxX, maxY, maxZ)=>{
    colliders.push(new THREE.Box3(new THREE.Vector3(minX, minY, minZ), new THREE.Vector3(maxX, maxY, maxZ)));
  };

  const base = new THREE.Mesh(new THREE.PlaneGeometry(80,80), new THREE.MeshStandardMaterial({color:0x4a6b8c, roughness:0.8}));
  base.rotation.x = -Math.PI/2;
  group.add(base);

  const borderMaterial = new THREE.MeshStandardMaterial({color:0x243247, roughness:0.6});
  const borderHeight = 2.8;
  const wallGeometry = new THREE.BoxGeometry(80, borderHeight, 2);
  const northWall = new THREE.Mesh(wallGeometry, borderMaterial);
  northWall.position.set(0, borderHeight/2, -39);
  group.add(northWall);
  addCollider(-40,0,-40,40,borderHeight,-38);
  const southWall = northWall.clone();
  southWall.position.z = 39;
  group.add(southWall);
  addCollider(-40,0,38,40,borderHeight,40);
  const sideGeometry = new THREE.BoxGeometry(2, borderHeight, 80);
  const westWall = new THREE.Mesh(sideGeometry, borderMaterial);
  westWall.position.set(-39, borderHeight/2, 0);
  group.add(westWall);
  addCollider(-40,0,-40,-38,borderHeight,40);
  const eastWall = westWall.clone();
  eastWall.position.x = 39;
  group.add(eastWall);
  addCollider(38,0,-40,40,borderHeight,40);

  const duelBuilding = new THREE.Group();
  const tower = new THREE.Mesh(new THREE.BoxGeometry(8,8,8), new THREE.MeshStandardMaterial({color:0x2f405a, roughness:0.75}));
  tower.position.y = 4;
  duelBuilding.add(tower);
  const roof = new THREE.Mesh(new THREE.ConeGeometry(6,4,6), new THREE.MeshStandardMaterial({color:0xc7d8f0, roughness:0.4}));
  roof.position.y = 8;
  duelBuilding.add(roof);
  duelBuilding.position.set(0,0,0);
  group.add(duelBuilding);
  addCollider(-4,0,-4,4,8,4);

  const rampsMaterial = new THREE.MeshStandardMaterial({color:0x88a0bf, roughness:0.55});
  const rampGeometry = new THREE.BoxGeometry(10,0.6,4);
  const ramp1 = new THREE.Mesh(rampGeometry, rampsMaterial);
  ramp1.rotation.z = -0.4;
  ramp1.position.set(-12,1.2,-10);
  group.add(ramp1);
  addCollider(-17,0,-12,-7,2.4,-8);
  const ramp2 = ramp1.clone();
  ramp2.rotation.z = 0.4;
  ramp2.position.set(12,1.2,-10);
  group.add(ramp2);
  addCollider(7,0,-12,17,2.4,-8);
  const ramp3 = ramp1.clone();
  ramp3.rotation.z = -0.4;
  ramp3.position.set(-12,1.2,10);
  group.add(ramp3);
  addCollider(-17,0,8,-7,2.4,12);
  const ramp4 = ramp2.clone();
  ramp4.rotation.z = 0.4;
  ramp4.position.set(12,1.2,10);
  group.add(ramp4);
  addCollider(7,0,8,17,2.4,12);

  const pillars = new THREE.CylinderGeometry(1.2,1.2,6,12);
  const pillarMaterial = new THREE.MeshStandardMaterial({color:0x1f2b3c, roughness:0.65});
  [[-18, -18], [18, -18], [-18, 18], [18, 18]].forEach(([x,z])=>{
    const pillar = new THREE.Mesh(pillars, pillarMaterial);
    pillar.position.set(x,3,z);
    group.add(pillar);
    addCollider(x-1.2,0,z-1.2,x+1.2,6,z+1.2);
  });

  function updateSign(count, lobbyName){
    let banner = group.getObjectByName('duelBanner');
    if(!banner){
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(18,4), new THREE.MeshStandardMaterial({color:0x112033, emissive:0x204060, emissiveIntensity:0.4}));
      plane.name = 'duelBanner';
      plane.position.set(0,5,18.5);
      group.add(plane);
      banner = plane;
    }
    let canvas = banner.userData && banner.userData.canvas;
    if(!canvas){
      canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 256;
      banner.userData = banner.userData || {};
      banner.userData.canvas = canvas;
      banner.userData.ctx = canvas.getContext('2d');
      const texture = new THREE.CanvasTexture(canvas);
      if('colorSpace' in texture){ texture.colorSpace = THREE.SRGBColorSpace; }
      banner.material = new THREE.MeshStandardMaterial({map:texture, transparent:true, emissive:0x204060, emissiveIntensity:0.35});
    }
    const ctx = banner.userData.ctx;
    const texture = banner.material.map;
    ctx.fillStyle = '#0d1723';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#2d8bff';
    ctx.font = 'bold 88px "Segoe UI", sans-serif';
    ctx.fillText(lobbyName || 'Arena', 40, 110);
    ctx.font = 'bold 72px "Segoe UI", sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`Players Ready: ${count}`, 40, 200);
    texture.needsUpdate = true;
  }

  return { group, colliders, updateSign };
}

function createSkylineMap(){
  const group = new THREE.Group();
  const colliders = [];
  const addCollider = (minX, minY, minZ, maxX, maxY, maxZ)=>{
    colliders.push(new THREE.Box3(new THREE.Vector3(minX, minY, minZ), new THREE.Vector3(maxX, maxY, maxZ)));
  };

  const base = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({color:0x1d1f29, roughness:0.7}));
  base.rotation.x = -Math.PI/2;
  group.add(base);

  const fogMat = new THREE.MeshStandardMaterial({color:0x2a2d3a, roughness:0.9});
  const rimGeometry = new THREE.TorusGeometry(60, 2.5, 16, 80);
  const rim = new THREE.Mesh(rimGeometry, fogMat);
  rim.rotation.x = Math.PI/2;
  rim.position.y = -0.4;
  group.add(rim);

  const platformMaterial = new THREE.MeshStandardMaterial({color:0x414b63, roughness:0.55});
  const central = new THREE.Mesh(new THREE.CylinderGeometry(8,8,1.2,24), platformMaterial);
  central.position.set(0,0.6,0);
  group.add(central);
  addCollider(-8,0,-8,8,1.2,8);

  const bridges = [
    { pos:[0,0,18], rot:0 },
    { pos:[18,0,0], rot:Math.PI/2 },
    { pos:[-18,0,0], rot:Math.PI/2 },
    { pos:[0,0,-18], rot:0 }
  ];
  bridges.forEach(({pos, rot})=>{
    const bridge = new THREE.Mesh(new THREE.BoxGeometry(6,0.4,18), new THREE.MeshStandardMaterial({color:0x566b8e, roughness:0.6}));
    bridge.position.set(pos[0],0.4,pos[2]);
    bridge.rotation.y = rot;
    group.add(bridge);
    const halfX = Math.abs(Math.cos(rot)) > 0.5 ? 3 : 9;
    const halfZ = Math.abs(Math.cos(rot)) > 0.5 ? 9 : 3;
    addCollider(pos[0]-halfX,0,pos[2]-halfZ,pos[0]+halfX,0.8,pos[2]+halfZ);
  });

  const pads = [
    [-26,0,26], [26,0,26], [-26,0,-26], [26,0,-26]
  ];
  pads.forEach(([x,y,z], idx)=>{
    const pad = new THREE.Mesh(new THREE.CylinderGeometry(6,6,1,18), new THREE.MeshStandardMaterial({color: idx%2 ? 0x6fd0ff : 0xff6fa0, emissive: idx%2 ? 0x1a4a6d : 0x61183c, emissiveIntensity:0.35, roughness:0.4}));
    pad.position.set(x,0.5,z);
    group.add(pad);
    addCollider(x-6,0,z-6,x+6,1,z+6);
  });

  const towerGeometry = new THREE.BoxGeometry(6, 18, 6);
  const towerMat = new THREE.MeshStandardMaterial({color:0x2d3650, roughness:0.6});
  [[0,18], [24,12], [-24,12]].forEach(([x,height])=>{
    const tower = new THREE.Mesh(towerGeometry, towerMat);
    tower.scale.y = height/18;
    tower.position.set(x, height/2, -24);
    group.add(tower);
    addCollider(x-3,0,-27,x+3,height,-21);
  });

  const holoCanvas = document.createElement('canvas');
  holoCanvas.width = 1024;
  holoCanvas.height = 256;
  const holoCtx = holoCanvas.getContext('2d');
  const holoTexture = new THREE.CanvasTexture(holoCanvas);
  if('colorSpace' in holoTexture){
    holoTexture.colorSpace = THREE.SRGBColorSpace;
  }
  const holoPlane = new THREE.Mesh(new THREE.PlaneGeometry(20,4), new THREE.MeshStandardMaterial({map:holoTexture, transparent:true, emissive:0x2f7be4, emissiveIntensity:0.5}));
  holoPlane.position.set(0,6,0);
  group.add(holoPlane);

  function updateSign(count, lobbyName){
    holoCtx.clearRect(0,0,holoCanvas.width, holoCanvas.height);
    const gradient = holoCtx.createLinearGradient(0,0,holoCanvas.width,0);
    gradient.addColorStop(0,'#5fd6ff');
    gradient.addColorStop(1,'#a66dff');
    holoCtx.fillStyle = gradient;
    holoCtx.fillRect(0,0,holoCanvas.width,holoCanvas.height);
    holoCtx.fillStyle = '#0b1424';
    holoCtx.font = 'bold 96px "Segoe UI", sans-serif';
    holoCtx.fillText(lobbyName || 'Skyline Rush', 40, 110);
    holoCtx.font = 'bold 72px "Segoe UI", sans-serif';
    holoCtx.fillText(`Squad Count: ${count}`, 40, 210);
    holoTexture.needsUpdate = true;
  }

  return { group, colliders, updateSign };
}

function buildEnvironment(mapKey='alexland'){
  activeMapKey = mapKey;
  const builders = {
    alexland: createAlexlandMap,
    duel: createDuelMap,
    skyline: createSkylineMap
  };
  const builder = builders[mapKey] || builders.alexland;
  const { group, colliders, updateSign } = builder();
  while(environment.children.length){
    environment.remove(environment.children[0]);
  }
  environment.add(group);
  populationSignUpdater = typeof updateSign === 'function' ? updateSign : ()=>{};
  staticColliders.length = 0;
  colliders.forEach(box=> staticColliders.push(box));
  registerForAlexland(group);
  refreshAlexlandBaseline(group);
  updatePopulationSign(Object.keys(remotePlayers).length + 1, activeLobbyName);
}

function updatePopulationSign(count, lobbyName = activeLobbyName){
  if(typeof populationSignUpdater === 'function'){
    populationSignUpdater(count, lobbyName);
  }
}

function setActiveLobbyName(name){
  activeLobbyName = (name && name.trim()) ? name.trim() : 'Alexland';
  updatePopulationSign(Object.keys(remotePlayers).length + 1, activeLobbyName);
  updateLobbyStageTitle(activeLobbyName);
}

buildEnvironment('alexland');

function resolveWorldCollisions(nextPosition){
  const adjusted = nextPosition.clone();
  let hitNormal = null;
  const radius = player?.radius ?? 0.45;
  const height = player?.height ?? 1.6;
  const playerBottom = nextPosition.y;
  const playerTop = playerBottom + height;
  for(const box of staticColliders){
    if(playerTop <= box.min.y || playerBottom >= box.max.y) continue;
    const expandedMinX = box.min.x - radius;
    const expandedMaxX = box.max.x + radius;
    const expandedMinZ = box.min.z - radius;
    const expandedMaxZ = box.max.z + radius;
    if(adjusted.x >= expandedMinX && adjusted.x <= expandedMaxX && adjusted.z >= expandedMinZ && adjusted.z <= expandedMaxZ){
      const centerX = (box.min.x + box.max.x) / 2;
      const centerZ = (box.min.z + box.max.z) / 2;
      const overlapX = Math.min(expandedMaxX - adjusted.x, adjusted.x - expandedMinX);
      const overlapZ = Math.min(expandedMaxZ - adjusted.z, adjusted.z - expandedMinZ);
      if(overlapX < overlapZ){
        if(adjusted.x > centerX){
          adjusted.x = expandedMaxX;
          if(player.velocity.x > 0) player.velocity.x = 0;
          hitNormal = new THREE.Vector3(1,0,0);
        } else {
          adjusted.x = expandedMinX;
          if(player.velocity.x < 0) player.velocity.x = 0;
          hitNormal = new THREE.Vector3(-1,0,0);
        }
      } else {
        if(adjusted.z > centerZ){
          adjusted.z = expandedMaxZ;
          if(player.velocity.z > 0) player.velocity.z = 0;
          hitNormal = new THREE.Vector3(0,0,1);
        } else {
          adjusted.z = expandedMinZ;
          if(player.velocity.z < 0) player.velocity.z = 0;
          hitNormal = new THREE.Vector3(0,0,-1);
        }
      }
    }
  }
  return { position: adjusted, normal: hitNormal };
}

/* HUD elements */
const hud = document.getElementById('hud');
const playersDiv = document.getElementById('players');
const nameInput = document.getElementById('nameInput');
const serverUrlInput = document.getElementById('serverUrl');
const roomInput = document.getElementById('roomCode');
const lobbyNameInput = document.getElementById('lobbyName');
const lobbyMaxInput = document.getElementById('lobbyMax');
const statusEl = document.getElementById('connectionStatus');
const networkLogEl = document.getElementById('networkLog');
const btnDisconnect = document.getElementById('btnDisconnect');
const btnCreateLobby = document.getElementById('btnCreateLobby');
const btnBrowseLobbies = document.getElementById('btnBrowseLobbies');
const btnRefreshLobbies = document.getElementById('btnRefreshLobbies');
const btnCloseLobbyBrowser = document.getElementById('btnCloseLobbyBrowser');
const btnJoinLobby = document.getElementById('btnJoinLobby');
const lobbyBrowserEl = document.getElementById('lobbyBrowser');
const lobbyListEl = document.getElementById('lobbyList');
const lobbyDetailNameEl = document.getElementById('lobbyDetailName');
const lobbyDetailMetaEl = document.getElementById('lobbyDetailMeta');
const lobbyPlayersEl = document.getElementById('lobbyPlayers');
const lobbyStageEl = document.getElementById('lobbyStage');
const lobbyStageTitleEl = document.getElementById('lobbyStageTitle');
const lobbyStageStatusEl = document.getElementById('lobbyStageStatus');
const lobbyRosterListEl = document.getElementById('lobbyRosterList');
const lobbyModeInputs = Array.from(document.querySelectorAll('input[name="lobbyMode"]'));
const lobbyMapSelect = document.getElementById('lobbyMapSelect');
const lobbyFriendlyFireInput = document.getElementById('lobbyFriendlyFire');
const lobbyReadyButton = document.getElementById('lobbyReadyButton');
const lobbyStartButton = document.getElementById('lobbyStartButton');
const lobbyLeaveButton = document.getElementById('lobbyLeaveButton');
const weaponWheelEl = document.getElementById('weaponWheel');
const touchControlsEl = document.getElementById('touchControls');
const touchMoveEl = document.getElementById('touchMove');
const touchLookEl = document.getElementById('touchLook');
const touchButtons = Array.from(document.querySelectorAll('.touch-button'));
const mainMenuEl = document.getElementById('mainMenu');
const menuTabs = Array.from(document.querySelectorAll('.menu-tab'));
const menuSections = Array.from(document.querySelectorAll('.menu-section'));
const startButton = document.getElementById('btnStartGame');
const playIntroEl = document.getElementById('playIntro');
const playModeSelectEl = document.getElementById('playModeSelect');
const menuRoomCodeInput = document.getElementById('menuRoomCode');
const menuPlayerNameInput = document.getElementById('menuPlayerName');
const btnPlaySolo = document.getElementById('btnPlaySolo');
const btnPlayHost = document.getElementById('btnPlayHost');
const btnPlayJoin = document.getElementById('btnPlayJoin');
const btnPlayBack = document.getElementById('btnPlayBack');
const cubeColorInput = document.getElementById('cubeColor');
const cubePreviewEl = document.getElementById('cubePreview');
const alexlandToggleInput = document.getElementById('alexlandToggle');
const waveBannerEl = document.getElementById('waveBanner');
const pauseMenuEl = document.getElementById('pauseMenu');
const btnResume = document.getElementById('btnResume');
const btnPauseMenu = document.getElementById('btnPauseMenu');
const pauseNameInput = document.getElementById('pauseNameInput');
const pauseColorInput = document.getElementById('pauseColorInput');
const parryFlashEl = document.getElementById('parryFlash');
const defaultGameOptions = Object.freeze({ mode:'classic', map:'alexland', friendlyFire:false });
let lobbyGameOptions = { ...defaultGameOptions };
let activeGameOptions = { ...defaultGameOptions };
let friendlyFireEnabled = false;
let lobbyPlayersState = new Map();
let lobbyPingState = new Map();
let lobbyHostId = null;
let lobbyStageOpen = false;
let localReadyState = false;
let localJoinOrder = 0;
let lobbyReadyMap = new Map();
const LOBBY_PING_INTERVAL = 5000;
let lobbyPingTimer = 0;

function isPlayerShotOwner(ownerId){
  if(!ownerId) return false;
  if(ownerId === player.id) return true;
  return !!remotePlayers[ownerId];
}

const DEFAULT_SIGNALING_URL = 'wss://unswarming-etha-unscanned.ngrok-free.dev';
const NETWORK_STORAGE_KEY = 'alex-network-settings';
let persistedNetworkSettings = loadPersistedNetworkSettings();
const COLOR_COOKIE_KEY = 'alexCubeColor';
const ALEXLAND_COOKIE_KEY = 'alexlandMode';

function readCookie(name){
  if(typeof document === 'undefined' || !name) return null;
  const prefix = `${name}=`;
  const parts = document.cookie ? document.cookie.split(';') : [];
  for(const part of parts){
    const trimmed = part.trim();
    if(trimmed.startsWith(prefix)){
      return decodeURIComponent(trimmed.slice(prefix.length));
    }
  }
  return null;
}

function writeCookie(name, value, days=365){
  if(typeof document === 'undefined' || !name) return;
  const encoded = encodeURIComponent(value ?? '');
  const maxAge = days ? `; max-age=${Math.floor(days*24*60*60)}` : '';
  document.cookie = `${name}=${encoded}; path=/${maxAge}`;
}

function loadPersistedNetworkSettings(){
  if(typeof window === 'undefined' || !window.localStorage){
    return {};
  }
  try{
    const raw = window.localStorage.getItem(NETWORK_STORAGE_KEY);
    if(!raw) return {};
    const parsed = JSON.parse(raw);
    return parsed && typeof parsed === 'object' ? parsed : {};
  }catch(err){
    console.warn('Failed to read stored network settings', err);
    return {};
  }
}

function savePersistedNetworkSettings(update){
  if(!update || typeof update !== 'object') return;
  persistedNetworkSettings = { ...persistedNetworkSettings, ...update };
  if(typeof window === 'undefined' || !window.localStorage) return;
  try{
    window.localStorage.setItem(NETWORK_STORAGE_KEY, JSON.stringify(persistedNetworkSettings));
  }catch(err){
    console.warn('Failed to persist network settings', err);
  }
}

function applyStoredNetworkDefaults(){
  const settings = persistedNetworkSettings || {};
  const server = settings.server || DEFAULT_SIGNALING_URL;
  serverUrlInput.value = server;
  if(settings.name){
    nameInput.value = settings.name;
    if(menuPlayerNameInput){
      menuPlayerNameInput.value = settings.name;
    }
  }
  if(settings.room){
    roomInput.value = settings.room;
    if(menuRoomCodeInput){
      menuRoomCodeInput.value = settings.room;
    }
  } else if(menuRoomCodeInput){
    menuRoomCodeInput.value = '';
  }
  if(settings.lobbyName){
    lobbyNameInput.value = settings.lobbyName;
  }
  if(settings.capacity){
    lobbyMaxInput.value = settings.capacity;
  }
}

applyStoredNetworkDefaults();

function syncRoomInputFromMenu(){
  if(!menuRoomCodeInput) return '';
  const raw = (menuRoomCodeInput.value || '').trim();
  roomInput.value = raw;
  savePersistedNetworkSettings({ room: raw });
  return raw;
}

const aggregatedInput = {
  move: new THREE.Vector2(),
  jumpHeld: false,
  jumpPressed: false,
  slideHeld: false,
  slidePressed: false,
  dashPressed: false,
  wheelHeld: false,
  wheelPressed: false,
  fireHeld: false,
  firePressed: false,
  prevSlideHeld: false,
  prevWheelHeld: false
};

const keyboardState = {
  moveX: 0,
  moveY: 0,
  jumpHeld: false,
  slideHeld: false,
  dashHeld: false,
  wheelHeld: false
};

const gamepadState = {
  connected: false,
  moveX: 0,
  moveY: 0,
  lookX: 0,
  lookY: 0,
  jump: false,
  dash: false,
  slide: false,
  wheel: false,
  fire: false,
  viewToggle: false,
  prevJump: false,
  prevDash: false,
  prevSlide: false,
  prevWheel: false,
  prevFire: false,
  prevViewToggle: false,
  justJumped: false,
  justDashed: false,
  justSlid: false,
  justWheel: false,
  justFire: false,
  justToggledView: false
};

const touchState = {
  active: false,
  moveId: null,
  lookId: null,
  moveStart: null,
  lookLast: null,
  moveOffset: new THREE.Vector2(),
  lookOffset: new THREE.Vector2(),
  jump: false,
  dash: false,
  slide: false,
  wheel: false,
  fire: false,
  punch: false,
  prevJump: false,
  prevDash: false,
  prevSlide: false,
  prevWheel: false,
  prevFire: false,
  prevPunch: false,
  justJumped: false,
  justDashed: false,
  justSlid: false,
  justWheel: false,
  justFired: false,
  justPunched: false
};

let customCubeColorHex = '#01c119';
let parryAudio = null;

function playSound(name){
  if(name === 'parry'){
    if(!parryAudio){
      parryAudio = new Audio('parry.ogg');
      parryAudio.preload = 'auto';
    }
    try{
      parryAudio.currentTime = 0;
      parryAudio.play();
    }catch(err){}
  }
}

function updateCubePreview(hex){
  if(cubePreviewEl){
    cubePreviewEl.style.background = hex;
  }
}

function applyCustomCubeColor(hex){
  if(!hex) return;
  if(!hex.startsWith('#')) hex = `#${hex}`;
  customCubeColorHex = hex;
  updateCubePreview(hex);
  if(cubeColorInput && cubeColorInput.value !== hex){
    cubeColorInput.value = hex;
  }
  if(pauseColorInput && pauseColorInput.value !== hex){
    pauseColorInput.value = hex;
  }
  applyColorToPlayerMesh(hex);
  if(typeof playerTemplates !== 'undefined'){
    playerTemplates.low = createLowPlayerTemplate();
    if(highQuality){
      playerTemplates.high = null;
      ensureHighQualityModels().then(()=> applyQualityTemplates());
    } else {
      applyQualityTemplates();
    }
  }
}

function setPlayerDisplayName(name, options={}){
  const trimmed = (name || '').trim() || 'Player';
  player.name = trimmed;
  if(nameInput && nameInput.value !== trimmed){
    nameInput.value = trimmed;
  }
  if(menuPlayerNameInput && menuPlayerNameInput.value !== trimmed){
    menuPlayerNameInput.value = trimmed;
  }
  if(pauseNameInput && pauseNameInput.value !== trimmed){
    pauseNameInput.value = trimmed;
  }
  if(options.persist !== false){
    savePersistedNetworkSettings({ name: trimmed });
  }
  updatePlayers();
}

const weaponConfigs = [
  {
    id: 1,
    label: 'Pulse Blaster',
    desc: 'Fast, accurate shot',
    type: 'pulse',
    fireInterval: 0.22,
    firePoseDuration: 0.14,
    chargeCost: 0.25,
    rechargeTime: 1.4,
    rechargeLabel: 'Charging capacitors',
    sway: {amplitude: 0.012, speed: 3.4, tilt: 0.02},
    appearance: {color: 0xffff66, emissive: 0x332200, emissiveIntensity: 0.55, length: 0.95, thickness: 0.95},
    poses: {
      idle: {
        left: {pos: [-0.32, -0.08, -0.32], rot: [-0.35, 0.25, 1.4]},
        right: {pos: [0.22, -0.12, -0.4], rot: [-0.45, -0.05, -1.45]},
        weapon: {pos: [0, -0.1, -0.5], rot: [-0.08, 0, 0]}
      },
      recharge: {
        left: {pos: [-0.3, -0.12, -0.38], rot: [-0.18, 0.32, 1.48]},
        right: {pos: [0.2, -0.2, -0.48], rot: [-0.3, -0.1, -1.52]},
        weapon: {pos: [0, -0.16, -0.64], rot: [-0.26, 0.06, 0]}
      },
      fire: {
        left: {pos: [-0.3, -0.05, -0.25], rot: [-0.25, 0.4, 1.3]},
        right: {pos: [0.25, -0.1, -0.32], rot: [-0.35, 0.05, -1.35]},
        weapon: {pos: [0, -0.06, -0.58], rot: [-0.15, 0, 0]}
      }
    }
  },
  {
    id: 2,
    label: 'Burst Rocket',
    desc: 'Slow but explosive',
    type: 'rocket',
    fireInterval: 0.95,
    firePoseDuration: 0.28,
    chargeCost: 0.5,
    rechargeTime: 2.6,
    rechargeLabel: 'Reloading rockets',
    sway: {amplitude: 0.008, speed: 2.6, tilt: 0.018},
    appearance: {color: 0xff5a2f, emissive: 0x401000, emissiveIntensity: 0.65, length: 1.35, thickness: 1.25},
    poses: {
      idle: {
        left: {pos: [-0.28, -0.18, -0.24], rot: [-0.2, 0.1, 1.55]},
        right: {pos: [0.15, -0.25, -0.34], rot: [-0.1, -0.2, -1.45]},
        weapon: {pos: [0, -0.22, -0.58], rot: [0.1, 0.05, 0]}
      },
      recharge: {
        left: {pos: [-0.26, -0.2, -0.32], rot: [-0.05, 0.22, 1.48]},
        right: {pos: [0.16, -0.3, -0.42], rot: [0.08, -0.22, -1.5]},
        weapon: {pos: [0, -0.28, -0.68], rot: [0.18, 0.08, 0.08]}
      },
      fire: {
        left: {pos: [-0.26, -0.16, -0.18], rot: [-0.1, 0.18, 1.4]},
        right: {pos: [0.18, -0.22, -0.26], rot: [0.02, -0.15, -1.35]},
        weapon: {pos: [0, -0.18, -0.72], rot: [0.18, 0.1, 0.05]}
      }
    }
  },
  {
    id: 3,
    label: 'Scatter Cycler',
    desc: 'Wide pellet burst',
    type: 'scatter',
    fireInterval: 0.58,
    firePoseDuration: 0.2,
    chargeCost: 0.4,
    rechargeTime: 1.8,
    rechargeLabel: 'Cycling drum',
    sway: {amplitude: 0.014, speed: 3.1, tilt: 0.024},
    appearance: {color: 0xfff1c1, emissive: 0x3a2c15, emissiveIntensity: 0.45, length: 1.05, thickness: 1.1},
    poses: {
      idle: {
        left: {pos: [-0.34, -0.12, -0.3], rot: [-0.55, 0.28, 1.7]},
        right: {pos: [0.2, -0.16, -0.38], rot: [-0.65, -0.12, -1.6]},
        weapon: {pos: [0, -0.14, -0.54], rot: [-0.28, 0, 0]}
      },
      recharge: {
        left: {pos: [-0.33, -0.14, -0.4], rot: [-0.38, 0.35, 1.65]},
        right: {pos: [0.2, -0.18, -0.46], rot: [-0.52, -0.08, -1.55]},
        weapon: {pos: [0, -0.18, -0.62], rot: [-0.34, 0.06, 0.02]}
      },
      fire: {
        left: {pos: [-0.32, -0.09, -0.24], rot: [-0.42, 0.4, 1.55]},
        right: {pos: [0.22, -0.14, -0.32], rot: [-0.5, 0, -1.45]},
        weapon: {pos: [0, -0.1, -0.64], rot: [-0.32, 0.08, 0]}
      }
    }
  },
  {
    id: 4,
    label: 'Pee Stream',
    desc: 'Rapid droplet spray',
    type: 'pee',
    fireInterval: 0.12,
    firePoseDuration: 0.1,
    chargeCost: 0.08,
    rechargeTime: 2.2,
    rechargeLabel: 'Drinking water',
    sway: {amplitude: 0.018, speed: 4.2, tilt: 0.03},
    appearance: {color: 0xfff57a, emissive: 0x463800, emissiveIntensity: 0.35, length: 1.2, thickness: 0.75},
    stream: {count: 8, spreadYaw: 0.26, spreadPitch: 0.2, speed: 12, size: 0.06, damage: 0.03, ttl: 0.6, hitRadius: 0.28, gravity: 4.2},
    poses: {
      idle: {
        left: {pos: [-0.18, -0.07, -0.44], rot: [-0.35, 0.05, 1.2]},
        right: {pos: [0.08, -0.1, -0.52], rot: [-0.4, -0.04, -1.2]},
        weapon: {pos: [0, -0.06, -0.72], rot: [-0.45, 0, 0]}
      },
      recharge: {
        left: {pos: [-0.2, 0.02, -0.36], rot: [-0.18, 0.28, 1.42]},
        right: {pos: [0.06, 0.06, -0.28], rot: [-0.92, -0.18, -1.12]},
        weapon: {pos: [0, -0.14, -0.78], rot: [-0.6, 0, 0]}
      },
      fire: {
        left: {pos: [-0.16, -0.06, -0.4], rot: [-0.2, 0.12, 1.05]},
        right: {pos: [0.1, -0.08, -0.46], rot: [-0.28, 0, -1.05]},
        weapon: {pos: [0, -0.03, -0.82], rot: [-0.52, 0.05, 0]}
      }
    }
  }
];
const weaponConfigById = new Map(weaponConfigs.map(cfg=>[cfg.id, cfg]));

const ROBLOX_AVATAR_PROFILES = {
  player: {
    userId: 1771701294,
    fallback: {
      skin: 0xffd9c0,
      head: 0xffd9c0,
      torso: 0x1f3e78,
      torsoAccent: 0xffd15f,
      sleeve: 0x1f3e78,
      shoulders: 0x223c74,
      belt: 0x0d1424,
      boots: 0x2d355c,
      leftArm: 0xffd9c0,
      rightArm: 0xffd9c0,
      leftLeg: 0x1b1d2b,
      rightLeg: 0x1b1d2b,
      brow: 0x2a2a2a,
      eye: 0x111111,
      accessories: [
        {type:'hair', color:0x2f1b10, offset:[0,0.33,0], radius:0.26, height:0.14},
        {type:'cap', color:0x1f3e78, offset:[0,0.37,0], brimRadius:0.34, brimThickness:0.05, height:0.2, billLength:0.22, billWidth:0.26}
      ]
    }
  },
  enemy: {
    userId: 4665392450,
    fallback: {
      skin: 0xffc8ad,
      head: 0xffc8ad,
      torso: 0x4c0f16,
      torsoAccent: 0x87212c,
      sleeve: 0x4c0f16,
      shoulders: 0x87212c,
      belt: 0x22070a,
      boots: 0x3a0c12,
      leftArm: 0xffc8ad,
      rightArm: 0xffc8ad,
      leftLeg: 0x1b1b1b,
      rightLeg: 0x1b1b1b,
      brow: 0x1f1010,
      eye: 0x0d0606,
      accessories: [
        {type:'hair', color:0x12090a, offset:[0,0.34,0], radius:0.24, height:0.14},
        {type:'hat', color:0x87212c, offset:[0,0.36,0], brimRadius:0.36, brimThickness:0.04, height:0.18, taper:0.88},
        {type:'backpack', color:0x4c0f16, height:0.5, width:0.36, depth:0.18}
      ]
    }
  }
};

const ROBLOX_FALLBACK_COLOR_TABLE = {
  1: 0xf2f3f3,
  5: 0xd7c59a,
  6: 0xe4adc8,
  9: 0x9dc3e6,
  11: 0xf8f400,
  12: 0xd47047,
  18: 0xcc8e69,
  21: 0xff1d2d,
  22: 0x2a5bd7,
  23: 0xffed6f,
  24: 0x1f75f2,
  26: 0xbadd3f,
  27: 0xf8a05e,
  28: 0xf7c59a,
  37: 0xff6699,
  100: 0x323232,
  101: 0x6d6e6a,
  102: 0x0d69ac,
  103: 0x185ed8,
  104: 0xffb9d5,
  107: 0xff9438,
  119: 0xf3f2f2,
  135: 0x74869b,
  141: 0x1a1f2b,
  153: 0x111111,
  191: 0xf8d90f,
  192: 0x3a7d44,
  194: 0x7f6b54,
  199: 0x6e99ca,
  208: 0x6d4c41
};

let robloxColorTable = null;
let robloxColorPromise = null;
const robloxAvatarCache = new Map();

function buildFallbackRobloxColorTable(){
  const map = new Map();
  for(const key in ROBLOX_FALLBACK_COLOR_TABLE){
    if(Object.prototype.hasOwnProperty.call(ROBLOX_FALLBACK_COLOR_TABLE, key)){
      map.set(Number(key), ROBLOX_FALLBACK_COLOR_TABLE[key]);
    }
  }
  return map;
}

function parseRobloxHexColor(hex){
  if(typeof hex !== 'string') return null;
  const match = hex.trim().replace('#','');
  if(!/^[0-9a-fA-F]{6}$/.test(match)) return null;
  return parseInt(match, 16);
}

async function ensureRobloxColorTable(){
  if(robloxColorTable) return robloxColorTable;
  if(robloxColorPromise) return robloxColorPromise;
  if(typeof fetch !== 'function'){
    robloxColorTable = buildFallbackRobloxColorTable();
    return robloxColorTable;
  }
  robloxColorPromise = (async()=>{
    try{
      const res = await fetch('https://avatar.roblox.com/v1/avatar-colors');
      if(res && res.ok){
        const json = await res.json();
        const entries = Array.isArray(json?.data) ? json.data : Array.isArray(json?.colors) ? json.colors : [];
        const table = buildFallbackRobloxColorTable();
        for(const entry of entries){
          const id = entry?.brickColorId ?? entry?.id ?? entry?.brickColor?.id;
          const hex = parseRobloxHexColor(entry?.hexColor ?? entry?.hex ?? entry?.color ?? entry?.hexValue);
          if(typeof id === 'number' && Number.isFinite(id) && typeof hex === 'number'){
            table.set(id, hex);
          }
        }
        robloxColorTable = table;
        return robloxColorTable;
      }
    }catch(err){
      console.warn('Failed to fetch Roblox color table', err);
    }
    robloxColorTable = buildFallbackRobloxColorTable();
    return robloxColorTable;
  })().finally(()=>{ robloxColorPromise = null; });
  return robloxColorPromise;
}

function colorFromRobloxId(id, fallback){
  if(typeof id !== 'number' || !Number.isFinite(id)) return fallback;
  if(!robloxColorTable){
    robloxColorTable = buildFallbackRobloxColorTable();
  }
  if(robloxColorTable.has(id)) return robloxColorTable.get(id);
  const seeded = Math.sin(id * 12.9898 + 78.233) * 43758.5453;
  const value = Math.floor((seeded % 1 + 1) % 1 * 0xffffff);
  const r = Math.max(40, (value >> 16) & 255);
  const g = Math.max(40, (value >> 8) & 255);
  const b = Math.max(40, value & 255);
  const color = (r << 16) | (g << 8) | b;
  robloxColorTable.set(id, color);
  return color;
}

function cloneAccessories(accessories){
  if(!Array.isArray(accessories)) return [];
  return accessories.map(acc=>({
    ...acc,
    offset: Array.isArray(acc?.offset) ? acc.offset.slice() : acc?.offset,
    rotation: Array.isArray(acc?.rotation) ? acc.rotation.slice() : acc?.rotation
  }));
}

const ROBLOX_COLOR_KEYWORDS = [
  {words:['black','noir','void','shadow','ebony','charcoal'], color:0x111111},
  {words:['white','pearl','ivory','snow'], color:0xf2f3f3},
  {words:['blue','azure','navy','indigo','cerulean'], color:0x1f4fa8},
  {words:['red','crimson','scarlet','ruby'], color:0xd7263d},
  {words:['green','emerald','forest','olive'], color:0x2f8f5b},
  {words:['yellow','gold','sun','lemon'], color:0xffd23c},
  {words:['orange','amber','pumpkin'], color:0xf26a1b},
  {words:['pink','rose','magenta'], color:0xf06292},
  {words:['purple','violet','amethyst','lavender'], color:0x7f51b5},
  {words:['brown','chocolate','umber','coffee'], color:0x5a3825},
  {words:['gray','grey','slate','ash','silver'], color:0x7f8c8d},
  {words:['teal','cyan','aqua'], color:0x1abc9c},
  {words:['lime','neon'], color:0xaef359},
  {words:['rainbow'], color:0xff6ff0}
];

function guessColorFromName(name, fallback){
  if(typeof name !== 'string') return fallback;
  const lower = name.toLowerCase();
  const hexMatch = lower.match(/#([0-9a-f]{6})/i);
  if(hexMatch){
    const parsed = parseInt(hexMatch[1], 16);
    if(!Number.isNaN(parsed)) return parsed;
  }
  for(const entry of ROBLOX_COLOR_KEYWORDS){
    if(entry.words.some(word=> lower.includes(word))){
      return entry.color;
    }
  }
  return fallback;
}

function shiftColor(color, factor){
  if(typeof color !== 'number' || !Number.isFinite(color)) return color;
  const clamp = v=> Math.max(0, Math.min(255, v));
  const r = clamp(Math.round(((color>>16)&255) * factor));
  const g = clamp(Math.round(((color>>8)&255) * factor));
  const b = clamp(Math.round((color&255) * factor));
  return (r<<16) | (g<<8) | b;
}

function combinePalettes(base, override){
  const result = {};
  if(base && typeof base === 'object'){
    for(const key in base){
      if(key === 'accessories') continue;
      if(Object.prototype.hasOwnProperty.call(base, key)){
        result[key] = base[key];
      }
    }
  }
  if(override && typeof override === 'object'){
    for(const key in override){
      if(key === 'accessories') continue;
      if(Object.prototype.hasOwnProperty.call(override, key) && override[key] !== undefined){
        result[key] = override[key];
      }
    }
  }
  return result;
}

async function fetchRobloxAvatar(userId){
  if(robloxAvatarCache.has(userId)) return robloxAvatarCache.get(userId);
  const promise = (async()=>{
    await ensureRobloxColorTable();
    if(typeof fetch !== 'function'){
      throw new Error('fetch unavailable');
    }
    const res = await fetch(`https://avatar.roblox.com/v1/users/${userId}/avatar`);
    if(!res || !res.ok){
      throw new Error(`Roblox avatar request failed (${res?.status})`);
    }
    return res.json();
  })();
  robloxAvatarCache.set(userId, promise);
  return promise;
}

function buildAppearanceFromAvatarData(data, fallback){
  const palette = combinePalettes(fallback, {});
  let accessories = [];
  const body = data?.bodyColors;
  if(body){
    if(body.headColorId !== undefined){
      palette.head = colorFromRobloxId(body.headColorId, palette.head);
      palette.skin = palette.skin ?? palette.head;
    }
    if(body.leftArmColorId !== undefined){
      palette.leftArm = colorFromRobloxId(body.leftArmColorId, palette.leftArm ?? palette.skin);
    }
    if(body.rightArmColorId !== undefined){
      palette.rightArm = colorFromRobloxId(body.rightArmColorId, palette.rightArm ?? palette.skin ?? palette.leftArm);
    }
    if(body.torsoColorId !== undefined){
      palette.torso = colorFromRobloxId(body.torsoColorId, palette.torso);
    }
    if(body.leftLegColorId !== undefined){
      const leg = colorFromRobloxId(body.leftLegColorId, palette.leftLeg ?? palette.legs);
      if(leg !== undefined) palette.leftLeg = leg;
    }
    if(body.rightLegColorId !== undefined){
      const leg = colorFromRobloxId(body.rightLegColorId, palette.rightLeg ?? palette.leftLeg ?? palette.legs);
      if(leg !== undefined) palette.rightLeg = leg;
    }
  }
  const assets = Array.isArray(data?.assets) ? data.assets : [];
  const findAsset = names=> assets.find(asset=> names.includes(asset?.assetType?.name));
  const shirt = findAsset(['Shirt','ShirtAccessory','Jacket','Sweater','TShirt']);
  if(shirt){
    const color = guessColorFromName(shirt.name, palette.torso);
    if(color !== undefined){
      palette.torso = color;
      palette.sleeve = shiftColor(color, 0.95);
      palette.torsoAccent = shiftColor(color, 1.12);
    }
  }
  const pants = findAsset(['Pants','PantsAccessory','Shorts','Skirt','DressSkirt']);
  if(pants){
    const color = guessColorFromName(pants.name, palette.leftLeg ?? palette.rightLeg ?? palette.legs);
    if(color !== undefined){
      palette.leftLeg = color;
      palette.rightLeg = color;
      palette.boots = shiftColor(color, 0.7);
    }
  }
  const face = findAsset(['Face']);
  if(face){
    const color = guessColorFromName(face.name, palette.eye ?? 0x1a1a1a);
    if(color !== undefined){
      palette.eye = color;
    }
  }
  const hairAssets = assets.filter(asset=> asset?.assetType?.name === 'HairAccessory');
  const hatAssets = assets.filter(asset=> asset?.assetType?.name === 'Hat');
  const backAsset = findAsset(['BackAccessory','FrontAccessory']);
  if(hairAssets.length){
    const hairColor = guessColorFromName(hairAssets[0].name, 0x312017);
    accessories.push({type:'hair', color:hairColor, offset:[0,0.34,0], radius:0.28, height:0.16});
  }
  if(hatAssets.length){
    hatAssets.slice(0,2).forEach((asset, idx)=>{
      const hatColor = guessColorFromName(asset.name, palette.torsoAccent ?? palette.torso ?? 0x3a3a3a);
      accessories.push({
        type: idx===0 ? 'cap' : 'hat',
        color: hatColor,
        offset: [0, 0.36 + idx*0.08, 0],
        brimRadius: 0.34,
        brimThickness: 0.05,
        height: 0.22,
        billLength: idx===0 ? 0.24 : undefined,
        billWidth: idx===0 ? 0.28 : undefined
      });
    });
  }
  if(backAsset){
    const packColor = guessColorFromName(backAsset.name, palette.shoulders ?? palette.secondary ?? 0x2f2f2f);
    accessories.push({type:'backpack', color:packColor});
  }
  if(accessories.length === 0 && Array.isArray(fallback?.accessories)){
    accessories = cloneAccessories(fallback.accessories);
  }
  return { palette, accessories };
}

function setMeshColor(mesh, color){
  if(!mesh || color === undefined || color === null) return;
  const applyColor = material=>{
    if(material && material.color){
      material.color.setHex(color);
    }
  };
  if(Array.isArray(mesh.material)){
    mesh.material.forEach(applyColor);
  } else {
    applyColor(mesh.material);
  }
}

function applyHumanoidPalette(root, palette={}){
  if(!root || !root.userData || !root.userData.humanoid) return;
  const humanoid = root.userData.humanoid;
  const parts = humanoid.parts || {};
  const detailNodes = humanoid.detailNodes || {};
  const applyGroup = (group, color)=>{
    if(!group || color === undefined || color === null) return;
    group.traverse(node=>{
      if(node.isMesh && node.material && node.material.color){
        node.material.color.setHex(color);
      }
    });
  };
  const skinColor = palette.skin ?? palette.head ?? 0xffd7c4;
  applyGroup(parts.head, palette.head ?? skinColor);
  applyGroup(parts.leftArm, palette.leftArm ?? skinColor);
  applyGroup(parts.rightArm, palette.rightArm ?? skinColor);
  applyGroup(parts.torso, palette.torso ?? palette.primary ?? 0x4f7bff);
  applyGroup(parts.leftLeg, palette.leftLeg ?? palette.legs ?? palette.secondary ?? 0x333333);
  applyGroup(parts.rightLeg, palette.rightLeg ?? palette.legs ?? palette.secondary ?? 0x333333);
  if(detailNodes.belt) setMeshColor(detailNodes.belt, palette.belt ?? palette.secondary ?? 0x1f2e6b);
  if(detailNodes.leftBoot) setMeshColor(detailNodes.leftBoot, palette.boots ?? palette.accent ?? 0xffffff);
  if(detailNodes.rightBoot) setMeshColor(detailNodes.rightBoot, palette.boots ?? palette.accent ?? 0xffffff);
  if(detailNodes.leftShoulder) setMeshColor(detailNodes.leftShoulder, palette.shoulders ?? palette.secondary ?? 0x1f2e6b);
  if(detailNodes.rightShoulder) setMeshColor(detailNodes.rightShoulder, palette.shoulders ?? palette.secondary ?? 0x1f2e6b);
  if(detailNodes.leftSleeve) setMeshColor(detailNodes.leftSleeve, palette.sleeve ?? palette.torso ?? palette.primary ?? 0x4f7bff);
  if(detailNodes.rightSleeve) setMeshColor(detailNodes.rightSleeve, palette.sleeve ?? palette.torso ?? palette.primary ?? 0x4f7bff);
  if(detailNodes.torsoOverlay) setMeshColor(detailNodes.torsoOverlay, palette.torsoAccent ?? palette.torso ?? palette.primary ?? 0x4f7bff);
  if(detailNodes.leftKnee) setMeshColor(detailNodes.leftKnee, palette.knee ?? palette.boots ?? palette.accent ?? 0xffffff);
  if(detailNodes.rightKnee) setMeshColor(detailNodes.rightKnee, palette.knee ?? palette.boots ?? palette.accent ?? 0xffffff);
  if(detailNodes.brow) setMeshColor(detailNodes.brow, palette.brow ?? palette.shoulders ?? 0x1e1e1e);
  if(detailNodes.leftEye) setMeshColor(detailNodes.leftEye, palette.eye ?? 0x1a1a1a);
  if(detailNodes.rightEye) setMeshColor(detailNodes.rightEye, palette.eye ?? 0x1a1a1a);
  root.userData.appliedPalette = {...palette, skin: skinColor};
  const callbacks = root.userData.onPaletteApplied;
  if(Array.isArray(callbacks)){
    callbacks.forEach(cb=>{
      try{ cb({...root.userData.appliedPalette}, root); }
      catch(err){ console.warn('Avatar palette callback failed', err); }
    });
  }
}

function clearHumanoidAccessories(root){
  if(!root || !root.userData) return;
  const existing = root.userData.accessoryGroups;
  if(Array.isArray(existing)){
    existing.forEach(group=>{
      if(group && group.parent){
        group.parent.remove(group);
      }
    });
  }
  root.userData.accessoryGroups = [];
}

function buildAccessoryGroup(def, humanoid){
  if(!def || !humanoid) return null;
  const targetName = def.attach || (def.type === 'backpack' ? 'torso' : 'head');
  const target = humanoid.parts?.[targetName];
  if(!target) return null;
  const group = new THREE.Group();
  group.name = `acc_${def.type || 'generic'}`;
  const color = def.color ?? 0x333333;
  const roughness = def.roughness ?? 0.55;
  const metalness = def.metalness ?? 0.08;
  const material = new THREE.MeshStandardMaterial({color, roughness, metalness});
  if(def.type === 'hair'){
    const radius = def.radius ?? 0.26;
    const geom = new THREE.SphereGeometry(radius, 18, 12, 0, Math.PI*2, 0, Math.PI/2);
    const mesh = new THREE.Mesh(geom, material);
    mesh.scale.set(def.scaleX ?? 1.08, def.scaleY ?? 0.75, def.scaleZ ?? 1.08);
    mesh.position.y = def.height ?? 0.14;
    group.add(mesh);
  } else if(def.type === 'cap' || def.type === 'hat'){
    const brimThickness = def.brimThickness ?? 0.04;
    const brimRadius = def.brimRadius ?? 0.34;
    const brimGeom = new THREE.CylinderGeometry(brimRadius, brimRadius, brimThickness, 20);
    const brimMesh = new THREE.Mesh(brimGeom, material.clone());
    brimMesh.position.y = 0;
    group.add(brimMesh);
    const topRadius = def.radius ?? 0.2;
    const topHeight = def.height ?? 0.22;
    const topGeom = new THREE.CylinderGeometry(topRadius, topRadius * (def.taper ?? 1), topHeight, 20);
    const topMesh = new THREE.Mesh(topGeom, material.clone());
    topMesh.position.y = brimThickness/2 + topHeight/2;
    group.add(topMesh);
    if(def.type === 'cap'){
      const billGeom = new THREE.BoxGeometry(def.billWidth ?? 0.28, def.billThickness ?? 0.04, def.billLength ?? 0.24);
      const billMesh = new THREE.Mesh(billGeom, material.clone());
      billMesh.position.set(0, brimThickness/2, (topRadius + (def.billLength ?? 0.24)/2) * 0.85);
      billMesh.rotation.x = -(def.billTilt ?? Math.PI/9);
      group.add(billMesh);
    }
  } else if(def.type === 'backpack'){
    const packGeom = new THREE.BoxGeometry(def.width ?? 0.38, def.height ?? 0.48, def.depth ?? 0.18);
    const packMesh = new THREE.Mesh(packGeom, material);
    packMesh.position.set(0, def.heightOffset ?? 0.2, -(def.depth ?? 0.18)/2 - 0.1);
    group.add(packMesh);
  } else if(def.geometry === 'box'){
    const geom = new THREE.BoxGeometry(def.sizeX ?? 0.2, def.sizeY ?? 0.2, def.sizeZ ?? 0.2);
    group.add(new THREE.Mesh(geom, material));
  }
  if(group.children.length === 0){
    const geom = new THREE.BoxGeometry(def.size ?? 0.18, def.size ?? 0.18, def.size ?? 0.18);
    group.add(new THREE.Mesh(geom, material));
  }
  if(def.rotation){
    const [rx=0, ry=0, rz=0] = def.rotation;
    group.rotation.set(rx, ry, rz);
  }
  if(def.offset){
    const [ox=0, oy=0, oz=0] = def.offset;
    group.position.set(ox, oy, oz);
  } else if(def.type === 'backpack'){
    group.position.set(0, 0.42, -0.05);
  } else {
    group.position.set(0, 0.32, 0);
  }
  target.add(group);
  return group;
}

let armRig = null;

let allowedWeaponIds = weaponConfigs.map(cfg=>cfg.id);
const weaponWheelState = {
  open: false,
  pointer: {x: innerWidth/2, y: innerHeight/2},
  selected: 0,
  options: weaponConfigs.filter(cfg=>allowedWeaponIds.includes(cfg.id)).map(cfg=>({id:cfg.id, label:cfg.label, desc:cfg.desc})),
  optionEls: [],
  centerEl: null
};
const shootState = {down:false, cooldown:0, mouseDown:false};
const weaponState = {charge:1, recharging:false, rechargeTimer:0, rechargeDuration:0, label:''};
const punchState = {cooldown:0, timer:0, hit:false, parryWindow:0};
const parryState = {
  flash: 0,
  flashDuration: 1,
  timeStop: 0,
  freezeTimer: 0,
  pendingReturns: []
};

function cloneTemplate(template){
  const clone = template.clone(true);
  clone.traverse(node=>{
    if(node.isMesh && node.material){
      if(Array.isArray(node.material)){
        node.material = node.material.map(mat=> mat && mat.clone ? mat.clone() : mat);
      } else {
        node.material = node.material.clone ? node.material.clone() : node.material;
      }
    }
  });
  const setup = (template.userData && typeof template.userData.setupClone === 'function') ? template.userData.setupClone : (clone.userData && typeof clone.userData.setupClone === 'function' ? clone.userData.setupClone : null);
  if(typeof setup === 'function'){
    setup(clone);
  }
  registerForAlexland(clone);
  return clone;
}

function createHumanoidTemplate(options={}){
  const { primary=0x6699ff, secondary=0x24355b, height=1.6, type='player' } = options;
  const root = new THREE.Group();
  const bodyMaterial = new THREE.MeshStandardMaterial({color:primary, roughness:0.7, metalness:0.1});
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), bodyMaterial);
  body.position.y = 0.4;
  body.name = 'cubeBody';
  root.add(body);

  const trimMaterial = new THREE.MeshStandardMaterial({color:secondary, roughness:0.6, metalness:0.08});
  const cap = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.2,0.6), trimMaterial);
  cap.position.y = 0.85;
  cap.name = 'cubeCap';
  root.add(cap);

  const faceMaterial = new THREE.MeshStandardMaterial({color:0xf2f2f2, emissive:0x222222, emissiveIntensity:0.3});
  const face = new THREE.Mesh(new THREE.PlaneGeometry(0.42,0.42), faceMaterial);
  face.position.set(0,0.42,0.41);
  face.name = 'cubeFace';
  root.add(face);

  const box = new THREE.Box3().setFromObject(root);
  const size = box.getSize(new THREE.Vector3());
  if(size.y > 0 && height){
    const scale = height / size.y;
    root.scale.setScalar(scale);
  }

  root.userData.cubeOptions = { primary, secondary, type, height };
  root.userData.setupClone = clone=>{
    const parts = {
      body: clone.getObjectByName('cubeBody'),
      cap: clone.getObjectByName('cubeCap'),
      face: clone.getObjectByName('cubeFace')
    };
    clone.userData.cubeParts = parts;
  };
  return root;
}

function createLowEnemyTemplate(){
  return createHumanoidTemplate({
    height:1.68,
    type:'enemy',
    primary:0xd04f4f,
    secondary:0x401919
  });
}

function createLowPlayerTemplate(){
  const primary = new THREE.Color(customCubeColorHex || '#4da6ff').getHex();
  return createHumanoidTemplate({
    height:1.7,
    type:'player',
    primary,
    secondary:0x24355b
  });
}

function updateHumanoidRig(root, anim={}, dt=0){
  if(!root) return;
  root.userData = root.userData || {};
  root.userData.cubeAnim = root.userData.cubeAnim || {phase: Math.random()*Math.PI*2};
  const state = root.userData.cubeAnim;
  state.phase += (dt || 0.016) * 3.5;
  const body = root.getObjectByName('cubeBody');
  if(body){
    body.position.y = 0.4 + Math.sin(state.phase) * 0.03;
  }
}

function prepareModelGroup(object, targetHeight=1){
  const group = new THREE.Group();
  group.add(object);
  object.traverse(node=>{
    if(node.isMesh && node.material){
      if(Array.isArray(node.material)){
        node.material = node.material.map(mat=> mat && mat.clone ? mat.clone() : mat);
      } else if(node.material.isMaterial && node.material.clone){
        node.material = node.material.clone();
      }
    }
  });
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  if(size.y > 0 && targetHeight){
    const scale = targetHeight / size.y;
    object.scale.multiplyScalar(scale);
  }
  const centeredBox = new THREE.Box3().setFromObject(object);
  const center = centeredBox.getCenter(new THREE.Vector3());
  object.position.sub(center);
  return group;
}

function loadObjWithMtl(objPath, mtlPath){
  return new Promise((resolve, reject)=>{
    const mtlLoader = new MTLLoader();
    const resolvePath = path=>{
      const idx = path.lastIndexOf('/');
      return idx >= 0 ? { dir: path.slice(0, idx + 1), file: path.slice(idx + 1) } : { dir: '', file: path };
    };
    const mtl = resolvePath(mtlPath);
    const obj = resolvePath(objPath);
    mtlLoader.setPath(mtl.dir || './');
    mtlLoader.setResourcePath(mtl.dir || obj.dir || './');
    mtlLoader.load(mtl.file, materials=>{
      materials.preload();
      const objLoader = new OBJLoader();
      objLoader.setMaterials(materials);
      objLoader.setPath(obj.dir || './');
      objLoader.setResourcePath(obj.dir || './');
      objLoader.load(obj.file, resolve, undefined, reject);
    }, undefined, reject);
  });
}

let highQuality = false;
let highQualityLoadPromise = null;
const enemyTemplates = { low: createLowEnemyTemplate(), high: null };
const playerTemplates = { low: createLowPlayerTemplate(), high: null };

async function ensureHighQualityModels(){
  if(enemyTemplates.high && playerTemplates.high) return;
  if(highQualityLoadPromise) return highQualityLoadPromise;
  highQualityLoadPromise = (async()=>{
    enemyTemplates.high = createHumanoidTemplate({ height:1.74, type:'enemy', primary:0xd04f4f, secondary:0x401919 });
    const primary = new THREE.Color(customCubeColorHex || '#4da6ff').getHex();
    playerTemplates.high = createHumanoidTemplate({ height:1.76, type:'player', primary, secondary:0x24355b });
  })().finally(()=>{ highQualityLoadPromise = null; });
  return highQualityLoadPromise;
}

function getActiveEnemyTemplate(){
  return (highQuality && enemyTemplates.high) ? enemyTemplates.high : enemyTemplates.low;
}

function getActivePlayerTemplate(){
  return (highQuality && playerTemplates.high) ? playerTemplates.high : playerTemplates.low;
}

function applyQualityTemplates(){
  if(alexMesh){
    while(alexMesh.children.length){ alexMesh.remove(alexMesh.children[0]); }
    const avatar = cloneTemplate(getActivePlayerTemplate());
    alexMesh.add(avatar);
    registerLocalAvatarPaletteSync(avatar);
  }
  if(enemyGroup){
    for(let i=0;i<enemies.length;i++){
      const enemy = enemies[i];
      if(!enemy) continue;
      const clone = cloneTemplate(getActiveEnemyTemplate());
      clone.position.copy(enemy.position);
      clone.quaternion.copy(enemy.quaternion);
      clone.userData = {...enemy.userData};
      tintEnemyMesh(clone, clone.userData.type);
      enemyGroup.remove(enemy);
      enemyGroup.add(clone);
      enemies[i] = clone;
    }
  }
  if(remotePlayers){
    for(const id in remotePlayers){
      const rp = remotePlayers[id];
      if(rp && rp.mesh){
        scene.remove(rp.mesh);
        rp.mesh = null;
      }
    }
  }
}

async function toggleHighQualityMode(){
  const targetState = !highQuality;
  if(targetState){
    try{
      await ensureHighQualityModels();
      highQuality = true;
    }catch(err){
      console.error('Unable to enable high quality mode', err);
      highQuality = false;
      return;
    }
  } else {
    highQuality = false;
  }
  applyQualityTemplates();
}

function buildWeaponWheel(){
  weaponWheelEl.innerHTML = '<div class="weapon-wheel-hint">Move the mouse to highlight a weapon</div>';
  weaponWheelState.optionEls = weaponWheelState.options.map((opt, idx)=>{
    const el = document.createElement('div');
    el.className = 'weapon-wheel-option';
    el.innerHTML = `<div><strong>${opt.label}</strong>${opt.desc ? `<span>${opt.desc}</span>` : ''}</div>`;
    el.dataset.index = idx;
    weaponWheelEl.appendChild(el);
    return el;
  });
  weaponWheelState.centerEl = document.createElement('div');
  weaponWheelState.centerEl.className = 'weapon-wheel-center';
  weaponWheelEl.appendChild(weaponWheelState.centerEl);
  positionWeaponWheelOptions();
  updateWeaponWheelHighlight();
}

function setAllowedWeapons(ids){
  const fallback = weaponConfigs.map(cfg=>cfg.id);
  const list = Array.isArray(ids) && ids.length ? ids.filter(id=>weaponConfigById.has(id)) : fallback;
  allowedWeaponIds = list.length ? list : fallback;
  weaponWheelState.options = weaponConfigs.filter(cfg=>allowedWeaponIds.includes(cfg.id)).map(cfg=>({id:cfg.id, label:cfg.label, desc:cfg.desc}));
  if(weaponWheelEl){
    buildWeaponWheel();
  }
  if(!allowedWeaponIds.includes(player.weapon)){
    equipWeapon(allowedWeaponIds[0], { immediate:true });
  }
}

function resetWeaponState(){
  weaponState.charge = 1;
  weaponState.recharging = false;
  weaponState.rechargeTimer = 0;
  weaponState.rechargeDuration = 0;
  weaponState.label = '';
  if(armRig && typeof armRig.endRecharge === 'function'){
    armRig.endRecharge();
  }
}

function triggerWeaponRecharge(cfg){
  const rechargeTime = cfg?.rechargeTime ?? 1.5;
  weaponState.recharging = true;
  weaponState.rechargeTimer = rechargeTime;
  weaponState.rechargeDuration = rechargeTime;
  weaponState.label = cfg?.rechargeLabel || 'Recharging';
  if(armRig && typeof armRig.beginRecharge === 'function'){
    armRig.beginRecharge(cfg);
  }
}

function positionWeaponWheelOptions(){
  const center = 130;
  const radius = 90;
  const total = weaponWheelState.options.length;
  weaponWheelState.optionEls.forEach((el, idx)=>{
    const angle = (idx/total) * Math.PI * 2 - Math.PI/2;
    const x = center + Math.cos(angle) * radius;
    const y = center + Math.sin(angle) * radius;
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
  });
}

function updateWeaponWheelPointer(x, y){
  weaponWheelState.pointer.x = Math.max(0, Math.min(innerWidth, x));
  weaponWheelState.pointer.y = Math.max(0, Math.min(innerHeight, y));
  updateWeaponWheelSelection();
}

function updateWeaponWheelHighlight(){
  weaponWheelState.optionEls.forEach((el, idx)=>{
    el.classList.toggle('active', idx === weaponWheelState.selected);
  });
  if(weaponWheelState.centerEl){
    const opt = weaponWheelState.options[weaponWheelState.selected];
    if(opt){
      weaponWheelState.centerEl.innerHTML = `<div>${opt.label}</div>${opt.desc ? `<span>${opt.desc}</span>` : ''}`;
    }
  }
}

function weaponWheelIsMultiplayer(){
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(ch && ch.readyState === 'open') return true;
  }
  return false;
}

function openWeaponWheel(){
  if(weaponWheelState.open) return;
  weaponWheelState.open = true;
  weaponWheelEl.classList.add('open');
  weaponWheelState.pointer = {x: innerWidth/2, y: innerHeight/2};
  const currentIndex = weaponWheelState.options.findIndex(opt=>opt.id === player.weapon);
  if(currentIndex >= 0) weaponWheelState.selected = currentIndex;
  const hint = weaponWheelEl.querySelector('.weapon-wheel-hint');
  if(hint){
    hint.textContent = weaponWheelIsMultiplayer() ? 'Multiplayer: slow motion disabled' : 'Move the mouse to highlight a weapon';
  }
  updateWeaponWheelHighlight();
}

function closeWeaponWheel(){
  if(!weaponWheelState.open) return;
  weaponWheelState.open = false;
  weaponWheelEl.classList.remove('open');
  const chosen = weaponWheelState.options[weaponWheelState.selected];
  if(chosen){
    equipWeapon(chosen.id);
  }
}

if(weaponWheelEl){
  weaponWheelEl.addEventListener('pointermove', e=>{
    if(!weaponWheelState.open) return;
    updateWeaponWheelPointer(e.clientX, e.clientY);
  });
  weaponWheelEl.addEventListener('pointerdown', e=>{
    if(!weaponWheelState.open) return;
    updateWeaponWheelPointer(e.clientX, e.clientY);
    e.preventDefault();
  });
}
window.addEventListener('pointermove', e=>{
  if(!weaponWheelState.open) return;
  if(e.pointerType === 'touch' || !isLocked){
    updateWeaponWheelPointer(e.clientX, e.clientY);
  }
});

function updateWeaponWheelSelection(){
  if(!weaponWheelState.open) return;
  const centerX = innerWidth/2;
  const centerY = innerHeight/2;
  const dx = weaponWheelState.pointer.x - centerX;
  const dy = weaponWheelState.pointer.y - centerY;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if(dist < 20){
    return;
  }
  const total = weaponWheelState.options.length;
  if(total === 0) return;
  let angle = Math.atan2(dy, dx);
  angle = (angle + Math.PI*2) % (Math.PI*2);
  const slice = (Math.PI*2) / total;
  const index = Math.floor((angle + slice/2) / slice) % total;
  if(index !== weaponWheelState.selected){
    weaponWheelState.selected = index;
    updateWeaponWheelHighlight();
  }
}

function equipWeapon(id, options={}){
  const cfg = weaponConfigById.get(id);
  if(!cfg) return;
  if(typeof player !== 'undefined'){
    player.weapon = id;
  }
  resetWeaponState();
  const idx = weaponWheelState.options.findIndex(opt=>opt.id===id);
  if(idx>=0){
    weaponWheelState.selected = idx;
    updateWeaponWheelHighlight();
  }
  if(armRig){
    armRig.setWeapon(id, options.immediate);
  }
  shootState.cooldown = 0;
}

function createArmRig(){
  const group = new THREE.Group();
  group.position.set(0, -0.12, 0.08);
  group.rotation.set(0, 0, 0);
  const baseGroupPosition = group.position.clone();

  const skinMaterial = new THREE.MeshStandardMaterial({color:0xffcaa6, roughness:0.55, metalness:0.1});
  const armGeometry = new THREE.CylinderGeometry(0.09, 0.12, 0.6, 14);
  armGeometry.translate(0, -0.3, 0);

  const left = new THREE.Group();
  const leftMesh = new THREE.Mesh(armGeometry, skinMaterial);
  left.add(leftMesh);

  const right = new THREE.Group();
  const rightMesh = new THREE.Mesh(armGeometry, skinMaterial.clone());
  right.add(rightMesh);
  const jugGroup = new THREE.Group();
  const jugMaterial = new THREE.MeshStandardMaterial({color:0x7fd2ff, transparent:true, opacity:0.65, roughness:0.35, metalness:0.25, emissive:0x1b3d6f, emissiveIntensity:0.2});
  const jugBody = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.13, 0.46, 16, 1, true), jugMaterial);
  jugBody.position.y = -0.18;
  jugGroup.add(jugBody);
  const jugCap = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.08, 12), new THREE.MeshStandardMaterial({color:0x2a5adf, roughness:0.2, metalness:0.35}));
  jugCap.position.y = 0.04;
  jugGroup.add(jugCap);
  jugGroup.visible = false;
  jugGroup.position.set(0.08, -0.08, -0.06);
  right.add(jugGroup);

  const weapon = new THREE.Group();
  const weaponGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1, 18);
  weaponGeometry.translate(0, -0.5, 0);
  const weaponMaterial = new THREE.MeshStandardMaterial({color:0xffff66, roughness:0.3, metalness:0.45, emissive:0x222200, emissiveIntensity:0.6});
  const weaponMesh = new THREE.Mesh(weaponGeometry, weaponMaterial);
  weaponMesh.rotation.x = Math.PI/2;
  weapon.add(weaponMesh);

  group.add(left);
  group.add(right);
  group.add(weapon);

  camera.add(group);
  registerForAlexland(group);

  const leftTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const rightTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const weaponTarget = {pos:new THREE.Vector3(), quat:new THREE.Quaternion()};
  const tempEuler = new THREE.Euler();

  function setTargetsForPose(pose){
    const safePose = pose || (weaponConfigs[0]?.poses.idle);
    if(safePose?.left){
      leftTarget.pos.set(safePose.left.pos[0], safePose.left.pos[1], safePose.left.pos[2]);
      tempEuler.set(safePose.left.rot[0], safePose.left.rot[1], safePose.left.rot[2], 'XYZ');
      leftTarget.quat.setFromEuler(tempEuler);
    }
    if(safePose?.right){
      rightTarget.pos.set(safePose.right.pos[0], safePose.right.pos[1], safePose.right.pos[2]);
      tempEuler.set(safePose.right.rot[0], safePose.right.rot[1], safePose.right.rot[2], 'XYZ');
      rightTarget.quat.setFromEuler(tempEuler);
    }
    if(safePose?.weapon){
      weaponTarget.pos.set(safePose.weapon.pos[0], safePose.weapon.pos[1], safePose.weapon.pos[2]);
      tempEuler.set(safePose.weapon.rot[0], safePose.weapon.rot[1], safePose.weapon.rot[2], 'XYZ');
      weaponTarget.quat.setFromEuler(tempEuler);
    }
  }

  const rig = {
    group,
    left,
    right,
    weapon,
    weaponMesh,
    weaponMaterial,
    hydrationJug: jugGroup,
    weaponId: 1,
    fireTimer: 0,
    fireTimerTotal: 0,
    time: 0,
    rechargeTime: 0,
    skinMaterials: [leftMesh.material, rightMesh.material],
    recharging: false,
    rechargeCfg: null,
    setWeapon(id, immediate){
      if(!weaponConfigById.has(id)) return;
      this.weaponId = id;
      this.time = 0;
      this.fireTimer = 0;
      this.fireTimerTotal = 0;
      this.weapon.visible = true;
      if(this.hydrationJug){ this.hydrationJug.visible = false; }
      const cfg = weaponConfigById.get(id) || weaponConfigs[0];
      const appearance = cfg.appearance || weaponConfigs[0].appearance;
      if(appearance){
        if(appearance.color !== undefined) this.weaponMaterial.color.setHex(appearance.color);
        if(appearance.emissive !== undefined) this.weaponMaterial.emissive.setHex(appearance.emissive);
        if(appearance.emissiveIntensity !== undefined) this.weaponMaterial.emissiveIntensity = appearance.emissiveIntensity;
        if(appearance.thickness !== undefined){
          weaponMesh.scale.x = appearance.thickness;
          weaponMesh.scale.z = appearance.thickness;
        }
        if(appearance.length !== undefined){
          weaponMesh.scale.y = appearance.length;
        }
      }
      this.applyPose('idle', immediate);
    },
    applyPose(poseName, immediate){
      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      const pose = (cfg.poses && cfg.poses[poseName]) || (cfg.poses && cfg.poses.idle) || weaponConfigs[0].poses.idle;
      setTargetsForPose(pose);
      if(immediate){
        left.position.copy(leftTarget.pos);
        left.quaternion.copy(leftTarget.quat);
        right.position.copy(rightTarget.pos);
        right.quaternion.copy(rightTarget.quat);
        weapon.position.copy(weaponTarget.pos);
        weapon.quaternion.copy(weaponTarget.quat);
      }
    },
    triggerFire(){
      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      this.fireTimer = cfg?.firePoseDuration ?? 0.15;
      this.fireTimerTotal = this.fireTimer;
      this.applyPose('fire');
    },
    beginRecharge(cfg){
      this.recharging = true;
      this.rechargeCfg = cfg || weaponConfigById.get(this.weaponId);
      this.rechargeTime = 0;
      const rechargeType = this.rechargeCfg?.type;
      if(rechargeType === 'pee'){
        this.weapon.visible = false;
        if(this.hydrationJug) this.hydrationJug.visible = true;
      } else {
        this.weapon.visible = true;
        if(this.hydrationJug) this.hydrationJug.visible = false;
      }
      this.applyPose('recharge');
    },
    endRecharge(){
      this.recharging = false;
      this.rechargeCfg = null;
      this.rechargeTime = 0;
      this.weapon.visible = true;
      if(this.hydrationJug) this.hydrationJug.visible = false;
      this.applyPose('idle');
    },
    update(dt){
      if(typeof player !== 'undefined'){
        group.visible = !player.thirdPerson;
      }
      this.time += dt;
      if(this.recharging){
        this.rechargeTime += dt;
      } else if(this.rechargeTime !== 0){
        this.rechargeTime = 0;
      }
      const lerpAlpha = Math.max(0, Math.min(1, dt * 12));
      left.position.lerp(leftTarget.pos, lerpAlpha);
      left.quaternion.slerp(leftTarget.quat, lerpAlpha);
      right.position.lerp(rightTarget.pos, lerpAlpha);
      right.quaternion.slerp(rightTarget.quat, lerpAlpha);
      weapon.position.lerp(weaponTarget.pos, lerpAlpha);
      weapon.quaternion.slerp(weaponTarget.quat, lerpAlpha);

      const cfg = weaponConfigById.get(this.weaponId) || weaponConfigs[0];
      const swayCfg = cfg?.sway || {};
      const swaySpeed = swayCfg.speed ?? 3.5;
      const swayAmount = swayCfg.amplitude ?? 0.01;
      const tiltAmount = swayCfg.tilt ?? 0.02;
      const fireInfluence = this.fireTimer > 0 && this.fireTimerTotal > 0 ? Math.max(0.3, this.fireTimer / this.fireTimerTotal) : 1;
      group.position.set(baseGroupPosition.x, baseGroupPosition.y + Math.sin(this.time * swaySpeed) * swayAmount * fireInfluence, baseGroupPosition.z);
      group.rotation.set(0, 0, Math.cos(this.time * swaySpeed * 0.5) * tiltAmount * fireInfluence);
      if(this.fireTimer <= 0){
        const bob = Math.sin(this.time * swaySpeed * 1.4) * swayAmount * 0.6;
        left.position.y += bob;
        right.position.y += bob;
        weapon.position.y += bob * 0.6;
      }

      if(this.fireTimer > 0){
        this.fireTimer -= dt;
        if(this.fireTimer <= 0){
          this.applyPose('idle');
        }
      }
      if(this.recharging){
        const lift = 0.02 + Math.sin(this.time * 3) * 0.01;
        if(this.rechargeCfg && this.rechargeCfg.type === 'pee'){
          if(this.hydrationJug){
            this.hydrationJug.rotation.x = -0.45 + Math.sin(this.time * 2.6) * 0.16;
            this.hydrationJug.rotation.y = Math.sin(this.time * 3.4) * 0.08;
          }
          left.position.y += lift * 0.2;
          right.position.y += lift * 0.3;
        } else {
          weapon.position.y += lift;
          left.position.y += lift * 0.6;
          right.position.y += lift * 0.6;
          weapon.rotation.z = Math.sin(this.time * 2.8) * 0.06;
        }
      } else if(this.hydrationJug){
        this.hydrationJug.rotation.set(0,0,0);
      }
    }
  };

  rig.applyPose('idle', true);
  return rig;
}

function updateArmRigWithPalette(palette){
  if(!armRig) return;
  const color = new THREE.Color(customCubeColorHex || '#4da6ff');
  if(Array.isArray(armRig.skinMaterials)){
    armRig.skinMaterials.forEach(mat=>{
      if(mat && mat.color){
        mat.color.copy(color);
      }
    });
  }
  if(armRig.group){
    refreshAlexlandBaseline(armRig.group);
  }
}

function registerLocalAvatarPaletteSync(avatar){
  if(!avatar) return;
  applyColorToPlayerMesh(customCubeColorHex);
  updateArmRigWithPalette();
}

buildWeaponWheel();

/* Player */
const player = {
  pos: new THREE.Vector3(0,0.5,0),
  velocity: new THREE.Vector3(),
  speed: 4.6,
  height: 1.6,
  radius: 0.45,
  gravity: 9.8,
  yaw: 0,
  pitch: 0,
  hp: 3,
  alive: true,
  thirdPerson: false,
  weapon: 1,
  jumpSpeed: 5.5,
  grounded: true,
  groundHeight: 0.5,
  coyoteTimer: 0,
  wallNormal: new THREE.Vector3(),
  wallTouchTimer: 0,
  isSliding: false,
  slideTimer: 0,
  slideCooldown: 0,
  slideDirection: new THREE.Vector3(),
  maxJumpCharges: 2,
  airJumpsRemaining: 1,
  dashTimer: 0,
  dashCooldown: 0,
  dashVector: new THREE.Vector3(),
  climbing: false,
  climbTimer: 0,
  climbSpeed: 3.6,
  anim: { mode:'idle', speed:0, variant:0 },
  id: Math.random().toString(36).slice(2,9),
  name: 'me',
  parryFrozen: false,
  stealthTimer: 0,
  parryActive: false
};
setPlayerDisplayName(nameInput?.value || player.name || 'Player', { persist: false });

function applyColorToPlayerMesh(hex){
  if(!alexMesh) return;
  const color = new THREE.Color(hex || '#01c119');
  const accent = color.clone().offsetHSL(0, 0, -0.2);
  alexMesh.traverse(node=>{
    if(node.isMesh && node.material && node.material.color){
      const name = (node.name || '');
      if(name === 'cubeCap'){
        node.material.color.copy(accent);
      } else if(name === 'cubeBody' || name === 'cubeFace'){
        node.material.color.copy(color);
      }
    }
  });
  refreshAlexlandBaseline(alexMesh);
  updateArmRigWithPalette();
}

const alexMesh = new THREE.Group();
scene.add(alexMesh);
alexMesh.add(cloneTemplate(getActivePlayerTemplate()));
armRig = createArmRig();
registerLocalAvatarPaletteSync(alexMesh.children[0]);
equipWeapon(player.weapon, {immediate:true});
applyColorToPlayerMesh(customCubeColorHex);

/* Controls */
let keys = {};
window.addEventListener('keydown', e=>{
  if(e.code === 'Escape'){
    e.preventDefault();
    if(pauseMenuEl && pauseMenuEl.style.display !== 'none'){
      closePauseMenu();
    } else if(mainMenuEl && mainMenuEl.style.display !== 'none'){
      showPlayIntro();
    } else {
      openPauseMenu();
    }
    return;
  }
  keys[e.code]=true;
  updateKeyboardState();
  if(e.code==='KeyY') player.thirdPerson = !player.thirdPerson;
  if(e.code==='KeyH' && !e.repeat){ toggleHighQualityMode(); }
  if(e.code==='Space' && !e.repeat){ attemptJump(); }
  if(!e.repeat && (e.code==='ControlLeft' || e.code==='ControlRight' || e.code==='KeyX')){
    triggerDash();
  }
  if(e.code==='KeyF' && !e.repeat){
    triggerPunch();
  }
  if(e.code.startsWith('Digit')){
    const digit = parseInt(e.code.slice(5), 10);
    if(!Number.isNaN(digit)){
      equipWeapon(digit);
    }
  }
  if(e.code==='KeyQ' && !e.repeat){ openWeaponWheel(); }
});
window.addEventListener('keyup', e=>{
  keys[e.code]=false;
  updateKeyboardState();
  if(e.code==='KeyQ'){ closeWeaponWheel(); }
  if(e.code==='ShiftLeft' || e.code==='ShiftRight'){
    if(player.isSliding && (!keys['ShiftLeft'] && !keys['ShiftRight'])){
      player.isSliding = false;
    }
  }
});
function updateKeyboardState(){
  keyboardState.moveX = 0;
  keyboardState.moveY = 0;
  if(keys['KeyA'] || keys['ArrowLeft']) keyboardState.moveX -= 1;
  if(keys['KeyD'] || keys['ArrowRight']) keyboardState.moveX += 1;
  if(keys['KeyW'] || keys['ArrowUp']) keyboardState.moveY += 1;
  if(keys['KeyS'] || keys['ArrowDown']) keyboardState.moveY -= 1;
  const len = Math.hypot(keyboardState.moveX, keyboardState.moveY);
  if(len > 1){
    keyboardState.moveX /= len;
    keyboardState.moveY /= len;
  }
  keyboardState.jumpHeld = !!keys['Space'];
  keyboardState.slideHeld = !!(keys['ShiftLeft'] || keys['ShiftRight']);
  keyboardState.dashHeld = !!(keys['ControlLeft'] || keys['ControlRight'] || keys['KeyX']);
  keyboardState.wheelHeld = !!keys['KeyQ'];
}
updateKeyboardState();
let isLocked = false;
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
document.addEventListener('pointerlockchange', ()=>{
  isLocked = (document.pointerLockElement === renderer.domElement);
  if(!isLocked){
    shootState.down = false;
    shootState.mouseDown = false;
  }
});
document.addEventListener('mousemove', e=>{
  if(weaponWheelState.open){
    if(isLocked){
      weaponWheelState.pointer.x = Math.max(0, Math.min(innerWidth, weaponWheelState.pointer.x + e.movementX));
      weaponWheelState.pointer.y = Math.max(0, Math.min(innerHeight, weaponWheelState.pointer.y + e.movementY));
    } else {
      weaponWheelState.pointer.x = e.clientX;
      weaponWheelState.pointer.y = e.clientY;
    }
    updateWeaponWheelSelection();
    return;
  }
  if(!isLocked) return;
  player.yaw -= e.movementX*0.002;
  player.pitch -= e.movementY*0.002;
  player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));
});

const coarsePointer = window.matchMedia ? window.matchMedia('(hover: none) and (pointer: coarse)') : null;
function refreshTouchControls(){
  if(!touchControlsEl) return;
  const show = coarsePointer ? coarsePointer.matches : false;
  touchControlsEl.classList.toggle('active', show);
}
if(coarsePointer && coarsePointer.addEventListener){
  coarsePointer.addEventListener('change', refreshTouchControls);
}
refreshTouchControls();

const TOUCH_RADIUS = 70;
function resetMoveVisual(){
  if(touchMoveEl){
    touchMoveEl.style.setProperty('--jx', '0px');
    touchMoveEl.style.setProperty('--jy', '0px');
  }
}
function startMoveJoystick(touch){
  touchState.moveId = touch.identifier;
  touchState.moveStart = {x: touch.clientX, y: touch.clientY};
  touchState.moveOffset.set(0,0);
  resetMoveVisual();
}
function updateMoveJoystick(touch){
  if(!touchState.moveStart) return;
  const dx = touch.clientX - touchState.moveStart.x;
  const dy = touch.clientY - touchState.moveStart.y;
  const dist = Math.hypot(dx, dy);
  const limit = TOUCH_RADIUS;
  const scale = dist > limit ? (limit / dist) : 1;
  const pxX = dx * scale;
  const pxY = dy * scale;
  const normX = pxX / limit;
  const normY = pxY / limit;
  touchState.moveOffset.set(normX, -normY);
  if(touchMoveEl){
    touchMoveEl.style.setProperty('--jx', `${pxX}px`);
    touchMoveEl.style.setProperty('--jy', `${-pxY}px`);
  }
}
function endMoveJoystick(){
  touchState.moveId = null;
  touchState.moveStart = null;
  touchState.moveOffset.set(0,0);
  resetMoveVisual();
}
function startLookDrag(touch){
  touchState.lookId = touch.identifier;
  touchState.lookLast = {x: touch.clientX, y: touch.clientY};
  if(weaponWheelState.open){
    updateWeaponWheelPointer(touch.clientX, touch.clientY);
  }
}
function updateLookDrag(touch){
  if(touchState.lookId !== touch.identifier || !touchState.lookLast) return;
  const dx = touch.clientX - touchState.lookLast.x;
  const dy = touch.clientY - touchState.lookLast.y;
  touchState.lookLast.x = touch.clientX;
  touchState.lookLast.y = touch.clientY;
  const sensitivity = 0.0045;
  touchState.lookOffset.x += dx * sensitivity;
  touchState.lookOffset.y += dy * sensitivity;
  if(weaponWheelState.open){
    updateWeaponWheelPointer(touch.clientX, touch.clientY);
  }
}
function endLookDrag(touch){
  if(touchState.lookId === touch.identifier){
    touchState.lookId = null;
    touchState.lookLast = null;
  }
}
function handleMoveStart(event){
  const touches = Array.from(event.changedTouches || []);
  let handled = false;
  for(const touch of touches){
    if(touchState.moveId === null){
      startMoveJoystick(touch);
      handled = true;
      break;
    }
  }
  if(handled){ event.preventDefault(); }
}
function handleMoveMove(event){
  const touches = Array.from(event.changedTouches || []);
  let handled = false;
  for(const touch of touches){
    if(touch.identifier === touchState.moveId){
      updateMoveJoystick(touch);
      handled = true;
    }
  }
  if(handled){ event.preventDefault(); }
}
function handleMoveEnd(event){
  const touches = Array.from(event.changedTouches || []);
  let handled = false;
  for(const touch of touches){
    if(touch.identifier === touchState.moveId){
      endMoveJoystick();
      handled = true;
    }
  }
  if(handled){ event.preventDefault(); }
}
function shouldIgnoreLookTouch(touch){
  const element = document.elementFromPoint(touch.clientX, touch.clientY);
  if(!element) return false;
  if(element.closest('#touchMove')) return true;
  if(element.closest('.touch-button')) return true;
  if(element.closest('#network')) return true;
  if(element.closest('.menu-panel')) return true;
  return false;
}
function handleLookStart(event){
  const touches = Array.from(event.changedTouches || []);
  let handled = false;
  for(const touch of touches){
    if(touchState.lookId === null && !shouldIgnoreLookTouch(touch)){
      startLookDrag(touch);
      handled = true;
    }
  }
  if(handled){ event.preventDefault(); }
}
function handleLookMove(event){
  const touches = Array.from(event.changedTouches || []);
  let handled = false;
  for(const touch of touches){
    if(touch.identifier === touchState.lookId){
      updateLookDrag(touch);
      handled = true;
    }
  }
  if(handled){ event.preventDefault(); }
}
function handleLookEnd(event){
  const touches = Array.from(event.changedTouches || []);
  let handled = false;
  for(const touch of touches){
    if(touch.identifier === touchState.lookId){
      endLookDrag(touch);
      handled = true;
    }
  }
  if(handled){ event.preventDefault(); }
}
if(touchMoveEl){
  touchMoveEl.addEventListener('touchstart', handleMoveStart, {passive:false});
  touchMoveEl.addEventListener('touchmove', handleMoveMove, {passive:false});
  touchMoveEl.addEventListener('touchend', handleMoveEnd, {passive:false});
  touchMoveEl.addEventListener('touchcancel', handleMoveEnd, {passive:false});
}
window.addEventListener('touchstart', handleLookStart, {passive:false});
window.addEventListener('touchmove', handleLookMove, {passive:false});
window.addEventListener('touchend', handleLookEnd, {passive:false});
window.addEventListener('touchcancel', handleLookEnd, {passive:false});
if(touchControlsEl){
  touchControlsEl.addEventListener('contextmenu', e=> e.preventDefault());
}

function setTouchButtonState(action, pressed, el){
  if(el){ el.classList.toggle('active', pressed); }
  switch(action){
    case 'jump': touchState.jump = pressed; break;
    case 'dash': touchState.dash = pressed; break;
    case 'slide': touchState.slide = pressed; break;
    case 'wheel': touchState.wheel = pressed; break;
    case 'shoot': touchState.fire = pressed; break;
    case 'punch':
      touchState.punch = pressed;
      if(pressed){ triggerPunch(); }
      break;
  }
}
touchButtons.forEach(btn=>{
  const action = btn.dataset.action;
  if(!action) return;
  btn.addEventListener('touchstart', e=>{ setTouchButtonState(action, true, btn); e.preventDefault(); });
  btn.addEventListener('touchend', e=>{ setTouchButtonState(action, false, btn); e.preventDefault(); });
  btn.addEventListener('touchcancel', e=>{ setTouchButtonState(action, false, btn); e.preventDefault(); });
});

function updateTouchFlags(){
  touchState.justJumped = touchState.jump && !touchState.prevJump;
  touchState.justDashed = touchState.dash && !touchState.prevDash;
  touchState.justSlid = touchState.slide && !touchState.prevSlide;
  touchState.justWheel = touchState.wheel && !touchState.prevWheel;
  touchState.justFired = touchState.fire && !touchState.prevFire;
  touchState.prevJump = touchState.jump;
  touchState.prevDash = touchState.dash;
  touchState.prevSlide = touchState.slide;
  touchState.prevWheel = touchState.wheel;
  touchState.prevFire = touchState.fire;
  touchState.justPunched = touchState.punch && !touchState.prevPunch;
  touchState.prevPunch = touchState.punch;
}

function applyDeadZone(value, threshold=0.18){
  return Math.abs(value) < threshold ? 0 : value;
}
function pollGamepads(){
  const pads = (typeof navigator !== 'undefined' && navigator.getGamepads) ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
  if(!pads.length){
    if(gamepadState.connected){
      gamepadState.connected = false;
      gamepadState.moveX = 0;
      gamepadState.moveY = 0;
      gamepadState.lookX = 0;
      gamepadState.lookY = 0;
      gamepadState.jump = false;
      gamepadState.dash = false;
      gamepadState.slide = false;
      gamepadState.wheel = false;
      gamepadState.fire = false;
      gamepadState.viewToggle = false;
      gamepadState.justJumped = false;
      gamepadState.justDashed = false;
      gamepadState.justSlid = false;
      gamepadState.justWheel = false;
      gamepadState.justFire = false;
      gamepadState.justToggledView = false;
      gamepadState.prevJump = false;
      gamepadState.prevDash = false;
      gamepadState.prevSlide = false;
      gamepadState.prevWheel = false;
      gamepadState.prevFire = false;
      gamepadState.prevViewToggle = false;
    }
    return;
  }
  const pad = pads[0];
  gamepadState.connected = true;
  gamepadState.moveX = applyDeadZone(pad.axes?.[0] ?? 0);
  gamepadState.moveY = -applyDeadZone(pad.axes?.[1] ?? 0);
  gamepadState.lookX = applyDeadZone(pad.axes?.[2] ?? 0, 0.12);
  gamepadState.lookY = -applyDeadZone(pad.axes?.[3] ?? 0, 0.12);
  const buttons = pad.buttons || [];
  const pressed = idx=> !!(buttons[idx] && (buttons[idx].pressed || buttons[idx].value > 0.5));
  const jump = pressed(0);
  const slide = pressed(1);
  const dash = pressed(2);
  const view = pressed(3);
  const wheel = pressed(6);
  const fire = pressed(7) || pressed(5);
  gamepadState.justJumped = jump && !gamepadState.prevJump;
  gamepadState.justSlid = slide && !gamepadState.prevSlide;
  gamepadState.justDashed = dash && !gamepadState.prevDash;
  gamepadState.justWheel = wheel && !gamepadState.prevWheel;
  gamepadState.justFire = fire && !gamepadState.prevFire;
  gamepadState.justToggledView = view && !gamepadState.prevViewToggle;
  gamepadState.prevJump = jump;
  gamepadState.prevSlide = slide;
  gamepadState.prevDash = dash;
  gamepadState.prevWheel = wheel;
  gamepadState.prevFire = fire;
  gamepadState.prevViewToggle = view;
  gamepadState.jump = jump;
  gamepadState.slide = slide;
  gamepadState.dash = dash;
  gamepadState.wheel = wheel;
  gamepadState.fire = fire;
  gamepadState.viewToggle = view;
}

function updateAggregatedInput(dt){
  pollGamepads();
  updateTouchFlags();

  const moveX = keyboardState.moveX + gamepadState.moveX + touchState.moveOffset.x;
  const moveY = keyboardState.moveY + gamepadState.moveY + touchState.moveOffset.y;
  let mx = moveX;
  let my = moveY;
  const len = Math.hypot(mx, my);
  if(len > 1){ mx /= len; my /= len; }
  aggregatedInput.move.set(mx, my);

  aggregatedInput.jumpHeld = keyboardState.jumpHeld || gamepadState.jump || touchState.jump;
  aggregatedInput.jumpPressed = gamepadState.justJumped || touchState.justJumped;

  const slideHeld = keyboardState.slideHeld || gamepadState.slide || touchState.slide;
  aggregatedInput.slideHeld = slideHeld;
  aggregatedInput.slidePressed = (!aggregatedInput.prevSlideHeld && slideHeld) || gamepadState.justSlid || touchState.justSlid;
  aggregatedInput.prevSlideHeld = slideHeld;

  aggregatedInput.dashPressed = gamepadState.justDashed || touchState.justDashed;

  const wheelHeld = gamepadState.wheel || touchState.wheel || keyboardState.wheelHeld;
  aggregatedInput.wheelHeld = wheelHeld;
  aggregatedInput.wheelPressed = (!aggregatedInput.prevWheelHeld && wheelHeld) || gamepadState.justWheel || touchState.justWheel;
  aggregatedInput.prevWheelHeld = wheelHeld;

  aggregatedInput.fireHeld = shootState.mouseDown || gamepadState.fire || touchState.fire;
  aggregatedInput.firePressed = gamepadState.justFire || touchState.justFired;

  if(aggregatedInput.firePressed && !weaponWheelState.open){
    shoot();
  }
  shootState.down = aggregatedInput.fireHeld;

  if((gamepadState.justJumped || touchState.justJumped) && !weaponWheelState.open){
    attemptJump();
  }
  if(aggregatedInput.dashPressed && !weaponWheelState.open){
    triggerDash();
  }

  if(aggregatedInput.wheelPressed && !weaponWheelState.open && !keys['KeyQ']){
    openWeaponWheel();
  }
  if(weaponWheelState.open && !aggregatedInput.wheelHeld && !keys['KeyQ']){
    closeWeaponWheel();
  }

  if(player.parryFrozen){
    aggregatedInput.move.set(0,0);
    aggregatedInput.jumpHeld = false;
    aggregatedInput.jumpPressed = false;
    aggregatedInput.slideHeld = false;
    aggregatedInput.slidePressed = false;
    aggregatedInput.dashPressed = false;
    aggregatedInput.wheelHeld = false;
    aggregatedInput.wheelPressed = false;
    aggregatedInput.fireHeld = false;
    aggregatedInput.firePressed = false;
    shootState.down = false;
  }

  const lookPadSpeed = 2.6;
  if(!weaponWheelState.open){
    player.yaw -= gamepadState.lookX * lookPadSpeed * dt;
    player.pitch -= gamepadState.lookY * lookPadSpeed * dt;
    player.yaw -= touchState.lookOffset.x;
    player.pitch -= touchState.lookOffset.y;
  } else {
    if(Math.abs(gamepadState.lookX) > 0.05 || Math.abs(gamepadState.lookY) > 0.05){
      const scale = 80;
      updateWeaponWheelPointer(
        weaponWheelState.pointer.x + gamepadState.lookX * scale,
        weaponWheelState.pointer.y + gamepadState.lookY * scale
      );
    }
  }
  touchState.lookOffset.set(0,0);
  player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));

  if(gamepadState.justToggledView){
    player.thirdPerson = !player.thirdPerson;
  }
}

function attemptJump(){
  if(player.parryFrozen) return false;
  if(weaponWheelState.open) return false;
  const canGroundJump = player.grounded || player.coyoteTimer > 0;
  if(canGroundJump){
    player.velocity.y = player.jumpSpeed;
    player.grounded = false;
    player.coyoteTimer = 0;
    player.isSliding = false;
    player.slideTimer = 0;
    player.climbing = false;
    player.climbTimer = 0;
    player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    player.dashTimer = 0;
    return true;
  }
  if(player.climbing){
    player.velocity.y = player.jumpSpeed * 1.05;
    if(player.wallNormal.lengthSq()>0){
      player.velocity.addScaledVector(player.wallNormal.clone().negate(), player.speed * 0.6);
    }
    player.climbing = false;
    player.climbTimer = 0;
    player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    return true;
  }
  if(player.wallTouchTimer > 0 && player.wallNormal.lengthSq()>0){
    player.velocity.y = player.jumpSpeed * 1.05;
    player.velocity.addScaledVector(player.wallNormal, player.speed * 2.2);
    player.wallTouchTimer = 0;
    player.isSliding = false;
    player.slideTimer = 0;
    player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    return true;
  }
  if(player.airJumpsRemaining > 0){
    player.velocity.y = player.jumpSpeed * 0.92;
    player.airJumpsRemaining -= 1;
    player.isSliding = false;
    player.slideTimer = 0;
    player.dashTimer = 0;
    player.dashVector.set(0,0,0);
    return true;
  }
  return false;
}

function triggerDash(direction){
  if(player.parryFrozen) return false;
  if(weaponWheelState.open) return false;
  if(player.dashTimer > 0 || player.dashCooldown > 0.05) return false;
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));
  const inputDir = direction ? direction.clone() : new THREE.Vector3();
  if(!direction){
    const move = aggregatedInput.move.clone();
    if(move.lengthSq() > 0){
      inputDir.addScaledVector(forward, move.y);
      inputDir.addScaledVector(right, move.x);
    } else {
      inputDir.copy(forward);
    }
  }
  if(inputDir.lengthSq() === 0) return false;
  inputDir.normalize();
  player.dashVector.copy(inputDir);
  player.dashTimer = 0.24;
  player.dashCooldown = 0.7;
  player.isSliding = false;
  player.slideTimer = 0;
  return true;
}

function attemptPunchHit(){
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  let hit = false;
  for(let i=enemies.length-1;i>=0;i--){
    const enemy = enemies[i];
    if(!enemy) continue;
    punchScratch.copy(enemy.position).sub(player.pos);
    const dist = punchScratch.length();
    if(dist > 1.8) continue;
    punchScratch.y = 0;
    if(punchScratch.lengthSq() === 0) continue;
    punchScratch.normalize();
    if(forward.dot(punchScratch) < 0.25) continue;
    if(damageEnemyAtIndex(i, 3)){
      hit = true;
    } else {
      scareEnemy(enemy);
      hit = true;
    }
  }
  if(hit){
    playSound('hit', {pitch:1.4});
  }
  return hit;
}

function triggerPunch(){
  if(player.parryFrozen) return false;
  if(weaponWheelState.open || punchState.cooldown > 0) return false;
  punchState.cooldown = 0.55;
  punchState.timer = 0.18;
  punchState.hit = false;
  punchState.parryWindow = 0.25;
  player.parryActive = true;
  playSound('punch');
  if(armRig) armRig.triggerFire();
  return true;
}

function updatePunch(dt){
  if(punchState.cooldown > 0){
    punchState.cooldown = Math.max(0, punchState.cooldown - dt);
  }
  if(punchState.timer > 0){
    punchState.timer -= dt;
    if(!punchState.hit){
      if(attemptPunchHit()){
        punchState.hit = true;
      }
    }
  }
  if(punchState.parryWindow > 0){
    punchState.parryWindow = Math.max(0, punchState.parryWindow - dt);
    if(punchState.parryWindow <= 0){
      player.parryActive = false;
    }
  }
}

/* Enemies & bullets */
const enemies=[]; const enemyGroup = new THREE.Group(); scene.add(enemyGroup);
const waveState = { current:0, active:false, killTarget:0, kills:0, pendingSpawns:0, spawnTimer:0, spawnInterval:2.4, spawnedGiant:false };
let waveBannerTimeout = null;
let nextWaveTimeout = null;

function waveTargetCount(wave){
  if(wave <= 1) return 5;
  if(wave <= 5) return 5 + (wave-1)*5;
  return 25 + (wave - 5);
}

function showWaveAnnouncement(text, duration=1800){
  if(!waveBannerEl) return;
  waveBannerEl.textContent = text;
  waveBannerEl.classList.add('show');
  if(waveBannerTimeout){ clearTimeout(waveBannerTimeout); }
  waveBannerTimeout = setTimeout(()=> waveBannerEl.classList.remove('show'), duration);
}

function startNextWave(fromMenu=false){
  if(activeGameOptions.mode !== 'classic') return;
  if(nextWaveTimeout){ clearTimeout(nextWaveTimeout); nextWaveTimeout = null; }
  waveState.current += 1;
  waveState.active = true;
  waveState.kills = 0;
  waveState.spawnedGiant = false;
  waveState.killTarget = waveTargetCount(waveState.current);
  waveState.pendingSpawns = waveState.killTarget;
  waveState.spawnInterval = Math.max(1.0, 2.6 - waveState.current * 0.18);
  waveState.spawnTimer = fromMenu ? 0.25 : 1.0;
  if(fromMenu){
    player.hp = 3;
    player.alive = true;
  }
  showWaveAnnouncement(`Wave ${waveState.current}`);
  playSound('wave');
  updateHUD();
}

function finishWave(){
  waveState.active = false;
  waveState.pendingSpawns = 0;
  showWaveAnnouncement(`Wave ${waveState.current} cleared!`, 2200);
  playSound('wave', {pitch:1.2});
  updateHUD();
  if(activeGameOptions.mode === 'classic'){
    if(nextWaveTimeout){ clearTimeout(nextWaveTimeout); }
    nextWaveTimeout = setTimeout(()=>{
      if(player.alive && !menuOpen){
        startNextWave();
      }
    }, 2800);
  }
}

function resetCombatState(){
  bullets.forEach(b=>scene.remove(b));
  bullets.length = 0;
  enemies.forEach(e=>enemyGroup.remove(e));
  enemies.length = 0;
  waveState.active = false;
  waveState.pendingSpawns = 0;
  waveState.spawnTimer = 0;
}

function prepareMatchEnvironment(options={}){
  const settings = { ...defaultGameOptions, ...options };
  activeGameOptions = settings;
  buildEnvironment(settings.map || 'alexland');
  friendlyFireEnabled = !!settings.friendlyFire;
  if(settings.mode === 'pee'){
    setAllowedWeapons([4]);
  } else {
    setAllowedWeapons(null);
  }
  updateHUD();
}

function startClassicMatch(){
  resetCombatState();
  waveState.current = 0;
  waveState.kills = 0;
  waveState.killTarget = 0;
  score = 0;
  player.hp = 3;
  player.alive = true;
  gameHasStarted = true;
  startNextWave(true);
}

function startDeathmatchMatch({ restrictPee=false }={}){
  resetCombatState();
  waveState.current = 0;
  waveState.kills = 0;
  waveState.killTarget = 0;
  waveState.active = false;
  score = 0;
  if(restrictPee){
    setAllowedWeapons([4]);
  } else {
    setAllowedWeapons(null);
  }
  gameHasStarted = true;
  updateHUD();
}

function startMatchFromOptions(options){
  let settings = { ...defaultGameOptions, ...(options || {}) };
  if(settings.mode === 'random'){
    const modes = ['classic','deathmatch','pee'];
    const maps = ['alexland','duel','skyline'];
    const mode = modes[Math.floor(Math.random()*modes.length)];
    const map = maps[Math.floor(Math.random()*maps.length)];
    const friendly = Math.random() < 0.4;
    settings = { ...settings, mode, map, friendlyFire: friendly };
  }
  activeGameOptions = settings;
  prepareMatchEnvironment(activeGameOptions);
  if(activeGameOptions.mode === 'pee'){
    startDeathmatchMatch({ restrictPee:true });
  } else if(activeGameOptions.mode === 'deathmatch'){
    startDeathmatchMatch({ restrictPee:false });
  } else {
    startClassicMatch();
  }
}

function chooseEnemyType(){
  if(waveState.current >= 15 && !waveState.spawnedGiant){
    waveState.spawnedGiant = true;
    return 'giant';
  }
  if(waveState.current >= 15 && Math.random() < 0.12){
    return 'giant';
  }
  if(waveState.current >= 5){
    const chance = Math.min(0.45, 0.12 + waveState.current * 0.03);
    if(Math.random() < chance){
      return 'shooter';
    }
  }
  return 'chaser';
}

function tintEnemyMesh(mesh, type){
  const tint = type === 'shooter' ? new THREE.Color(0xffe066) : type === 'giant' ? new THREE.Color(0x993333) : null;
  if(!tint) return;
  mesh.traverse(node=>{
    if(node.isMesh && node.material && node.material.color){
      if(type === 'shooter'){
        node.material.color.lerp(tint, 0.5);
      } else if(type === 'giant'){
        node.material.color.lerp(tint, 0.6);
      }
    }
  });
}

function spawnEnemy(forceType){
  if(waveState.pendingSpawns <= 0) return null;
  const type = forceType || chooseEnemyType();
  const template = getActiveEnemyTemplate();
  const clone = cloneTemplate(template);
  tintEnemyMesh(clone, type);
  refreshAlexlandBaseline(clone);
  const angle=Math.random()*Math.PI*2;
  const dist=12+Math.random()*12;
  clone.position.set(Math.cos(angle)*dist,0.5,Math.sin(angle)*dist);
  const baseData = {hp:2, speed:1.25, fleeTimer:0, type, damage:1, hitRadius: type === 'giant' ? 1.3 : type === 'shooter' ? 0.85 : 0.75};
  if(type === 'shooter'){
    baseData.hp = 3;
    baseData.speed = 1.45;
    baseData.shootCooldown = Math.max(0.9, 2.4 - waveState.current * 0.08);
    baseData.shootTimer = 1.2;
    baseData.hitRadius = 0.9;
  }
  if(type === 'giant'){
    clone.scale.setScalar(1.6);
    baseData.hp = 8;
    baseData.speed = 0.85;
    baseData.damage = 2.5;
    baseData.hitRadius = 1.4;
  }
  clone.userData = {...(clone.userData||{}), ...baseData};
  enemyGroup.add(clone);
  enemies.push(clone);
  waveState.pendingSpawns = Math.max(0, waveState.pendingSpawns - 1);
  playSound('spawn', {pitch: type === 'giant' ? 0.6 : type === 'shooter' ? 1.1 : 1});
  updateHUD();
  return clone;
}

const bullets=[];

function createShotsForWeapon(cfg, origin, dir){
  const forward = dir.clone().normalize();
  const thirdPerson = player.thirdPerson;
  const offset = thirdPerson ? 0.9 : 0.35;
  const baseOrigin = origin.clone().add(forward.clone().multiplyScalar(offset));
  if(cfg.type === 'pulse'){
    return [{
      type:'pulse',
      pos: baseOrigin.toArray(),
      dir: forward.toArray(),
      speed: 14,
      size: 0.1,
      color: cfg.appearance?.color ?? 0xffff66,
      damage: 1,
      ttl: 2.2,
      hitRadius: 0.45,
      pierce: 0
    }];
  }
  if(cfg.type === 'rocket'){
    return [{
      type:'rocket',
      pos: baseOrigin.toArray(),
      dir: forward.toArray(),
      speed: 9,
      size: 0.32,
      color: cfg.appearance?.color ?? 0xff5a2f,
      damage: 2,
      ttl: 4,
      hitRadius: 0.6,
      explode: 1.8,
      pierce: 0
    }];
  }
  if(cfg.type === 'scatter'){
    const shots = [];
    const pelletCount = 6;
    const euler = new THREE.Euler();
    const quat = new THREE.Quaternion();
    for(let i=0;i<pelletCount;i++){
      const spreadYaw = (Math.random()-0.5) * 0.3;
      const spreadPitch = (Math.random()-0.5) * 0.22;
      euler.set(spreadPitch, spreadYaw, 0, 'YXZ');
      quat.setFromEuler(euler);
      const pelletDir = forward.clone().applyQuaternion(quat).normalize();
      const pelletOrigin = origin.clone().add(pelletDir.clone().multiplyScalar(thirdPerson ? 0.9 : 0.32));
      shots.push({
        type:'pellet',
        pos: pelletOrigin.toArray(),
        dir: pelletDir.toArray(),
        speed: 11,
        size: 0.08,
        color: cfg.appearance?.color ?? 0xfff1c1,
        damage: 1,
        ttl: 0.55,
        hitRadius: 0.35,
        pierce: 0
      });
    }
    return shots;
  }
  if(cfg.type === 'pee'){
    const stream = cfg.stream || {};
    const shots = [];
    const dropletCount = stream.count || 8;
    const euler = new THREE.Euler();
    const quat = new THREE.Quaternion();
    for(let i=0;i<dropletCount;i++){
      const spreadYaw = (Math.random()-0.5) * (stream.spreadYaw || 0.22);
      const spreadPitch = (Math.random()-0.5) * (stream.spreadPitch || 0.18);
      euler.set(spreadPitch, spreadYaw, 0, 'YXZ');
      quat.setFromEuler(euler);
      const dropletDir = forward.clone().applyQuaternion(quat).normalize();
      const dropletOrigin = origin.clone()
        .add(dropletDir.clone().multiplyScalar(thirdPerson ? 0.9 : 0.36))
        .add(new THREE.Vector3((Math.random()-0.5)*0.06, (Math.random()-0.5)*0.04, (Math.random()-0.5)*0.06));
      shots.push({
        type:'pee',
        pos: dropletOrigin.toArray(),
        dir: dropletDir.toArray(),
        speed: stream.speed || 12,
        size: stream.size || 0.06,
        color: cfg.appearance?.color ?? 0xfff57a,
        damage: stream.damage || 0.03,
        ttl: stream.ttl || 0.6,
        hitRadius: stream.hitRadius || 0.28,
        gravity: stream.gravity || 4.2,
        pierce: 0
      });
    }
    return shots;
  }
  const beamOrigin = origin.clone().add(forward.clone().multiplyScalar(thirdPerson ? 1.0 : 0.45));
  return [{
    type:'beam',
    pos: beamOrigin.toArray(),
    dir: forward.toArray(),
    color: cfg.appearance?.color ?? 0x5ad4ff,
    duration: 0.18,
    length: 12,
    width: 0.14,
    damage: 2,
    hitRadius: 0.75
  }];
}

function spawnBulletFromShot(shot, ownerId){
  const dir = new THREE.Vector3(...(shot.dir || [0,0,-1])).normalize();
  if(shot.type === 'beam'){
    const length = shot.length ?? 10;
    const width = shot.width ?? 0.12;
    const geometry = new THREE.CylinderGeometry(width, width, length, 16, 1, true);
    const material = new THREE.MeshStandardMaterial({color: shot.color ?? 0x5ad4ff, emissive: new THREE.Color(shot.color ?? 0x5ad4ff).multiplyScalar(0.35), transparent:true, opacity:0.7, roughness:0.25, metalness:0.1});
    const mesh = new THREE.Mesh(geometry, material);
    const origin = new THREE.Vector3(...shot.pos);
    const midpoint = origin.clone().add(dir.clone().multiplyScalar(length/2));
    mesh.position.copy(midpoint);
    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
    mesh.userData = {
      type:'beam',
      owner: ownerId,
      origin,
      dir,
      length,
      damage: shot.damage ?? 2,
      life: shot.duration ?? 0.15,
      duration: shot.duration ?? 0.15,
      hitRadius: shot.hitRadius ?? 0.7,
      hitIds: new Set()
    };
    scene.add(mesh); bullets.push(mesh);
    registerForAlexland(mesh);
    refreshAlexlandBaseline(mesh);
    return mesh;
  }
  const radius = shot.size ?? 0.1;
  const geometry = new THREE.SphereGeometry(radius, 12, 12);
  const baseColor = shot.color ?? 0xffffff;
  const emissiveColor = new THREE.Color(baseColor).multiplyScalar(shot.type === 'pee' ? 0.08 : 0.3);
  const materialConfig = {
    color: baseColor,
    emissive: emissiveColor,
    roughness: shot.type === 'pee' ? 0.68 : 0.35,
    metalness: shot.type === 'pee' ? 0.04 : 0.15
  };
  if(shot.type === 'pee'){
    materialConfig.transparent = true;
    materialConfig.opacity = 0.78;
    materialConfig.depthWrite = false;
  }
  const material = new THREE.MeshStandardMaterial(materialConfig);
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(shot.pos[0], shot.pos[1], shot.pos[2]);
  const velocity = dir.clone().multiplyScalar(shot.speed ?? 0);
  mesh.userData = {
    type: shot.type || 'pulse',
    owner: ownerId,
    dir,
    speed: shot.speed ?? 10,
    velocity,
    damage: shot.damage ?? 1,
    life: shot.ttl ?? 2,
    maxLife: shot.ttl ?? 2,
    hitRadius: shot.hitRadius ?? radius*2,
    explode: shot.explode ?? 0,
    pierce: shot.pierce ?? 0,
    gravity: shot.gravity ?? 0,
    parry: !!shot.parry
  };
  scene.add(mesh); bullets.push(mesh);
  registerForAlexland(mesh);
  refreshAlexlandBaseline(mesh);
  return mesh;
}

function scheduleParryReturn(config, ownerId, options = {}){
  if(!config) return;
  const originSource = config.origin;
  let origin;
  if(Array.isArray(originSource)){
    origin = originSource.slice();
  } else if(originSource && typeof originSource.length === 'number'){
    origin = Array.from(originSource);
  } else {
    origin = [player.pos.x, player.pos.y + 0.6, player.pos.z];
  }
  let dirSource = options.dir !== undefined ? options.dir : config.dir;
  let dirArray = null;
  if(dirSource){
    if(Array.isArray(dirSource)){
      dirArray = dirSource.slice();
    } else if(typeof dirSource.toArray === 'function'){
      dirArray = dirSource.toArray();
    } else if(typeof dirSource.x === 'number'){
      dirArray = [dirSource.x, dirSource.y, dirSource.z];
    }
  }
  const entry = {
    delay: typeof config.delay === 'number' ? config.delay : 1,
    origin,
    enemyId: config.enemyId || null,
    speed: config.speed,
    size: config.size,
    damage: config.damage,
    ttl: config.ttl,
    hitRadius: config.hitRadius,
    color: config.color,
    dir: dirArray,
    ownerId: ownerId,
    parry: !!config.parry
  };
  parryState.pendingReturns.push(entry);
}

function releaseParryShot(entry){
  const originVec = new THREE.Vector3(...(entry.origin || [player.pos.x, player.pos.y + 0.6, player.pos.z]));
  let dirVec = null;
  if(entry.enemyId){
    for(let i=enemies.length-1;i>=0;i--){
      const enemy = enemies[i];
      if(enemy && enemy.uuid === entry.enemyId){
        dirVec = enemy.position.clone().add(new THREE.Vector3(0,0.6,0)).sub(originVec).normalize();
        break;
      }
    }
  }
  if(!dirVec && entry.dir){
    dirVec = new THREE.Vector3(entry.dir[0] || 0, entry.dir[1] || 0, entry.dir[2] || 0).normalize();
  }
  if(!dirVec){
    dirVec = camera.getWorldDirection(new THREE.Vector3()).normalize();
  }
  const shot = {
    type: 'pulse',
    pos: originVec.toArray(),
    dir: dirVec.toArray(),
    speed: entry.speed || 11,
    size: entry.size || 0.12,
    color: entry.color || 0xffd84a,
    damage: entry.damage || 0.7,
    ttl: entry.ttl || 2.4,
    hitRadius: entry.hitRadius || 0.42,
    parry: entry.parry || false
  };
  spawnBulletFromShot(shot, entry.ownerId || player.id);
}

function beginParrySequence(config, options = {}){
  punchState.parryWindow = 0;
  player.parryActive = false;
  const freezeDuration = options.freezeDuration || 1;
  const flashDuration = config.flashDuration || freezeDuration;
  parryState.flashDuration = flashDuration;
  parryState.flash = flashDuration;
  if(parryFlashEl){
    parryFlashEl.style.opacity = '0.55';
  }
  playSound('parry');
  player.parryFrozen = true;
  parryState.freezeTimer = Math.max(parryState.freezeTimer, freezeDuration);
  if(!options.multiplayer){
    parryState.timeStop = Math.max(parryState.timeStop, freezeDuration);
  } else {
    player.stealthTimer = Math.max(player.stealthTimer, options.stealthDuration || freezeDuration);
  }
  const ownerId = options.ownerId || player.id;
  scheduleParryReturn(config, ownerId, {dir: config.dir});
  if(options.broadcast && typeof sendData === 'function'){
    const payload = {
      delay: typeof config.delay === 'number' ? config.delay : freezeDuration,
      origin: Array.isArray(config.origin) ? config.origin.slice() : (config.origin && typeof config.origin.length === 'number' ? Array.from(config.origin) : [player.pos.x, player.pos.y + 0.6, player.pos.z]),
      enemyId: config.enemyId || null,
      speed: config.speed,
      size: config.size,
      damage: config.damage,
      ttl: config.ttl,
      hitRadius: config.hitRadius,
      color: config.color,
      parry: !!config.parry,
      dir: Array.isArray(config.dir) ? config.dir.slice() : (config.dir && typeof config.dir.toArray === 'function' ? config.dir.toArray() : (config.dir && typeof config.dir.x === 'number' ? [config.dir.x, config.dir.y, config.dir.z] : null))
    };
    sendData({t:'parry', config: payload, owner: ownerId});
  }
}

function parryIncomingShot(bullet, data, index){
  const origin = player.pos.clone().add(new THREE.Vector3(0,0.6,0));
  let incomingDir = null;
  if(data.dir){
    if(typeof data.dir.clone === 'function'){
      incomingDir = data.dir.clone().normalize();
    } else if(Array.isArray(data.dir)){
      incomingDir = new THREE.Vector3(data.dir[0] || 0, data.dir[1] || 0, data.dir[2] || 0).normalize();
    } else if(typeof data.dir.x === 'number'){
      incomingDir = new THREE.Vector3(data.dir.x, data.dir.y, data.dir.z).normalize();
    }
  }
  if(!incomingDir){
    incomingDir = bullet.position.clone().sub(origin).normalize();
  }
  const reflectDir = incomingDir.clone().multiplyScalar(-1);
  const config = {
    delay: 1,
    origin: origin.toArray(),
    enemyId: data.owner || null,
    speed: data.speed || 11,
    size: data.size || 0.12,
    damage: data.damage || 0.7,
    ttl: data.ttl || 2.4,
    hitRadius: data.hitRadius || 0.42,
    color: data.color || 0xffd84a,
    dir: reflectDir.toArray(),
    parry: true
  };
  cleanupBullet(index);
  beginParrySequence(config, {
    multiplayer: isMultiplayerActive(),
    ownerId: player.id,
    broadcast: true,
    freezeDuration: 1,
    stealthDuration: 1
  });
}

function updateParry(rawDt){
  if(parryState.flash > 0){
    parryState.flash = Math.max(0, parryState.flash - rawDt);
    if(parryFlashEl){
      const ratio = parryState.flashDuration > 0 ? parryState.flash / parryState.flashDuration : 0;
      parryFlashEl.style.opacity = (0.55 * Math.min(1, ratio)).toFixed(3);
    }
  } else if(parryFlashEl && parryFlashEl.style.opacity !== '0'){
    parryFlashEl.style.opacity = '0';
  }

  if(parryState.timeStop > 0){
    parryState.timeStop = Math.max(0, parryState.timeStop - rawDt);
  }

  if(parryState.freezeTimer > 0){
    parryState.freezeTimer = Math.max(0, parryState.freezeTimer - rawDt);
    if(parryState.freezeTimer <= 0){
      player.parryFrozen = false;
    }
  }

  if(player.stealthTimer > 0){
    player.stealthTimer = Math.max(0, player.stealthTimer - rawDt);
  }

  for(let i=parryState.pendingReturns.length-1;i>=0;i--){
    const entry = parryState.pendingReturns[i];
    entry.delay -= rawDt;
    if(entry.delay <= 0){
      releaseParryShot(entry);
      parryState.pendingReturns.splice(i,1);
    }
  }
}

function isMultiplayerActive(){
  const hasRemotes = remotePlayers && Object.keys(remotePlayers).length > 0;
  const hasPeers = (typeof peerConnections !== 'undefined' && peerConnections) ? Object.keys(peerConnections).length > 0 : false;
  return hasRemotes || hasPeers;
}

function cleanupBullet(index){
  const mesh = bullets[index];
  if(!mesh) return;
  scene.remove(mesh);
  bullets.splice(index,1);
}

function scareEnemy(enemy){
  if(!enemy || !enemy.userData) return;
  const data = enemy.userData;
  const fleeDuration = 2.4;
  const fleeSpeed = 4.5;
  data.fleeTimer = Math.max(data.fleeTimer || 0, fleeDuration);
  data.fleeSpeed = Math.max(data.fleeSpeed || 0, fleeSpeed);
}

function damageEnemyAtIndex(idx, amount, onSurvive){
  const enemy = enemies[idx];
  if(!enemy) return false;
  if(typeof enemy.userData.hp !== 'number'){ enemy.userData.hp = 2; }
  enemy.userData.hp -= amount;
  if(enemy.userData.hp <= 0){
    enemyGroup.remove(enemy);
    enemies.splice(idx,1);
    score += 10;
    waveState.kills = Math.min(waveState.killTarget, waveState.kills + 1);
    if(waveState.active && waveState.kills >= waveState.killTarget && waveState.pendingSpawns === 0){
      finishWave();
    }
    updateHUD();
    playSound('hit', {pitch: enemy.userData.type === 'giant' ? 0.7 : 1});
    return true;
  }
  playSound('hit', {pitch: enemy.userData.type === 'giant' ? 0.6 : 1.1});
  if(typeof onSurvive === 'function') onSurvive(enemy);
  return false;
}

function applyExplosion(position, radius, damage){
  for(let j=enemies.length-1;j>=0;j--){
    const enemy = enemies[j];
    if(!enemy) continue;
    if(enemy.position.distanceTo(position) <= radius){
      damageEnemyAtIndex(j, damage);
    }
  }
}

function applyBeamDamage(beam){
  const data = beam.userData;
  if(!data || !data.origin || !data.dir) return;
  const origin = data.origin;
  const dir = data.dir;
  if(!data.hitIds) data.hitIds = new Set();
  for(let j=enemies.length-1;j>=0;j--){
    const enemy = enemies[j];
    if(!enemy || data.hitIds.has(enemy.uuid)) continue;
    const toEnemy = new THREE.Vector3().subVectors(enemy.position, origin);
    const projection = toEnemy.dot(dir);
    if(projection < 0 || projection > data.length) continue;
    const perpendicularSq = toEnemy.lengthSq() - projection*projection;
    const radiusSq = (data.hitRadius ?? 0.7) ** 2;
    if(perpendicularSq > radiusSq) continue;
    data.hitIds.add(enemy.uuid);
    damageEnemyAtIndex(j, data.damage ?? 2);
  }
}

function enemyShoot(enemy, targetInfo){
  if(!enemy) return;
  const origin = enemy.position.clone().add(new THREE.Vector3(0,0.8,0));
  let aim = null;
  if(targetInfo && targetInfo.pos){
    aim = targetInfo.pos.clone ? targetInfo.pos.clone() : new THREE.Vector3(targetInfo.pos.x, targetInfo.pos.y, targetInfo.pos.z);
  } else if(player && player.alive){
    aim = player.pos.clone();
  }
  if(!aim) return;
  const target = aim.add(new THREE.Vector3(0,0.6,0));
  const dir = target.sub(origin).normalize();
  const shot = {
    type:'pulse',
    pos: origin.toArray(),
    dir: dir.toArray(),
    speed: 11,
    size: 0.12,
    color: 0xffd84a,
    damage: 0.7,
    ttl: 2.6,
    hitRadius: 0.42
  };
  spawnBulletFromShot(shot, enemy.uuid || 'enemy');
  if(isHost){
    broadcast({ t:'enemy_shoot', shot, enemyId: enemy.uuid || 'enemy' });
  }
  playSound('shoot', {pitch:0.8});
}

function shoot(){
  if(!player.alive || weaponWheelState.open) return false;
  const cfg = weaponConfigById.get(player.weapon) || weaponConfigs[0];
  const interval = cfg.fireInterval ?? 0.3;
  if(weaponState.recharging) return false;
  if(shootState.cooldown > 0) return false;
  shootState.cooldown = interval;
  const cost = cfg.chargeCost ?? 0.2;
  if(weaponState.charge < cost){
    triggerWeaponRecharge(cfg);
    return false;
  }
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  const origin = player.thirdPerson ? player.pos.clone().add(new THREE.Vector3(0,0.7,0)) : camera.getWorldPosition(new THREE.Vector3());
  const shots = createShotsForWeapon(cfg, origin, dir);
  const serialized = [];
  shots.forEach(shot=>{
    spawnBulletFromShot(shot, player.id);
    serialized.push({...shot});
  });
  weaponState.charge = Math.max(0, weaponState.charge - cost);
  if(weaponState.charge <= 0){
    triggerWeaponRecharge(cfg);
  }
  const weaponId = cfg?.id ?? player.weapon;
  sendData({t:'shoot', w: weaponId, shots: serialized});
  if(armRig) armRig.triggerFire();
  playSound('shoot');
  return true;
}

window.addEventListener('mousedown', e=>{
  if(e.button===0){
    shootState.mouseDown = true;
    shootState.down = true;
    shoot();
  }
});
window.addEventListener('mouseup', e=>{
  if(e.button===0){
    shootState.mouseDown = false;
    if(!gamepadState.fire && !touchState.fire){
      shootState.down = false;
    }
  }
});
window.addEventListener('blur', ()=>{
  shootState.down = false;
  shootState.mouseDown = false;
});

/* HUD update */
let score = 0;
function updateHUD(){
  const waveText = waveState.active ? `Wave ${waveState.current} (${Math.max(0, waveState.killTarget - waveState.kills)} left)` : (waveState.current > 0 ? `Wave ${waveState.current} ready` : 'Wave 0');
  const hpValue = Number.isFinite(player.hp) ? (Math.abs(player.hp % 1) < 1e-2 ? player.hp.toFixed(0) : player.hp.toFixed(1)) : '0';
  let modeLabel = activeGameOptions.mode === 'deathmatch' ? 'Deathmatch' : activeGameOptions.mode === 'pee' ? 'Pee Deathmatch' : `Wave ${waveState.current}`;
  if(activeGameOptions.mode === 'classic'){ modeLabel = waveText; }
  let weaponStatus = '';
  if(weaponState.recharging){
    const remaining = Math.max(0, weaponState.rechargeTimer || 0);
    const total = Math.max(remaining, weaponState.rechargeDuration || 0);
    const percent = total > 0 ? Math.round(((total - remaining) / total) * 100) : 0;
    const label = weaponState.label || 'Recharging';
    const timeText = remaining > 0 ? ` (${remaining.toFixed(1)}s)` : '';
    const pctText = total > 0 ? ` [${Math.max(0, Math.min(100, percent))}%]` : '';
    weaponStatus = ` | ${label}${timeText}${pctText}`;
  }
  hud.textContent = `Score: ${score} | ${modeLabel} | Enemies: ${enemies.length} | HP: ${hpValue} | Signaling: ${connectionLabel}${weaponStatus}`;
}
function updatePlayers(){
  let txt = `Players: ${nameInput.value || player.name || 'me'}`;
  let count = 1;
  for(const id in remotePlayers){
    const r = remotePlayers[id];
    txt += '\n' + (r.name || id);
    count += 1;
  }
  playersDiv.textContent = txt;
  updatePopulationSign(count, activeLobbyName);
}

function getLobbyPlayersArray(){
  return Array.from(lobbyPlayersState.values()).sort((a,b)=>{
    if(a.joinOrder !== b.joinOrder){
      return a.joinOrder - b.joinOrder;
    }
    return a.name.localeCompare(b.name);
  });
}

function renderLobbyRoster(){
  if(!lobbyRosterListEl) return;
  lobbyRosterListEl.innerHTML = '';
  const players = getLobbyPlayersArray();
  if(!players.length){
    const empty = document.createElement('div');
    empty.textContent = 'Waiting for playersâ€¦';
    empty.style.opacity = '0.7';
    lobbyRosterListEl.appendChild(empty);
    return;
  }
  players.forEach(player=>{
    const row = document.createElement('div');
    row.className = 'lobby-roster-entry';
    const nameWrap = document.createElement('div');
    nameWrap.className = 'name';
    if(player.id === lobbyHostId){
      const crown = document.createElement('span');
      crown.className = 'crown';
      crown.textContent = 'ðŸ‘‘';
      nameWrap.appendChild(crown);
    }
    if(player.color){
      const swatch = document.createElement('span');
      swatch.style.display = 'inline-block';
      swatch.style.width = '10px';
      swatch.style.height = '10px';
      swatch.style.borderRadius = '2px';
      swatch.style.margin = '0 6px 0 4px';
      swatch.style.border = '1px solid rgba(255,255,255,0.35)';
      swatch.style.background = player.color;
      nameWrap.appendChild(swatch);
    }
    const nameLabel = document.createElement('span');
    nameLabel.textContent = player.name || player.id;
    nameWrap.appendChild(nameLabel);
    if(player.ready){
      const readyTag = document.createElement('span');
      readyTag.textContent = 'READY';
      readyTag.style.fontSize = '11px';
      readyTag.style.marginLeft = '8px';
      readyTag.style.padding = '2px 6px';
      readyTag.style.borderRadius = '999px';
      readyTag.style.background = 'rgba(124,196,255,0.25)';
      readyTag.style.color = '#aee8ff';
      nameWrap.appendChild(readyTag);
    }
    row.appendChild(nameWrap);
    const ping = document.createElement('div');
    ping.className = 'ping';
    const latency = lobbyPingState.get(player.id);
    ping.textContent = latency ? `${latency} ms` : 'â€”';
    row.appendChild(ping);
    lobbyRosterListEl.appendChild(row);
  });
  updateLobbyButtons();
}

function setLobbyStageVisible(open){
  lobbyStageOpen = !!open;
  if(lobbyStageEl){
    lobbyStageEl.classList.toggle('open', lobbyStageOpen);
  }
  if(lobbyStageOpen){
    renderLobbyRoster();
    syncLobbyOptionUI();
  }
  setMenuOpen(lobbyStageOpen);
}

function updateLobbyStageStatus(text){
  if(!lobbyStageStatusEl) return;
  if(text){
    lobbyStageStatusEl.textContent = text;
    return;
  }
  const players = getLobbyPlayersArray();
  const readyCount = players.filter(p=>p.ready).length;
  lobbyStageStatusEl.textContent = `${readyCount}/${players.length || 1} ready`;
}

function syncLobbyOptionUI(){
  const isHostClient = !!(player && player.id && lobbyHostId === player.id && isHost);
  lobbyModeInputs.forEach(input=>{
    input.checked = input.value === lobbyGameOptions.mode;
    input.disabled = !isHostClient;
  });
  if(lobbyMapSelect){
    lobbyMapSelect.value = lobbyGameOptions.map;
    lobbyMapSelect.disabled = !isHostClient;
  }
  if(lobbyFriendlyFireInput){
    lobbyFriendlyFireInput.checked = !!lobbyGameOptions.friendlyFire;
    lobbyFriendlyFireInput.disabled = !isHostClient;
  }
  if(lobbyStartButton){
    lobbyStartButton.disabled = !isHostClient;
  }
}

function updateLobbyButtons(){
  if(lobbyReadyButton){
    lobbyReadyButton.textContent = localReadyState ? 'Cancel Ready' : 'Ready Up';
    lobbyReadyButton.classList.toggle('active', localReadyState);
  }
  if(lobbyStartButton){
    const players = getLobbyPlayersArray();
    const allReady = players.length > 0 && players.every(p=>p.ready);
    const hostClient = player && player.id === lobbyHostId && isHost;
    lobbyStartButton.disabled = !(hostClient && allReady);
    if(allReady){
      updateLobbyStageStatus('All players ready!');
    } else {
      updateLobbyStageStatus();
    }
  }
}

function updateLobbyOptionsFromUI(){
  const modeInput = lobbyModeInputs.find(input=>input.checked);
  if(modeInput){
    lobbyGameOptions.mode = modeInput.value;
  }
  if(lobbyMapSelect){
    lobbyGameOptions.map = lobbyMapSelect.value;
  }
  if(lobbyFriendlyFireInput){
    lobbyGameOptions.friendlyFire = lobbyFriendlyFireInput.checked;
  }
}

function upsertLobbyPlayer(id, data={}){
  if(!id) return;
  const prev = lobbyPlayersState.get(id) || {};
  const joinOrder = prev.joinOrder ?? data.joinOrder ?? (Date.now() + Math.random());
  const next = {
    id,
    name: data.name ?? prev.name ?? id,
    ready: data.ready ?? prev.ready ?? false,
    joinOrder,
    color: data.color ?? prev.color ?? null
  };
  lobbyPlayersState.set(id, next);
  if(!lobbyPingState.has(id)){ lobbyPingState.set(id, null); }
  if(typeof data.ready === 'boolean'){ lobbyReadyMap.set(id, data.ready); }
  renderLobbyRoster();
  updateLobbyStageStatus();
}

function removeLobbyPlayer(id){
  if(!id) return;
  lobbyPlayersState.delete(id);
  lobbyReadyMap.delete(id);
  lobbyPingState.delete(id);
  renderLobbyRoster();
  updateLobbyStageStatus();
}

function setLobbyHost(id){
  lobbyHostId = id;
  syncLobbyOptionUI();
  renderLobbyRoster();
}

function updateLobbyStageTitle(name){
  if(!lobbyStageTitleEl) return;
  lobbyStageTitleEl.textContent = name || 'Lobby';
}

function buildLocalLobbyMeta(){
  return {
    id: player.id,
    name: player.name,
    ready: localReadyState,
    joinOrder: localJoinOrder,
    color: customCubeColorHex
  };
}

function sendLobbyHandshake(peerId){
  if(!peerId) return;
  const meta = {
    t:'lobby_meta',
    player: buildLocalLobbyMeta(),
    options: lobbyGameOptions,
    host: lobbyHostId,
    lobbyName: activeLobbyName
  };
  sendDirect(peerId, meta);
  if(isHost && player && player.id && lobbyHostId === player.id){
    const roster = getLobbyPlayersArray();
    sendDirect(peerId, { t:'lobby_state', roster, options: lobbyGameOptions, host: lobbyHostId, lobbyName: activeLobbyName });
  }
}

function pumpLobbyPings(){
  if(!isMultiplayerActive()) return;
  const now = performance.now ? performance.now() : Date.now();
  if(isHost){
    let touched = false;
    for(const id in dataChannels){
      const ch = dataChannels[id];
      if(ch && ch.readyState === 'open'){
        touched = true;
        sendDirect(id, { t:'lobby_ping', ts: now, id: player.id });
      }
    }
    if(touched){
      lobbyPingState.set(player.id, 0);
    }
    return;
  }
  const hostChannel = dataChannels['host'];
  if(hostChannel && hostChannel.readyState === 'open'){
    sendDirect('host', { t:'lobby_ping', ts: now, id: player.id });
  }
}

function broadcastLobbyMeta(){
  const payload = { t:'lobby_meta', player: buildLocalLobbyMeta(), options: lobbyGameOptions, host: lobbyHostId, lobbyName: activeLobbyName };
  sendData(payload);
}

function broadcastLobbySettings(){
  const payload = { t:'lobby_settings', options: lobbyGameOptions };
  sendData(payload);
}

function broadcastLobbyReady(ready){
  const payload = { t:'lobby_ready', ready: !!ready };
  sendData(payload);
}

function resolveMatchOptions(options){
  let settings = { ...defaultGameOptions, ...(options || {}) };
  if(settings.mode === 'random'){
    const modes = ['classic','deathmatch','pee'];
    const maps = ['alexland','duel','skyline'];
    const mode = modes[Math.floor(Math.random()*modes.length)];
    const map = maps[Math.floor(Math.random()*maps.length)];
    const friendly = Math.random() < 0.4;
    settings = { ...settings, mode, map, friendlyFire: friendly };
  }
  return settings;
}

function hostStartMatch(){
  if(!(player && player.id === lobbyHostId && isHost)) return;
  const players = getLobbyPlayersArray();
  const allReady = players.length > 0 && players.every(p=>p.ready);
  if(!allReady){
    alert('All players must be ready before starting.');
    return;
  }
  const startOptions = resolveMatchOptions(lobbyGameOptions);
  const payload = { t:'lobby_start', options: startOptions, lobbyName: activeLobbyName, host: player.id };
  sendData(payload);
  startMatchFromOptions(startOptions);
  setLobbyStageVisible(false);
}

/* Game Over / Retry */
const gameOverDiv = document.getElementById('gameOver');
document.getElementById('retry').addEventListener('click', ()=>{
  // reset player
  player.hp = 3; player.alive = true; player.pos.set(0,0.5,0); player.velocity.set(0,0,0);
  // clear bullets & enemies and reset spawn
  bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
  enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
  waveState.current = 0;
  waveState.kills = 0;
  waveState.killTarget = 0;
  waveState.pendingSpawns = 0;
  waveState.spawnTimer = 0;
  waveState.spawnInterval = 2.4;
  waveState.spawnedGiant = false;
  if(nextWaveTimeout){ clearTimeout(nextWaveTimeout); nextWaveTimeout = null; }
  score = 0;
  // broadcast reset to peers
  sendData({t:'reset'});
  gameOverDiv.style.display = 'none';
  updateHUD(); updatePlayers();
  gameHasStarted = true;
  startNextWave(true);
});

/* --------------------------
   Networking: WebSocket assisted P2P
   -------------------------- */
const btnHost = document.getElementById('btnHost');
const btnJoin = document.getElementById('btnJoin');
const btnHide = document.getElementById('btnHide');
let peerConnections = {}; // peerId -> RTCPeerConnection
let dataChannels = {};    // peerId -> DataChannel
const peerIdToPlayerId = new Map();
let menuOpen = true;
let isHost = false;
let signalingSocket = null;
let localPeerId = '';
let activeRoomCode = '';
let connectionLabel = 'disconnected';
let pendingHostMeta = null;
let lobbyState = { list: [], selected: null };
const SIGNALING_PING_INTERVAL = 5000;
let signalingHeartbeat = null;
let manualSignalingDisconnect = false;
let manualDisconnectMessage = '';
let lastSignalingPong = 0;

/* pause when menu open */
function setMenuOpen(open){
  menuOpen = open;
}

function showPlayIntro(){
  if(playIntroEl){ playIntroEl.classList.remove('hidden'); }
  if(playModeSelectEl){ playModeSelectEl.classList.add('hidden'); }
}

function showPlayModeSelect(){
  if(playIntroEl){ playIntroEl.classList.add('hidden'); }
  if(playModeSelectEl){ playModeSelectEl.classList.remove('hidden'); }
  let focused = false;
  if(menuRoomCodeInput){
    if(!menuRoomCodeInput.value){
      menuRoomCodeInput.value = roomInput.value || '';
    }
    if(!menuRoomCodeInput.value){
      menuRoomCodeInput.focus();
      focused = true;
    }
  }
  if(menuPlayerNameInput){
    if(!menuPlayerNameInput.value){
      menuPlayerNameInput.value = nameInput.value || player.name || '';
    }
    if(!focused){
      menuPlayerNameInput.focus();
    }
  }
}

function showMainMenu(){
  if(mainMenuEl){
    mainMenuEl.style.display = 'flex';
  }
  if(pauseMenuEl){ pauseMenuEl.style.display = 'none'; }
  showPlayIntro();
  gameHasStarted = false;
  setMenuOpen(true);
}

function closeMainMenu(){
  if(mainMenuEl){
    mainMenuEl.style.display = 'none';
  }
  setMenuOpen(false);
}

function closePauseMenu(){
  if(pauseMenuEl){ pauseMenuEl.style.display = 'none'; }
  setMenuOpen(false);
}

function openPauseMenu(){
  if(mainMenuEl && mainMenuEl.style.display !== 'none') return;
  if(pauseMenuEl){
    pauseMenuEl.style.display = 'flex';
  }
  document.exitPointerLock?.();
  setMenuOpen(true);
}

let gameHasStarted = false;

function initializeMenuUI(){
  if(!mainMenuEl) return;
  const storedColor = readCookie(COLOR_COOKIE_KEY);
  if(storedColor){
    customCubeColorHex = storedColor;
  }
  applyCustomCubeColor(customCubeColorHex);

  if(cubeColorInput){
    cubeColorInput.value = customCubeColorHex;
    cubeColorInput.addEventListener('input', e=>{
      const hex = e.target.value || '#01c119';
      applyCustomCubeColor(hex);
      writeCookie(COLOR_COOKIE_KEY, hex);
      refreshAlexlandBaseline(alexMesh);
    });
  }

  const storedAlexland = readCookie(ALEXLAND_COOKIE_KEY);
  if(storedAlexland){
    setAlexlandMode(storedAlexland === 'on');
    if(alexlandToggleInput){
      alexlandToggleInput.checked = (storedAlexland === 'on');
    }
  } else {
    setAlexlandMode(false);
  }
  if(alexlandToggleInput){
    alexlandToggleInput.addEventListener('change', ()=>{
      const enabled = !!alexlandToggleInput.checked;
      setAlexlandMode(enabled);
      writeCookie(ALEXLAND_COOKIE_KEY, enabled ? 'on' : 'off');
    });
  }

  menuTabs.forEach(tab=>{
    tab.addEventListener('click', ()=>{
      const id = tab.dataset.tab;
      menuTabs.forEach(btn=> btn.classList.toggle('active', btn === tab));
      menuSections.forEach(section=>{
        section.classList.toggle('active', section.dataset.content === id);
      });
    });
  });

  if(startButton){
    startButton.addEventListener('click', ()=>{
      showPlayModeSelect();
    });
  }

  function updateRoomCodeFromMenu(){
    return syncRoomInputFromMenu();
  }

  function updateNameFromMenu(){
    const raw = (menuPlayerNameInput?.value || '').trim();
    const name = raw || 'Player';
    setPlayerDisplayName(name);
  }

  if(menuRoomCodeInput){
    if(!menuRoomCodeInput.value){
      menuRoomCodeInput.value = roomInput.value || '';
    }
    menuRoomCodeInput.addEventListener('input', updateRoomCodeFromMenu);
    menuRoomCodeInput.addEventListener('change', updateRoomCodeFromMenu);
  }

  if(menuPlayerNameInput){
    menuPlayerNameInput.value = nameInput.value || player.name || '';
    menuPlayerNameInput.addEventListener('input', updateNameFromMenu);
  }

  if(btnPlayBack){
    btnPlayBack.addEventListener('click', ()=>{
      showPlayIntro();
    });
  }

  function beginGame(mode){
    if(menuPlayerNameInput){
      updateNameFromMenu();
    } else {
      const fallback = (nameInput.value || player.name || 'Player').trim();
      setPlayerDisplayName(fallback);
    }
    if(pauseNameInput && pauseNameInput.value !== player.name){
      pauseNameInput.value = player.name;
    }
    let joinedRoomCode = '';
    if(menuRoomCodeInput){
      joinedRoomCode = syncRoomInputFromMenu();
      if(mode === 'join' && !joinedRoomCode){
        alert('Enter a room code to join a lobby.');
        menuRoomCodeInput.focus();
        return;
      }
    } else if(mode === 'join' && !(roomInput.value || '').trim()){
      alert('Enter a room code to join a lobby.');
      return;
    }
    closePauseMenu();
    closeMainMenu();
    if(mode === 'solo'){
      activeGameOptions = { ...defaultGameOptions };
      lobbyGameOptions = { ...defaultGameOptions };
      friendlyFireEnabled = false;
      lobbyPlayersState.clear();
      lobbyPingState.clear();
      setLobbyStageVisible(false);
      startMatchFromOptions(activeGameOptions);
      return;
    }
    localReadyState = false;
    lobbyReadyMap.set(player.id, false);
    lobbyPlayersState.clear();
    lobbyPingState.clear();
    upsertLobbyPlayer(player.id, { name: player.name, ready: false, joinOrder: localJoinOrder++ });
    lobbyPingState.set(player.id, 0);
    if(mode === 'host'){
      const stagedName = (lobbyNameInput?.value || '').trim();
      if(stagedName){
        setActiveLobbyName(stagedName);
      }
      setLobbyHost(player.id);
      peerIdToPlayerId.set('host', player.id);
    }
    setLobbyStageVisible(true);
    const stageLabel = activeLobbyName || joinedRoomCode || roomInput.value || 'Lobby';
    updateLobbyStageTitle(stageLabel);
    updateLobbyStageStatus('Waiting for playersâ€¦');
    if(mode === 'host'){ btnHost?.click(); }
    if(mode === 'join'){ btnJoin?.click(); }
  }

  btnPlaySolo?.addEventListener('click', ()=> beginGame('solo'));
  btnPlayHost?.addEventListener('click', ()=> beginGame('host'));
  btnPlayJoin?.addEventListener('click', ()=> beginGame('join'));

  updateCubePreview(customCubeColorHex);
  showMainMenu();
}

btnResume?.addEventListener('click', ()=>{
  closePauseMenu();
});

btnPauseMenu?.addEventListener('click', ()=>{
  closePauseMenu();
  showMainMenu();
});

function setSignalingStatus(text, mode='info'){
  connectionLabel = text;
  statusEl.textContent = `Status: ${text}`;
  if(mode === 'connected'){
    statusEl.style.color = '#8f8';
  } else if(mode === 'error'){
    statusEl.style.color = '#f88';
  } else if(mode === 'warning'){
    statusEl.style.color = '#ffd27f';
  } else if(mode === 'connecting'){
    statusEl.style.color = '#ffd27f';
  } else {
    statusEl.style.color = '#fff';
  }
  updateHUD();
}

function logNetwork(msg){
  const now = new Date();
  const stamp = now.toLocaleTimeString();
  networkLogEl.textContent = `${stamp} â€” ${msg}\n${networkLogEl.textContent}`.slice(0, 4000);
}

function stopSignalingHeartbeat(){
  if(signalingHeartbeat){
    clearInterval(signalingHeartbeat);
    signalingHeartbeat = null;
  }
}

function startSignalingHeartbeat(){
  stopSignalingHeartbeat();
  signalingHeartbeat = setInterval(()=>{
    if(!signalingSocket || signalingSocket.readyState !== WebSocket.OPEN) return;
    try{ signalingSocket.send(JSON.stringify({ type:'ping' })); }
    catch(e){}
  }, SIGNALING_PING_INTERVAL);
}

function handleSignalingSocketClosed(wasManual, message){
  stopSignalingHeartbeat();
  if(signalingSocket){
    signalingSocket.onopen = null;
    signalingSocket.onclose = null;
    signalingSocket.onerror = null;
    signalingSocket.onmessage = null;
    signalingSocket = null;
  }
  const note = message || (wasManual ? 'Disconnected.' : 'Signaling connection lost. Existing peers remain connected.');
  manualSignalingDisconnect = false;
  manualDisconnectMessage = '';
  localPeerId = '';
  pendingHostMeta = null;
  setActiveLobbyName('Alexland');
  if(wasManual){
    activeRoomCode = '';
    resetNetworkButtons();
    setSignalingStatus('disconnected');
    if(note) logNetwork(note);
    closeAllPeers();
    if(!lobbyBrowserEl.classList.contains('open')){
      setMenuOpen(false);
    }
  } else {
    resetNetworkButtons();
    setSignalingStatus('relay disconnected', 'warning');
    if(note) logNetwork(note);
  }
}

function clampCapacity(value){
  const num = Number.parseInt(value, 10);
  if(Number.isFinite(num)){
    return Math.min(16, Math.max(1, num));
  }
  return 10;
}

function persistCurrentNetworkForm(){
  const capacityVal = Number.parseInt(lobbyMaxInput.value, 10);
  const clamped = Number.isFinite(capacityVal) ? clampCapacity(capacityVal) : 10;
  savePersistedNetworkSettings({
    server: (serverUrlInput.value || '').trim() || DEFAULT_SIGNALING_URL,
    name: (nameInput.value || '').trim(),
    room: (roomInput.value || '').trim(),
    lobbyName: (lobbyNameInput.value || '').trim(),
    capacity: clamped
  });
}

[nameInput, serverUrlInput, roomInput, lobbyNameInput, lobbyMaxInput].forEach(el=>{
  if(!el) return;
  const handler = ()=> persistCurrentNetworkForm();
  el.addEventListener('change', handler);
  if(el !== lobbyMaxInput){
    el.addEventListener('input', handler);
  }
});

if(lobbyNameInput){
  lobbyNameInput.addEventListener('change', ()=>{
    if(isHost && player && player.id === lobbyHostId){
      const staged = (lobbyNameInput.value || '').trim();
      setActiveLobbyName(staged || activeLobbyName);
      broadcastLobbyMeta();
    }
  });
}

function slugifyRoomName(name){
  if(!name) return '';
  return name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').slice(0, 40);
}

function websocketToHttp(url){
  try{
    const parsed = new URL(url);
    if(parsed.protocol === 'ws:') parsed.protocol = 'http:';
    if(parsed.protocol === 'wss:') parsed.protocol = 'https:';
    return parsed.toString().replace(/\/$/, '');
  }catch(err){
    if(url.startsWith('http')) return url.replace(/\/$/, '');
    return `http://${url.replace(/\/$/, '')}`;
  }
}

function resetLobbySelection(){
  lobbyState.selected = null;
  lobbyDetailNameEl.textContent = 'Select a lobby';
  lobbyDetailMetaEl.textContent = 'Pick a room from the list to see who is inside.';
  lobbyPlayersEl.textContent = 'No lobby selected';
  lobbyPlayersEl.classList.add('empty');
  btnJoinLobby.disabled = true;
  lobbyListEl.querySelectorAll('.lobby-entry').forEach(el=> el.classList.remove('active'));
}

let autoConnectTriggered = false;
function attemptAutoConnectFromStorage(){
  if(autoConnectTriggered) return;
  autoConnectTriggered = true;
  const settings = persistedNetworkSettings || {};
  if(!settings.autoConnect) return;
  const role = settings.lastRole;
  const room = settings.lastRoom;
  if(!role || !room) return;
  if(!roomInput.value){
    roomInput.value = room;
  }
  if(role === 'host' && settings.lastLobbyName && !lobbyNameInput.value){
    lobbyNameInput.value = settings.lastLobbyName;
  }
  setTimeout(()=>{
    beginSignaling(role === 'host' ? 'host' : 'join');
  }, 200);
}

window.addEventListener('load', ()=> attemptAutoConnectFromStorage());

function renderLobbyList(list){
  lobbyListEl.innerHTML = '';
  lobbyState.list = list;
  if(!list.length){
    const empty = document.createElement('div');
    empty.textContent = 'No public lobbies online';
    empty.style.opacity = '0.6';
    empty.style.padding = '12px';
    lobbyListEl.appendChild(empty);
    resetLobbySelection();
    return;
  }
  list.forEach(lobby=>{
    const entry = document.createElement('div');
    entry.className = 'lobby-entry';
    entry.dataset.code = lobby.code;
    const nameSpan = document.createElement('div');
    nameSpan.textContent = lobby.name || lobby.code;
    const countSpan = document.createElement('div');
    countSpan.textContent = `${lobby.players.length}/${lobby.capacity}`;
    countSpan.style.opacity = '0.8';
    entry.appendChild(nameSpan);
    entry.appendChild(countSpan);
    entry.addEventListener('click', ()=>{
      selectLobby(lobby.code);
    });
    lobbyListEl.appendChild(entry);
  });
  resetLobbySelection();
}

function selectLobby(code){
  const lobby = lobbyState.list.find(l=>l.code === code);
  lobbyListEl.querySelectorAll('.lobby-entry').forEach(el=>{
    el.classList.toggle('active', el.dataset.code === code);
  });
  if(!lobby){
    resetLobbySelection();
    return;
  }
  lobbyState.selected = lobby;
  lobbyDetailNameEl.textContent = lobby.name || lobby.code;
  lobbyDetailMetaEl.textContent = `${lobby.players.length}/${lobby.capacity} players`;
  lobbyPlayersEl.classList.toggle('empty', lobby.players.length === 0);
  lobbyPlayersEl.innerHTML = '';
  if(!lobby.players.length){
    const empty = document.createElement('div');
    empty.textContent = 'Be the first to join!';
    empty.style.opacity = '0.75';
    lobbyPlayersEl.appendChild(empty);
  } else {
    lobby.players.forEach(p=>{
      const row = document.createElement('div');
      row.textContent = p.name || p.id;
      lobbyPlayersEl.appendChild(row);
    });
  }
  const full = lobby.players.length >= lobby.capacity;
  btnJoinLobby.disabled = full;
  if(full){
    lobbyDetailMetaEl.textContent += ' (Full)';
  }
}

async function refreshLobbyList(){
  const base = websocketToHttp((serverUrlInput.value || 'ws://localhost:3000').trim());
  try{
    const res = await fetch(`${base}/rooms`, { cache: 'no-store', headers: { 'Accept': 'application/json' } });
    if(!res.ok){
      throw new Error(`Server responded with ${res.status}`);
    }
    const raw = await res.text();
    let data;
    try{
      data = JSON.parse(raw);
    }catch(parseErr){
      const snippet = raw.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim().slice(0, 120);
      throw new Error(snippet ? `Invalid JSON: ${snippet}...` : 'Invalid JSON response');
    }
    renderLobbyList(Array.isArray(data.rooms) ? data.rooms : []);
    logNetwork(`Loaded ${Array.isArray(data.rooms) ? data.rooms.length : 0} lobby entries`);
  }catch(err){
    logNetwork(`Failed to load lobbies: ${err.message || err}`);
    renderLobbyList([]);
  }
}

function openLobbyBrowser(){
  lobbyBrowserEl.classList.add('open');
  setMenuOpen(true);
  refreshLobbyList();
}

function closeLobbyBrowser(){
  lobbyBrowserEl.classList.remove('open');
  resetLobbySelection();
  if(!signalingSocket){
    setMenuOpen(false);
  }
}

function gatherHostMeta(){
  const lobbyName = lobbyNameInput.value.trim();
  const capacity = clampCapacity(lobbyMaxInput.value);
  return { lobbyName, capacity };
}

function ensureRoomCode(meta){
  if(roomInput.value.trim()) return;
  const fromName = slugifyRoomName(meta.lobbyName);
  if(fromName){
    roomInput.value = fromName;
  } else {
    roomInput.value = `room-${Math.floor(Math.random()*9000 + 1000)}`;
  }
  if(menuRoomCodeInput){
    menuRoomCodeInput.value = roomInput.value;
  }
}

function joinSelectedLobby(){
  if(!lobbyState.selected) return;
  if(signalingSocket && signalingSocket.readyState === WebSocket.OPEN){
    alert('Already connected to a lobby. Disconnect first.');
    return;
  }
  roomInput.value = lobbyState.selected.code;
  if(menuRoomCodeInput){
    menuRoomCodeInput.value = lobbyState.selected.code;
  }
  closeLobbyBrowser();
  beginSignaling('join');
}

function resetNetworkButtons(){
  btnHost.disabled = false;
  btnJoin.disabled = false;
  btnDisconnect.disabled = true;
}

/* Hide/Show UI behavior */
btnHide.onclick = ()=>{
  const networkDiv = document.getElementById('network');
  const collapsed = networkDiv.dataset.collapsed === '1';
  if(collapsed){
    networkDiv.dataset.collapsed = '';
    networkDiv.style.maxHeight = '';
    networkDiv.style.overflow = '';
    btnHide.textContent = 'Hide UI';
    setMenuOpen(true);
  } else {
    networkDiv.dataset.collapsed = '1';
    networkDiv.style.maxHeight = '32px';
    networkDiv.style.overflow = 'hidden';
    btnHide.textContent = 'Show UI';
    setMenuOpen(false);
  }
};

function closeAllPeers(reason){
  for(const id in dataChannels){
    try{ dataChannels[id].close(); }catch(e){}
  }
  for(const id in peerConnections){
    try{ peerConnections[id].close(); }catch(e){}
  }
  dataChannels = {};
  peerConnections = {};
  peerIdToPlayerId.clear();
  const remoteIds = Object.keys(remotePlayers);
  remoteIds.forEach(id=> removeRemote(id));
  if(reason) logNetwork(reason);
}

function disconnectFromSignaling(message){
  const note = message || 'Disconnected.';
  manualSignalingDisconnect = true;
  manualDisconnectMessage = note;
  savePersistedNetworkSettings({ autoConnect: false });
  if(signalingSocket && (signalingSocket.readyState === WebSocket.OPEN || signalingSocket.readyState === WebSocket.CONNECTING || signalingSocket.readyState === WebSocket.CLOSING)){
    try{ signalingSocket.close(); }catch(e){}
    return;
  }
  handleSignalingSocketClosed(true, note);
}

btnDisconnect.onclick = ()=>{
  disconnectFromSignaling('Disconnected by user');
};

function sendSignal(obj){
  if(!signalingSocket || signalingSocket.readyState !== WebSocket.OPEN) return;
  const payload = {...obj, room: activeRoomCode};
  if(localPeerId){
    payload.from = localPeerId;
  }
  try{
    signalingSocket.send(JSON.stringify(payload));
  }catch(err){
    logNetwork(`Failed to send signal: ${err.message || err}`);
  }
}

function beginSignaling(role, meta = null){
  if(signalingSocket && signalingSocket.readyState === WebSocket.OPEN){
    logNetwork('Already connected to signaling server.');
    return;
  }
  isHost = role === 'host';
  manualSignalingDisconnect = false;
  manualDisconnectMessage = '';
  stopSignalingHeartbeat();
  if(isHost){
    const hostMeta = meta || gatherHostMeta();
    pendingHostMeta = { lobbyName: hostMeta.lobbyName || '', capacity: hostMeta.capacity || 10 };
    ensureRoomCode(pendingHostMeta);
  } else {
    pendingHostMeta = null;
  }
  player.name = nameInput.value || (isHost ? 'Host' : 'Player');
  updatePlayers();
  persistCurrentNetworkForm();
  const url = (serverUrlInput.value || 'ws://localhost:3000').trim();
  if(!url){
    alert('Enter a signaling server URL');
    return;
  }
  activeRoomCode = (roomInput.value || '').trim();
  if(!activeRoomCode){
    alert('Enter or generate a room code.');
    return;
  }
  if(isHost && pendingHostMeta){
    setActiveLobbyName(pendingHostMeta.lobbyName || activeRoomCode);
  } else {
    setActiveLobbyName(activeRoomCode);
  }
  savePersistedNetworkSettings({
    autoConnect: true,
    server: url,
    name: player.name,
    room: activeRoomCode,
    lobbyName: isHost && pendingHostMeta ? (pendingHostMeta.lobbyName || activeRoomCode) : activeLobbyName,
    capacity: isHost && pendingHostMeta ? pendingHostMeta.capacity : Number.parseInt(lobbyMaxInput.value, 10) || 10,
    lastRole: isHost ? 'host' : 'join',
    lastRoom: activeRoomCode,
    lastLobbyName: activeLobbyName
  });
  try{
    signalingSocket = new WebSocket(url);
  }catch(err){
    logNetwork(`Failed to connect: ${err.message || err}`);
    setSignalingStatus('connection failed', 'error');
    resetNetworkButtons();
    return;
  }
  setMenuOpen(true);
  btnHost.disabled = true;
  btnJoin.disabled = true;
  btnDisconnect.disabled = true;
  setSignalingStatus('connecting...', 'connecting');
  logNetwork(`Connecting to ${url} as ${isHost ? 'host' : 'joiner'} (room ${activeRoomCode})`);
  if(lobbyBrowserEl.classList.contains('open')){
    closeLobbyBrowser();
  }

  signalingSocket.onopen = ()=>{
    setSignalingStatus('connected', 'connected');
    btnDisconnect.disabled = false;
    const hello = { type:'hello', role: isHost ? 'host' : 'join', room: activeRoomCode, name: player.name, playerId: player.id };
    if(isHost && pendingHostMeta){
      if(pendingHostMeta.lobbyName){
        hello.lobbyName = pendingHostMeta.lobbyName;
      }
      hello.capacity = pendingHostMeta.capacity || 10;
    }
    try{ signalingSocket.send(JSON.stringify(hello)); }catch(err){ logNetwork(`Failed to register: ${err.message || err}`); }
    lastSignalingPong = performance.now();
    startSignalingHeartbeat();
    try{ signalingSocket.send(JSON.stringify({ type:'ping' })); }
    catch(e){}
  };
  signalingSocket.onclose = ()=>{
    const wasManual = manualSignalingDisconnect;
    const note = wasManual ? (manualDisconnectMessage || 'Disconnected.') : 'Signaling connection closed. Existing peers remain connected.';
    handleSignalingSocketClosed(wasManual, note);
  };
  signalingSocket.onerror = err=>{
    let detail = '';
    if(err && typeof err === 'object'){
      if('message' in err && err.message){
        detail = err.message;
      } else if('type' in err && err.type){
        detail = err.type;
      } else {
        try{ detail = JSON.stringify(err); }
        catch(e){ detail = String(err); }
      }
    } else {
      detail = String(err);
    }
    logNetwork(`Signaling error: ${detail}`);
  };
  signalingSocket.onmessage = ev=>{
    let msg;
    try{ msg = JSON.parse(ev.data); }catch(e){ return; }
    handleSignalMessage(msg);
  };
}

btnHost.onclick = ()=>{
  const meta = gatherHostMeta();
  ensureRoomCode(meta);
  beginSignaling('host', meta);
};
btnJoin.onclick = ()=> beginSignaling('join');
btnCreateLobby.onclick = ()=>{
  const meta = gatherHostMeta();
  if(!meta.lobbyName){
    alert('Enter a lobby name before creating a lobby.');
    return;
  }
  ensureRoomCode(meta);
  beginSignaling('host', meta);
};
btnBrowseLobbies.onclick = ()=>{
  if(signalingSocket && signalingSocket.readyState === WebSocket.OPEN){
    alert('Disconnect before browsing other lobbies.');
    return;
  }
  openLobbyBrowser();
};
btnRefreshLobbies.onclick = ()=> refreshLobbyList();
btnCloseLobbyBrowser.onclick = ()=> closeLobbyBrowser();
btnJoinLobby.onclick = ()=> joinSelectedLobby();
lobbyModeInputs.forEach(input=>{
  input.addEventListener('change', ()=>{
    const isHostClient = player && player.id === lobbyHostId && isHost;
    if(!isHostClient){
      syncLobbyOptionUI();
      return;
    }
    updateLobbyOptionsFromUI();
    broadcastLobbySettings();
  });
});
lobbyMapSelect?.addEventListener('change', ()=>{
  const isHostClient = player && player.id === lobbyHostId && isHost;
  if(!isHostClient){
    syncLobbyOptionUI();
    return;
  }
  updateLobbyOptionsFromUI();
  broadcastLobbySettings();
});
lobbyFriendlyFireInput?.addEventListener('change', ()=>{
  const isHostClient = player && player.id === lobbyHostId && isHost;
  if(!isHostClient){
    syncLobbyOptionUI();
    return;
  }
  updateLobbyOptionsFromUI();
  broadcastLobbySettings();
});
lobbyReadyButton?.addEventListener('click', ()=>{
  localReadyState = !localReadyState;
  lobbyReadyMap.set(player.id, localReadyState);
  upsertLobbyPlayer(player.id, { ready: localReadyState });
  updateLobbyButtons();
  broadcastLobbyReady(localReadyState);
});
lobbyLeaveButton?.addEventListener('click', ()=>{
  disconnectFromSignaling('Left lobby');
  setLobbyStageVisible(false);
});
lobbyStartButton?.addEventListener('click', ()=>{
  if(!(player && player.id === lobbyHostId && isHost)) return;
  hostStartMatch();
});
pauseNameInput?.addEventListener('change', e=>{
  setPlayerDisplayName(e.target.value, { persist: true });
  broadcastLobbyMeta();
});
pauseColorInput?.addEventListener('change', e=>{
  const hex = e.target.value || '#01c119';
  applyCustomCubeColor(hex);
  writeCookie(COLOR_COOKIE_KEY, hex);
  broadcastLobbyMeta();
});

function handleSignalMessage(msg){
  if(msg.type === 'pong'){
    lastSignalingPong = performance.now();
    return;
  }
  if(msg.type === 'welcome'){
    localPeerId = msg.id;
    logNetwork(`Registered on server as ${localPeerId}`);
    if(msg.meta && msg.meta.name){
      setActiveLobbyName(msg.meta.name);
    }
    savePersistedNetworkSettings({
      autoConnect: true,
      lastRole: isHost ? 'host' : 'join',
      lastRoom: activeRoomCode,
      lastLobbyName: activeLobbyName
    });
    return;
  }
  if(msg.type === 'error'){
    setSignalingStatus('error', 'error');
    logNetwork(`Server error: ${msg.message}`);
    btnDisconnect.disabled = false;
    return;
  }
  if(msg.type === 'host-transfer'){
    if(processHostTransferMessage({ ...msg, t:'host_transfer' })){
      return;
    }
  }
  if(msg.type === 'join-request' && isHost){
    logNetwork(`Join request from ${msg.name || msg.peerId}`);
    createOfferForPeer(msg.peerId, msg.name, msg.playerId);
    return;
  }
  if(msg.type === 'offer' && !isHost){
    receiveOfferFromHost(msg);
    return;
  }
  if(msg.type === 'answer' && isHost){
    applyAnswerFromPeer(msg);
    return;
  }
  if(msg.type === 'ice'){
    applyRemoteIceCandidate(msg);
    return;
  }
  if(msg.type === 'peer-left'){
    logNetwork(`Peer ${msg.peerId} left`);
    removeRemote(msg.peerId);
    if(peerConnections[msg.peerId]){
      try{ peerConnections[msg.peerId].close(); }catch(e){}
      delete peerConnections[msg.peerId];
    }
    if(dataChannels[msg.peerId]) delete dataChannels[msg.peerId];
    updatePlayers();
  }
}

function createOfferForPeer(peerId, displayName, playerId){
  const pc = makePeer(peerId, playerId);
  const channel = pc.createDataChannel('game');
  setupDataChannel(peerId, channel, displayName, playerId);
  pc.createOffer().then(offer=>{
    return pc.setLocalDescription(offer);
  }).then(()=>{
    sendSignal({type:'offer', target: peerId, sdp: pc.localDescription});
  }).catch(err=>{
    logNetwork(`Offer error for ${peerId}: ${err.message || err}`);
  });
}

function receiveOfferFromHost(msg){
  const peerId = msg.peerId;
  const pc = makePeer(peerId, msg.playerId);
  pc.ondatachannel = ev=> setupDataChannel(peerId, ev.channel, msg.name, msg.playerId);
  const remoteDesc = new RTCSessionDescription(msg.sdp);
  pc.setRemoteDescription(remoteDesc).then(()=>{
    return pc.createAnswer();
  }).then(answer=>{
    return pc.setLocalDescription(answer);
  }).then(()=>{
    sendSignal({type:'answer', target: peerId, sdp: pc.localDescription});
  }).catch(err=>{
    logNetwork(`Answer error: ${err.message || err}`);
  });
}

function applyAnswerFromPeer(msg){
  const pc = peerConnections[msg.peerId];
  if(!pc) return;
  const remoteDesc = new RTCSessionDescription(msg.sdp);
  pc.setRemoteDescription(remoteDesc).catch(err=>{
    logNetwork(`Remote desc error: ${err.message || err}`);
  });
}

function applyRemoteIceCandidate(msg){
  const pc = peerConnections[msg.peerId];
  if(!pc || !msg.candidate) return;
  pc.addIceCandidate(new RTCIceCandidate(msg.candidate)).catch(err=>{
    logNetwork(`ICE candidate error: ${err.message || err}`);
  });
}

/* helper to make a new RTCPeerConnection */
function makePeer(peerId, remotePlayerId){
  const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  peerConnections[peerId] = pc;
  pc.onicecandidate = ev=>{
    if(ev.candidate){
      sendSignal({type:'ice', target: peerId, candidate: ev.candidate});
    }
  };
  pc.onconnectionstatechange = ()=>{
    if(pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed'){
      removeRemote(peerId);
      delete peerConnections[peerId];
      delete dataChannels[peerId];
      updatePlayers();
    }
  };
  pc.ondatachannel = ev=>{
    setupDataChannel(peerId, ev.channel, undefined, remotePlayerId);
  };
  return pc;
}

/* set up datachannel handlers */
function setupDataChannel(peerId, ch, displayName, remotePlayerId){
  dataChannels[peerId] = ch;
  if(remotePlayerId){
    peerIdToPlayerId.set(peerId, remotePlayerId);
  }
  if(displayName){
    if(!remotePlayers[peerId]) remotePlayers[peerId] = {id: remotePlayerId || peerId, pos:new THREE.Vector3(), yaw:0, pitch:0, name:displayName};
    updatePlayers();
  }
  ch.onopen = ()=>{
    logNetwork(`Data channel open: ${peerId}`);
    try{ sendLobbyHandshake(peerId); }catch(e){}
  };
  ch.onmessage = ev=>{
    try{
      const msg = JSON.parse(ev.data);
      handleRemoteMessage(peerId, msg);
    }catch(e){}
  };
  ch.onclose = ()=>{
    logNetwork(`Data channel closed: ${peerId}`);
    delete dataChannels[peerId];
    delete peerConnections[peerId];
    const mappedId = peerIdToPlayerId.get(peerId);
    if(mappedId){
      removeLobbyPlayer(mappedId);
      peerIdToPlayerId.delete(peerId);
    }
    removeRemote(peerId);
    if(isHost){
      broadcast({t:'peer_left', from:peerId}, peerId);
    }
  };
}

/* broadcast object to all open DCs */
function sendData(obj, skipId){
  const str = JSON.stringify(obj);
  for(const id in dataChannels){
    const ch = dataChannels[id];
    if(id === skipId) continue;
    if(ch && ch.readyState === 'open'){
      try{ ch.send(str); }catch(e){}
    }
  }
}

function broadcast(obj, skipId){
  sendData(obj, skipId);
}

function sendDirect(peerId, obj){
  const ch = dataChannels[peerId];
  if(ch && ch.readyState === 'open'){
    try{ ch.send(JSON.stringify(obj)); }
    catch(e){}
  }
}

function removeRemote(remoteId){
  const rp = remotePlayers[remoteId];
  if(!rp) return;
  if(rp.mesh){ scene.remove(rp.mesh); }
  delete remotePlayers[remoteId];
  updatePlayers();
}

/* handle incoming messages from peers */
function processHostTransferMessage(msg){
  if(!msg) return false;
  const type = msg.t || msg.type;
  if(type !== 'host_transfer' && type !== 'host-transfer'){
    return false;
  }
  const hostPlayerId = msg.playerId || msg.hostPlayerId || msg.host || null;
  if(hostPlayerId){
    upsertLobbyPlayer(hostPlayerId, { name: msg.name || hostPlayerId });
    setLobbyHost(hostPlayerId);
    peerIdToPlayerId.set('host', hostPlayerId);
  }
  if(msg.lobbyName){
    setActiveLobbyName(msg.lobbyName);
  } else if(msg.meta && msg.meta.name){
    setActiveLobbyName(msg.meta.name);
  }
  if(msg.becomeHost || msg.promote){
    logNetwork('Promoted to host role.');
    isHost = true;
    localPeerId = 'host';
    lobbyHostId = player.id;
    setLobbyHost(player.id);
    peerIdToPlayerId.set('host', player.id);
    lobbyPingState.set(player.id, 0);
    closeAllPeers('Reconfiguring as new host');
    peerIdToPlayerId.set('host', player.id);
    if(msg.options){
      lobbyGameOptions = { ...lobbyGameOptions, ...msg.options };
    }
    syncLobbyOptionUI();
    updateLobbyButtons();
    broadcastLobbyMeta();
  } else {
    logNetwork('Host migrated to another player.');
    if(msg.options){
      lobbyGameOptions = { ...lobbyGameOptions, ...msg.options };
    }
    if(isHost){
      isHost = false;
    }
    closeAllPeers('Host migrated, awaiting reconnection');
    if(hostPlayerId){
      peerIdToPlayerId.set('host', hostPlayerId);
    }
    syncLobbyOptionUI();
    updateLobbyButtons();
  }
  return true;
}

function handleRemoteMessage(peerId, msg){
  const sourceId = (peerId === 'host' && msg.from) ? msg.from : peerId;

  if(isHost && peerId !== 'host'){
    const forward = {...msg, from: peerId};
    broadcast(forward, peerId);
  }

  if(msg && msg.t === 'host_transfer'){
    if(processHostTransferMessage(msg)){
      return;
    }
  }

  if(msg.t === 'lobby_meta'){
    const p = msg.player || {};
    const id = p.id || sourceId;
    upsertLobbyPlayer(id, { name: p.name || id, ready: !!p.ready, joinOrder: p.joinOrder ?? Date.now(), color: p.color });
    if(peerId && p.id){ peerIdToPlayerId.set(peerId, p.id); }
    if(msg.host){
      setLobbyHost(msg.host);
      peerIdToPlayerId.set('host', msg.host);
    }
    if(msg.lobbyName){
      setActiveLobbyName(msg.lobbyName);
      updateLobbyStageTitle(msg.lobbyName);
    }
    if(msg.options){
      lobbyGameOptions = { ...lobbyGameOptions, ...msg.options };
      syncLobbyOptionUI();
    }
    if(isHost){
      const roster = getLobbyPlayersArray();
      sendDirect(peerId, { t:'lobby_state', roster, options: lobbyGameOptions, host: lobbyHostId, lobbyName: activeLobbyName });
    }
    return;
  }

  if(msg.t === 'lobby_settings'){
    if(!isHost){
      lobbyGameOptions = { ...lobbyGameOptions, ...(msg.options || {}) };
      syncLobbyOptionUI();
    }
    return;
  }

  if(msg.t === 'lobby_ready'){
    const ready = !!msg.ready;
    lobbyReadyMap.set(sourceId, ready);
    upsertLobbyPlayer(sourceId, { ready });
    if(isHost){
      const roster = getLobbyPlayersArray();
      sendData({ t:'lobby_state', roster, options: lobbyGameOptions, host: lobbyHostId, lobbyName: activeLobbyName });
    }
    return;
  }

  if(msg.t === 'lobby_state'){
    lobbyPlayersState.clear();
    lobbyReadyMap.clear();
    lobbyPingState.clear();
    const roster = Array.isArray(msg.roster) ? msg.roster : [];
    roster.forEach((entry, idx)=>{
      const id = entry.id || entry.peerId || `peer-${idx}`;
      upsertLobbyPlayer(id, { name: entry.name || id, ready: !!entry.ready, joinOrder: entry.joinOrder ?? (idx + 1), color: entry.color });
      lobbyReadyMap.set(id, !!entry.ready);
    });
    if(msg.options){
      lobbyGameOptions = { ...lobbyGameOptions, ...msg.options };
      syncLobbyOptionUI();
    }
    if(msg.host){ setLobbyHost(msg.host); }
    if(msg.lobbyName){
      setActiveLobbyName(msg.lobbyName);
      updateLobbyStageTitle(msg.lobbyName);
    }
    updateLobbyButtons();
    return;
  }

  if(msg.t === 'lobby_start'){
    if(msg.host){ setLobbyHost(msg.host); }
    if(msg.lobbyName){
      setActiveLobbyName(msg.lobbyName);
      updateLobbyStageTitle(msg.lobbyName);
    }
    if(msg.options){
      lobbyGameOptions = { ...msg.options };
      startMatchFromOptions(msg.options);
    }
    setLobbyStageVisible(false);
    return;
  }

  if(msg.t === 'lobby_ping'){
    if(typeof msg.ts === 'number'){
      const response = { t:'lobby_pong', ts: msg.ts, id: msg.id || sourceId };
      if(peerId === 'host'){
        sendDirect('host', response);
      } else {
        sendDirect(peerId, response);
      }
    }
    return;
  }

  if(msg.t === 'lobby_pong'){
    if(typeof msg.ts === 'number'){
      const latency = Math.round(Math.max(1, performance.now() - msg.ts));
      const id = msg.id || sourceId;
      lobbyPingState.set(id, latency);
      renderLobbyRoster();
    }
    return;
  }

  if(msg.t === 'peer_left'){
    const mappedId = peerIdToPlayerId.get(sourceId);
    if(mappedId){
      removeLobbyPlayer(mappedId);
      peerIdToPlayerId.delete(sourceId);
    }
    removeRemote(sourceId);
    return;
  }

  if(msg.t === 'state'){
    if(!remotePlayers[sourceId]) remotePlayers[sourceId] = {id:sourceId, pos:new THREE.Vector3(), yaw:0, pitch:0, name:msg.name||sourceId};
    const rp = remotePlayers[sourceId];
    rp.pos.set(msg.p[0], msg.p[1], msg.p[2]);
    rp.yaw = msg.y; rp.pitch = msg.r; rp.hp = msg.hp; rp.name = msg.name || sourceId;
    const animMsg = msg.a || {};
    rp.anim = {
      mode: animMsg.m || (rp.anim ? rp.anim.mode : 'idle'),
      speed: typeof animMsg.s === 'number' ? animMsg.s : (rp.anim ? rp.anim.speed : 0),
      variant: typeof animMsg.v === 'number' ? animMsg.v : (rp.anim ? rp.anim.variant : 0)
    };
    updatePlayers();
  }
  if(msg.t === 'parry'){
    const cfg = msg.config || {};
    const ownerId = msg.owner || sourceId;
    scheduleParryReturn(cfg, ownerId, {dir: cfg.dir});
    return;
  }
  if(msg.t === 'enemy_shoot'){
    if(msg.shot){
      spawnBulletFromShot(msg.shot, msg.enemyId || 'enemy');
    }
    return;
  }

  if(msg.t === 'shoot'){
    if(Array.isArray(msg.shots)){
      msg.shots.forEach(shot=> spawnBulletFromShot(shot, sourceId));
    } else if(msg.p && msg.d){
      let fallbackType = 'pulse';
      if(msg.w === 2) fallbackType = 'rocket';
      else if(msg.w === 3) fallbackType = 'pellet';
      else if(msg.w === 4) fallbackType = 'pee';
      const fallback = {
        type: fallbackType,
        pos: msg.p,
        dir: msg.d,
        speed: msg.w === 2 ? 8 : msg.w === 4 ? 12 : 12,
        size: msg.w === 2 ? 0.3 : msg.w === 4 ? 0.06 : 0.1,
        color: msg.w === 2 ? 0xffaa00 : msg.w === 4 ? 0xfff57a : 0xffff00,
        damage: msg.w === 2 ? 2 : msg.w === 4 ? 0.03 : 1,
        ttl: msg.w === 2 ? 4 : msg.w === 4 ? 0.6 : 2,
        hitRadius: msg.w === 2 ? 0.6 : msg.w === 4 ? 0.28 : 0.45,
        explode: msg.w === 2 ? 1.8 : 0,
        gravity: msg.w === 4 ? 4.2 : 0
      };
      spawnBulletFromShot(fallback, sourceId);
    }
  }
  if(msg.t === 'reset'){
    bullets.forEach(b=>scene.remove(b)); bullets.length = 0;
    enemies.forEach(e=>enemyGroup.remove(e)); enemies.length = 0;
    waveState.current = 0;
    waveState.kills = 0;
    waveState.killTarget = 0;
    waveState.pendingSpawns = 0;
    waveState.spawnTimer = 0;
    waveState.spawnInterval = 2.4;
    waveState.spawnedGiant = false;
    if(nextWaveTimeout){ clearTimeout(nextWaveTimeout); nextWaveTimeout = null; }
    score = 0;
    player.hp = 3;
    player.alive = true;
    updateHUD();
    if(gameHasStarted){
      startNextWave(true);
    }
  }
}

/* periodic state broadcast */
setInterval(()=>{
  const payload = {
    t:'state',
    id:player.id,
    p:[player.pos.x, player.pos.y, player.pos.z],
    y:player.yaw,
    r:player.pitch,
    hp:player.hp,
    name: nameInput.value || player.name,
    a: { m: player.anim.mode, s: Number((player.anim.speed||0).toFixed(2)), v: player.anim.variant || 0 }
  };
  sendData(payload);
}, 80);

/* -------------------------
   Game logic & physics
   ------------------------- */
/* Movement vectors: CORRECT so W is forward */
function updatePlayer(dt){
  const forward = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));
  const inputMove = aggregatedInput.move.clone();
  const move = new THREE.Vector3();
  if(inputMove.lengthSq()>0){
    move.addScaledVector(forward, inputMove.y);
    move.addScaledVector(right, inputMove.x);
    if(move.lengthSq()>0) move.normalize();
  }
  const wasGrounded = player.grounded;
  player.slideCooldown = Math.max(0, player.slideCooldown - dt);
  player.dashCooldown = Math.max(0, player.dashCooldown - dt);
  const dashWasActive = player.dashTimer > 0;
  if(player.dashTimer > 0){
    player.dashTimer = Math.max(0, player.dashTimer - dt);
    if(player.dashTimer <= 0){
      player.dashVector.set(0,0,0);
    }
  }

  const slidePressed = aggregatedInput.slidePressed && player.grounded && move.lengthSq()>0 && player.slideCooldown <= 0 && !player.isSliding;
  if(slidePressed){
    player.isSliding = true;
    player.slideTimer = 0.65;
    player.slideDirection.copy(move.lengthSq()>0 ? move : forward);
    player.slideCooldown = 0.95;
  }
  if(player.isSliding){
    player.slideTimer -= dt;
    const releaseSlide = !aggregatedInput.slideHeld && player.slideTimer < 0.3;
    if(player.slideTimer <= 0 || releaseSlide){
      player.isSliding = false;
    } else if(move.lengthSq()>0){
      player.slideDirection.lerp(move, Math.min(1, dt*6));
      if(player.slideDirection.lengthSq()>0){ player.slideDirection.normalize(); }
    }
  }

  const sprinting = keyboardState.slideHeld && !player.isSliding && player.grounded && move.lengthSq()>0;
  const controlDir = player.isSliding ? player.slideDirection.clone() : move.clone();
  const baseSpeed = player.isSliding ? player.speed * 2.6 : player.speed * (player.grounded ? (sprinting ? 1.35 : 1) : 0.78);
  controlDir.multiplyScalar(baseSpeed);

  if(dashWasActive){
    player.velocity.x = player.dashVector.x * 11;
    player.velocity.z = player.dashVector.z * 11;
  } else {
    const accel = player.grounded ? 12 : 4.5;
    player.velocity.x = THREE.MathUtils.damp(player.velocity.x, controlDir.x, accel, dt);
    player.velocity.z = THREE.MathUtils.damp(player.velocity.z, controlDir.z, accel, dt);
  }

  const nextPos = player.pos.clone();
  nextPos.x += player.velocity.x * dt;
  nextPos.z += player.velocity.z * dt;
  const collision = resolveWorldCollisions(nextPos);
  player.pos.x = collision.position.x;
  player.pos.z = collision.position.z;
  if(collision.normal){
    if(!player.grounded){
      player.wallNormal.copy(collision.normal);
      player.wallTouchTimer = 0.28;
    } else {
      player.wallTouchTimer = 0;
    }
    if(player.climbing){
      player.pos.addScaledVector(collision.normal, -0.02);
    }
    if(!player.isSliding){
      // keep facing consistent
    }
  } else {
    player.wallTouchTimer = Math.max(0, player.wallTouchTimer - dt);
  }
  if(player.wallTouchTimer <= 0){
    player.wallNormal.set(0,0,0);
    if(!player.grounded){
      player.climbing = false;
    }
  }

  if(!player.climbing && player.wallTouchTimer > 0 && aggregatedInput.jumpHeld && !player.grounded){
    player.climbing = true;
    player.climbTimer = 0.6;
  }
  if(player.climbing){
    player.climbTimer = Math.max(0, player.climbTimer - dt);
    if(player.climbTimer <= 0 || !aggregatedInput.jumpHeld){
      player.climbing = false;
    }
  }

  player.velocity.y -= player.gravity * dt;
  if(player.climbing){
    player.velocity.y = Math.max(player.velocity.y, player.climbSpeed);
    if(player.wallNormal.lengthSq()>0){
      player.pos.addScaledVector(player.wallNormal, -0.02);
    }
  }
  player.pos.y += player.velocity.y * dt;

  if(player.pos.y <= player.groundHeight){
    if(player.velocity.y < 0) player.velocity.y = 0;
    player.pos.y = player.groundHeight;
    if(!player.grounded){
      player.airJumpsRemaining = Math.max(0, player.maxJumpCharges - 1);
    }
    player.grounded = true;
    player.climbing = false;
    player.climbTimer = 0;
  } else {
    player.grounded = false;
  }

  if(player.grounded){
    player.coyoteTimer = 0.14;
    player.wallTouchTimer = 0;
  } else {
    player.coyoteTimer = wasGrounded ? 0.14 : Math.max(0, player.coyoteTimer - dt);
  }

  const horizontalSpeed = Math.sqrt(player.velocity.x*player.velocity.x + player.velocity.z*player.velocity.z);
  player.anim.speed = Math.min(1.5, horizontalSpeed / player.speed);
  if(player.isSliding){
    player.anim.mode = 'slide';
  } else if(player.dashTimer > 0){
    player.anim.mode = 'dash';
  } else if(player.climbing){
    player.anim.mode = 'climb';
  } else if(!player.grounded){
    player.anim.mode = 'air';
  } else if(player.anim.speed > 0.15){
    player.anim.mode = sprinting ? 'sprint' : 'run';
  } else {
    player.anim.mode = 'idle';
  }
  player.anim.variant = sprinting ? 1 : 0;

  // camera
  if(player.thirdPerson){
    alexMesh.visible = true;
    const distance = 5;
    const phi = Math.PI/2 + player.pitch;
    const theta = player.yaw;
    const camX = player.pos.x + distance * Math.sin(phi) * Math.sin(theta);
    const camY = player.pos.y + distance * Math.cos(phi);
    const camZ = player.pos.z + distance * Math.sin(phi) * Math.cos(theta);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(player.pos.x, player.pos.y + 0.7, player.pos.z);
  } else {
    alexMesh.visible = false;
    const camHeight = player.isSliding ? 0.45 : 0.7;
    camera.position.copy(player.pos.clone().add(new THREE.Vector3(0,camHeight,0)));
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
  }

  alexMesh.position.copy(player.pos);
  if(player.isSliding){
    alexMesh.position.y -= 0.15;
  }
  alexMesh.rotation.y = player.yaw;
  const avatar = alexMesh.children[0];
  if(avatar){
    updateHumanoidRig(avatar, player.anim, dt);
  }
}

/* bullets & enemies update */
function isPlayerJumping(){
  return !player.grounded;
}

function updateBullets(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    const data = b.userData || {};
    if(typeof data.life === 'number'){
      data.life -= dt;
    } else {
      data.life = 3;
    }

    if(data.type === 'beam'){
      if(b.material && typeof b.material.opacity === 'number' && data.duration){
        b.material.opacity = Math.max(0, (data.life / data.duration) * 0.7);
      }
      applyBeamDamage(b);
      if(data.life <= 0){
        cleanupBullet(i);
      }
      continue;
    }

    if(data.velocity){
      if(data.gravity){
        data.velocity.y -= data.gravity * dt;
      }
      b.position.addScaledVector(data.velocity, dt);
    } else if(data.dir){
      b.position.addScaledVector(data.dir, (data.speed ?? 0) * dt);
    }

    if(data.type === 'pee' && b.material && typeof b.material.opacity === 'number' && data.maxLife){
      const lifeRatio = Math.max(0, Math.min(1, data.life / data.maxLife));
      b.material.opacity = 0.25 + lifeRatio * 0.55;
    }

    let removed = false;
    for(let j=enemies.length-1;j>=0;j--){
      const enemy = enemies[j];
      if(!enemy) continue;
      const enemyRadius = (enemy.userData && typeof enemy.userData.hitRadius === 'number') ? enemy.userData.hitRadius : 0.6;
      const dist = b.position.distanceTo(enemy.position);
      if(dist <= (data.hitRadius ?? 0.45) + enemyRadius){
        if(data.type === 'rocket' && data.explode){
          applyExplosion(b.position, data.explode, data.damage ?? 2);
        } else {
          const shouldScare = data.type === 'pee' && data.owner === player.id && isPlayerJumping();
          const onSurvive = shouldScare ? scareEnemy : undefined;
          damageEnemyAtIndex(j, data.damage ?? 1, onSurvive);
        }
        if(data.pierce && data.pierce > 0){
          data.pierce -= 1;
          continue;
        }
        removed = true;
        break;
      }
    }

    if(!removed && player.alive){
      const ownerIsPlayer = isPlayerShotOwner(data.owner);
      if(ownerIsPlayer && (!friendlyFireEnabled || data.owner === player.id)){
        continue;
      }
      if(data.owner === player.id){
        continue;
      }
      const playerHeight = player.pos.clone().add(new THREE.Vector3(0,0.6,0));
      const distToPlayer = b.position.distanceTo(playerHeight);
      const threshold = (data.hitRadius ?? 0.45) + player.radius * 0.4;
      if(distToPlayer <= threshold){
        if(player.parryActive && punchState.parryWindow > 0 && data.owner){
          parryIncomingShot(b, data, i);
          continue;
        }
        if(data.parry){
          continue;
        }
        player.hp = Math.max(0, player.hp - (data.damage ?? 0.5));
        updateHUD();
        playSound('hit', {pitch:0.5});
        if(player.hp <= 0){
          player.hp = 0;
          player.alive = false;
          updateHUD();
          gameOverDiv.style.display = 'block';
        }
        cleanupBullet(i);
        continue;
      }
    }

    if(removed){
      cleanupBullet(i);
      continue;
    }

    if(data.life <= 0){
      if(data.type === 'rocket' && data.explode){
        applyExplosion(b.position, data.explode, data.damage ?? 2);
      }
      cleanupBullet(i);
    }
  }
}
const enemyScratch = new THREE.Vector3();
const enemyMoveDir = new THREE.Vector3();
const punchScratch = new THREE.Vector3();

function chooseEnemyTarget(enemy){
  if(player.alive && player.stealthTimer <= 0){
    return {pos: player.pos, id: player.id, local: true};
  }
  let closest = null;
  let closestDistSq = Infinity;
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(!rp || !rp.pos) continue;
    if(typeof rp.hp === 'number' && rp.hp <= 0) continue;
    const distSq = enemy.position.distanceToSquared(rp.pos);
    if(distSq < closestDistSq){
      closestDistSq = distSq;
      closest = {pos: rp.pos, id, local: false};
    }
  }
  if(closest){
    return closest;
  }
  if(player.alive){
    return {pos: player.pos, id: player.id, local: true};
  }
  return null;
}
function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(!e) continue;
    const data = e.userData || (e.userData = {});
    const targetInfo = chooseEnemyTarget(e);
    const targetPos = (targetInfo && targetInfo.pos) ? targetInfo.pos : player.pos;
    enemyScratch.copy(targetPos).sub(e.position);
    enemyScratch.y = 0;
    const dist = enemyScratch.length();
    if(dist === 0) continue;
    const type = data.type || 'chaser';
    let animSpeed = 0.6;
    if(data.fleeTimer && data.fleeTimer > 0){
      data.fleeTimer = Math.max(0, data.fleeTimer - dt);
      const fleeDir = enemyScratch.clone().normalize().negate();
      const fleeSpeed = data.fleeSpeed || 4.5;
      animSpeed = Math.min(1.4, fleeSpeed / 4);
      e.position.addScaledVector(fleeDir, fleeSpeed * dt);
    } else if(type === 'shooter'){
      const desired = 8;
      const chaseDir = enemyScratch.clone().normalize();
      const approach = dist - desired;
      enemyMoveDir.set(0,0,0);
      if(approach > 1){
        enemyMoveDir.copy(chaseDir);
      } else if(approach < -1.2){
        enemyMoveDir.copy(chaseDir).multiplyScalar(-1);
      }
      if(enemyMoveDir.lengthSq() > 0){
        const speed = data.speed || 1.4;
        animSpeed = Math.min(1.1, speed / 1.3);
        e.position.addScaledVector(enemyMoveDir, (data.speed || 1.4) * dt);
      } else {
        animSpeed = 0.35;
      }
      data.shootTimer = (data.shootTimer || 0) - dt;
      if(data.shootTimer <= 0){
        enemyShoot(e, targetInfo);
        data.shootTimer = data.shootCooldown || 1.8;
      }
    } else {
      const chaseDir = enemyScratch.clone().normalize();
      const chaseSpeed = data.speed || 1.2;
      animSpeed = Math.min(1.25, chaseSpeed / 1.4);
      e.position.addScaledVector(chaseDir, chaseSpeed * dt);
    }

    const contactRadius = (data.hitRadius || (type === 'giant' ? 1.4 : 0.9)) + 0.3;
    if(player.alive){
      const distToPlayer = e.position.distanceTo(player.pos);
      if(distToPlayer < contactRadius){
        const damage = data.damage || (type === 'shooter' ? 0.6 : 1);
        player.hp = Math.max(0, player.hp - damage * dt * 2.5);
        updateHUD();
        if(player.hp <= 0){
          player.hp = 0;
          player.alive = false;
          updateHUD();
          waveState.active = false;
          waveState.pendingSpawns = 0;
          gameOverDiv.style.display = 'block';
        }
      }
    }

    const lookPos = (targetInfo && targetInfo.pos) ? targetInfo.pos : player.pos;
    e.lookAt(lookPos.x, e.position.y, lookPos.z);
    const mode = animSpeed > 0.4 ? 'run' : 'idle';
    updateHumanoidRig(e, {mode, speed:animSpeed}, dt);
  }
}

/* render remote players */
function renderRemotes(dt){
  const template = getActivePlayerTemplate();
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(!rp.mesh){
      rp.mesh = cloneTemplate(template);
      scene.add(rp.mesh);
    }
    if(rp.pos) rp.mesh.position.copy(rp.pos);
    rp.mesh.rotation.y = rp.yaw || 0;
    if(rp.mesh){
      updateHumanoidRig(rp.mesh, rp.anim || {mode:'idle', speed:0}, dt);
    }
  }
}

/* pause logic controlled by menuOpen */
function gameTick(now){
  const rawDt = Math.min(0.05, (now - (gameTick.last||now))/1000);
  gameTick.last = now;
  updateAggregatedInput(rawDt);
  updateParry(rawDt);
  const slowMoActive = weaponWheelState.open && !weaponWheelIsMultiplayer();
  const timeScale = slowMoActive ? 0.25 : 1;
  const dt = rawDt * timeScale;
  const freezeWorld = parryState.timeStop > 0;
  const playerFrozen = player.parryFrozen || freezeWorld;
  const worldDt = freezeWorld ? 0 : dt;
  const playerDt = playerFrozen ? 0 : dt;
  shootState.cooldown = Math.max(0, shootState.cooldown - rawDt);
  if(weaponState.recharging){
    weaponState.rechargeTimer = Math.max(0, weaponState.rechargeTimer - rawDt);
    if(weaponState.rechargeTimer <= 0){
      weaponState.recharging = false;
      weaponState.charge = 1;
      weaponState.rechargeTimer = 0;
      weaponState.rechargeDuration = 0;
      weaponState.label = '';
      if(armRig && typeof armRig.endRecharge === 'function'){
        armRig.endRecharge();
      }
    }
  }

  if(!menuOpen){
    if(gameHasStarted && waveState.active && player.alive){
      waveState.spawnTimer -= worldDt;
      while(waveState.spawnTimer <= 0 && waveState.pendingSpawns > 0){
        spawnEnemy();
        waveState.spawnTimer += waveState.spawnInterval;
        waveState.spawnInterval = Math.max(0.75, waveState.spawnInterval * 0.97);
      }
    }
    if(player.alive){
      updatePlayer(playerDt);
      updatePunch(dt);
      updateBullets(worldDt);
      updateEnemies(worldDt);
      if(!playerFrozen && shootState.down){
        shoot();
      }
    }
    renderRemotes(dt);
  }

  if(armRig){
    armRig.update(dt);
  }

  lobbyPingTimer += rawDt * 1000;
  if(lobbyPingTimer >= LOBBY_PING_INTERVAL){
    lobbyPingTimer = 0;
    pumpLobbyPings();
  }

  updateHUD();
  updatePlayers();
  renderer.render(scene, camera);
  requestAnimationFrame(gameTick);
}
initializeMenuUI();
requestAnimationFrame(gameTick);

/* Expose debugging objects */
window._peers = peerConnections;
window._dcs = dataChannels;
window._remote = remotePlayers;
window._send = sendData;

window.addEventListener('beforeunload', ()=>{
  try{ sendData({t:'peer_left', from: isHost ? 'host' : 'self'}); }catch(e){}
});

</script>
</body>
</html>
